<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Brian&#39;s Home</title>
  
  <subtitle>Stay Hungry, Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://brianyi.github.io/"/>
  <updated>2019-05-07T05:06:07.090Z</updated>
  <id>https://brianyi.github.io/</id>
  
  <author>
    <name>Brian Yi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[leetcode]214.最短回文串</title>
    <link href="https://brianyi.github.io/2019/05/07/leetcode-214-%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>https://brianyi.github.io/2019/05/07/leetcode-214-最短回文串/</id>
    <published>2019-05-07T04:00:26.000Z</published>
    <updated>2019-05-07T05:06:07.090Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/07/leetcode-214-最短回文串/Image21.png"><h3 id="方法一-KMP算法"><a href="#方法一-KMP算法" class="headerlink" title="方法一: KMP算法"></a>方法一: KMP算法</h3><p>时间复杂度: $O(m+n)$</p><blockquote><p>解题思路: 实际就是求原串从左到右的最长回文串(必须包含左边所有字符),此处采用<strong>倒置+KMP算法</strong>来缩短匹配时间</p><ol><li>将字符串倒置,原串作为模式串pat,倒置串作为主串txt</li><li>求出模式串pat的nextval[]值,然后进行字符串匹配,得到的模式串pat最长匹配长度即为模式串pat从第一个字符开始的最大回文串(匹配过程时间复杂度只需要$O(m+n)$)</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nextval[<span class="number">40005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_nextval</span><span class="params">(<span class="built_in">string</span> pat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">-1</span>,len=pat.size();</span><br><span class="line">    nextval[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;i&lt;len&amp;&amp;j&lt;len;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">-1</span>||pat[i]==pat[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++,j++;</span><br><span class="line">            <span class="keyword">if</span> (pat[i]==pat[j])</span><br><span class="line">                nextval[i]=nextval[j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextval[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j=nextval[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="built_in">string</span> txt)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> pat=txt;</span><br><span class="line">    reverse(txt.begin(),txt.end()); <span class="comment">// O(n)</span></span><br><span class="line">    get_nextval(pat); <span class="comment">// </span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,lenTxt=txt.size(),lenPat=pat.size();</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;lenTxt&amp;&amp;j&lt;lenPat;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">-1</span>||txt[i]==pat[j])</span><br><span class="line">            i++,j++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = nextval[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> txt.substr(<span class="number">0</span>,lenTxt-j)+pat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/07/leetcode-214-最短回文串/Image21.png&quot;&gt;
&lt;h3 id=&quot;方法一-KMP算法&quot;&gt;&lt;a href=&quot;#方法一-KMP算法&quot; class=&quot;headerlink&quot; title=&quot;方法一: KMP算法&quot;&gt;&lt;/a&gt;方法一
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="回文串" scheme="https://brianyi.github.io/tags/%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    
      <category term="KMP" scheme="https://brianyi.github.io/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]TOC汇总</title>
    <link href="https://brianyi.github.io/2019/05/07/leetcode-TOC%E6%B1%87%E6%80%BB/"/>
    <id>https://brianyi.github.io/2019/05/07/leetcode-TOC汇总/</id>
    <published>2019-05-07T00:31:49.000Z</published>
    <updated>2019-05-07T03:06:59.931Z</updated>
    
    <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="请输入文章密码" />    <label for="pass">请输入文章密码</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      文章内容已被加密.&lt;/br&gt;
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="TOC" scheme="https://brianyi.github.io/tags/TOC/"/>
    
  </entry>
  
  <entry>
    <title>[algorithm]排序</title>
    <link href="https://brianyi.github.io/2019/05/06/algorithm-%E6%8E%92%E5%BA%8F/"/>
    <id>https://brianyi.github.io/2019/05/06/algorithm-排序/</id>
    <published>2019-05-06T14:58:06.000Z</published>
    <updated>2019-05-06T15:23:31.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-排序算法"><a href="#一-排序算法" class="headerlink" title="一.排序算法"></a>一.排序算法</h2><h3 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h3><h4 id="1-直接插入排序-插入类"><a href="#1-直接插入排序-插入类" class="headerlink" title="1) 直接插入排序:(插入类)"></a>1) 直接插入排序:(插入类)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( R[i].key &lt; R[i - <span class="number">1</span>].key )</span><br><span class="line">        &#123;</span><br><span class="line">            R[<span class="number">0</span>] = R[i];</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; <span class="number">0</span> &amp;&amp; ( R[<span class="number">0</span>].key &lt; R[j].key ); j-- )</span><br><span class="line">                R[j + <span class="number">1</span>] = R[j];</span><br><span class="line">            R[j + <span class="number">1</span>] = R[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况(顺序有序):</p><p>　　1)比较次数: $\sum_{i=2}^{n} 1=n-1$</p><p>　　2)移动次数: 0</p><p>最坏情况(逆序有序):</p><p>　　1)比较次数: $\sum_{i=2}^{n} i=\frac {(n+2)(n-1)}{2}$</p><p>　　2)移动次数: $\sum_{i=2}^{n} (i+1)=\frac {(n+4)(n-1)}{2}$</p><h4 id="2-折半插入排序-插入类"><a href="#2-折半插入排序-插入类" class="headerlink" title="2)折半插入排序:(插入类)"></a>2)折半插入排序:(插入类)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BiInsertSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        R[<span class="number">0</span>] = R[i];</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>, high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( low &lt;= high )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = ( low + high ) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ( R[<span class="number">0</span>].key &lt; R[m].key ) high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; high; j-- )</span><br><span class="line">            R[j + <span class="number">1</span>] = R[j];</span><br><span class="line">        R[j + <span class="number">1</span>] = R[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-希尔排序-又称缩小增量排序-插入类"><a href="#3-希尔排序-又称缩小增量排序-插入类" class="headerlink" title="3)希尔排序(又称缩小增量排序)(插入类)"></a>3)希尔排序(又称缩小增量排序)(插入类)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当dk=1时,即为直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> dk = n / <span class="number">2</span>; dk &gt;= <span class="number">1</span>; dk /= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = dk + <span class="number">1</span>; i &lt;= n; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( R[i].key &lt; R[i - dk].key )</span><br><span class="line">            &#123;</span><br><span class="line">                R[<span class="number">0</span>] = R[i];</span><br><span class="line">            <span class="keyword">for</span> ( j = i - dk; j &gt; <span class="number">0</span> &amp;&amp; ( R[<span class="number">0</span>].key &lt; R[j].key ); j -= dk )</span><br><span class="line">                    R[j + dk] = R[j];</span><br><span class="line">                R[j + dk] = R[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-交换排序"><a href="#2-交换排序" class="headerlink" title="2.交换排序"></a>2.交换排序</h3><h4 id="1-起泡排序-冒泡排序-交换类"><a href="#1-起泡排序-冒泡排序-交换类" class="headerlink" title="1)起泡排序(冒泡排序)(交换类)"></a>1)起泡排序(冒泡排序)(交换类)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = n; j &gt; i; j-- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (R[j].key &lt; R[j<span class="number">-1</span>].key )</span><br><span class="line">            &#123;</span><br><span class="line">                swap( R[j], R[j - <span class="number">1</span>] );</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( !flag ) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-快速排序-交换类"><a href="#2-快速排序-交换类" class="headerlink" title="2)快速排序:(交换类)"></a>2)快速排序:(交换类)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Partition</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快排</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( low &gt;= high ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivotpos = Partition( R, low, high );</span><br><span class="line">    QuickSort( R, low, pivotpos - <span class="number">1</span> );</span><br><span class="line">    QuickSort( R, pivotpos + <span class="number">1</span>, high );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 划分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Partition</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElemType pivot = R[low];</span><br><span class="line">    <span class="keyword">while</span> ( low &lt; high )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high &amp;&amp; R[high].key &gt;= pivot.key ) high--;</span><br><span class="line">        R[low] = R[high];</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high &amp;&amp; R[low].key &lt;= pivot.key ) low++;</span><br><span class="line">        R[high] = R[low];</span><br><span class="line">    &#125;</span><br><span class="line">    R[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3.选择排序"></a>3.选择排序</h3><h4 id="1-简单选择排序-选择类"><a href="#1-简单选择排序-选择类" class="headerlink" title="1)简单选择排序(选择类)"></a>1)简单选择排序(选择类)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( R[j].key &lt; R[min].key ) min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( min != i ) swap( R[i], R[min] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-堆排序-选择类"><a href="#2-堆排序-选择类" class="headerlink" title="2)堆排序(选择类)"></a>2)堆排序(选择类)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">( ElemType R[], <span class="keyword">int</span> s, <span class="keyword">int</span> n )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt; <span class="number">0</span>; i-- )</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">( R, i, n )</span></span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; i-- )</span><br><span class="line">    &#123;</span><br><span class="line">        swap( R[i], R[<span class="number">1</span>] );</span><br><span class="line">        AdjustDown( R, <span class="number">1</span>, i - <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">( ElemType R[], <span class="keyword">int</span> s, <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    R[<span class="number">0</span>] = R[s];</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span> * s; i &lt;= n; i *= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( i &lt; n&amp;&amp;R[i].key &lt; R[i + <span class="number">1</span>].key ) i++;</span><br><span class="line">        <span class="keyword">if</span> (R[<span class="number">0</span>].key  &gt;=R[i].key ) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            R[s] = R[i]; s = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    R[s] = R[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向上调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustUp</span><span class="params">( ElemType R[], <span class="keyword">int</span> s )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    R[<span class="number">0</span>] = R[s];</span><br><span class="line">    <span class="keyword">int</span> p = s / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> ( p &gt;&amp;&amp; R[p].key &lt; R[<span class="number">0</span>].key )</span><br><span class="line">    &#123;</span><br><span class="line">        R[s] = R[p];</span><br><span class="line">        s = p;</span><br><span class="line">        p /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    R[s] = R[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-归并排序-归并类"><a href="#4-归并排序-归并类" class="headerlink" title="4.归并排序(归并类)"></a>4.归并排序(归并类)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( low &gt;= high ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = ( low + high ) / <span class="number">2</span>;</span><br><span class="line">    MergeSort( R, low, mid );</span><br><span class="line">    MergeSort( R, mid + <span class="number">1</span>, high );</span><br><span class="line">    Merge( R, low, mid, high );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElemType B[MAXSIZE];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span> ( i = low; i &lt;= high; i++ )</span><br><span class="line">        B[i] = R[i];</span><br><span class="line">    i = k = low, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ( i &lt;= mid &amp;&amp; j &lt;= high )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( B[i].key &lt;= B[j].key )</span><br><span class="line">            R[k++] = B[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            R[k++] = B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( i &lt;= mid ) R[k++] = B[i++];</span><br><span class="line">    <span class="keyword">while</span> ( j &lt;= high ) R[k++] = B[j++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-综合题-算法"><a href="#二-综合题-算法" class="headerlink" title="二.综合题(算法)"></a>二.综合题(算法)</h2><p>1.设顺序表用数组R[]表示,表中存储在数组下标1~m+n的范围内,前m个元素递增有序,后n个元素递增有序,设计一个算法,使得整个顺序表有序<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> m, <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = m + <span class="number">1</span>; i &lt;= m + n; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( R[i].key &lt; R[i - <span class="number">1</span>].key )</span><br><span class="line">        &#123;</span><br><span class="line">            R[<span class="number">0</span>] = R[i];</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; <span class="number">0</span> &amp;&amp; ( R[<span class="number">0</span>].key &lt; R[j].key ); j-- )</span><br><span class="line">                R[j + <span class="number">1</span>] = R[j];</span><br><span class="line">            R[j + <span class="number">1</span>] = R[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.计数排序:对表进行排序并将结果放到另一个新的表中,要求表中所有关键码互不相同<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountSort</span><span class="params">( ElemType A[], ElemType B[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++ )</span><br><span class="line">            <span class="keyword">if</span> ( A[i].key &gt; A[j].key )cnt++;</span><br><span class="line">        B[cnt] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.双向冒泡排序<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思想:第一趟通过交换把最大的放最后,第二趟通过交换把最小的放最前,反复进行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">( ElemType A[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = n - <span class="number">1</span>, i;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> ( low &lt; high &amp;&amp; flag )</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = low; i &lt; high; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i]&gt;A[i+<span class="number">1</span>] )</span><br><span class="line">            &#123;</span><br><span class="line">                swap( A[i], A[i + <span class="number">1</span>] ); flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high--;</span><br><span class="line">        <span class="keyword">for</span> ( i = high; i &gt; low; i-- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( A[i] &lt; A[i - <span class="number">1</span>] )</span><br><span class="line">            &#123;</span><br><span class="line">                swap( A[i], A[i - <span class="number">1</span>] ); flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        low++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.单链表的简单选择排序(假设不带表头结点)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">( LinkList&amp; L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList h, p, s, pre, r;</span><br><span class="line">    h = L;</span><br><span class="line">    <span class="keyword">while</span> ( h )</span><br><span class="line">    &#123;</span><br><span class="line">        p = s = h; pre = r = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 找最大结点s</span></span><br><span class="line">        <span class="keyword">while</span> ( p )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;data&gt;s-&gt;data )</span><br><span class="line">            &#123;</span><br><span class="line">                s = p; r = pre;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 脱链</span></span><br><span class="line">        <span class="keyword">if</span> ( s == h ) h = h-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> r-&gt;next = s-&gt;next;</span><br><span class="line">        <span class="comment">// 头插法</span></span><br><span class="line">        s-&gt;next = L; L = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5.顺序表中有n个不同整数(下标1~n),设计算法把所有奇数移动到偶数前面(时,空都最少)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">( ElemType A[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">1</span>, high = n;</span><br><span class="line">    <span class="keyword">while</span> ( low &lt; high )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high&amp;&amp;A[low] % <span class="number">2</span> ) low++;</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high &amp;&amp; A[high] % <span class="number">2</span> == <span class="number">0</span> ) high--;</span><br><span class="line">        <span class="keyword">if</span> ( low &lt; high )</span><br><span class="line">        &#123;</span><br><span class="line">            swap( A[low], A[high] );</span><br><span class="line">            low++; high--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6.在顺序表中找出第k小的元素(时空最少)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思想:划分</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = R[low];</span><br><span class="line">    <span class="keyword">while</span> ( low &lt; high )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high &amp;&amp; R[high].key &gt;= pivot.key ) high--;</span><br><span class="line">        R[low] = R[high];</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high&amp;&amp; R[low].key &lt;= pivot.key ) low++;</span><br><span class="line">            R[high] = R[low];</span><br><span class="line">    &#125;</span><br><span class="line">    R[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">Kth_elem</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> k )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivotpos = Partition( R, low, high );</span><br><span class="line">    <span class="keyword">if</span> ( pivotpos == k ) <span class="keyword">return</span> R[pivotpos];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( pivotpos &gt; k ) <span class="keyword">return</span> Kth_elem( R, low, pivotpos - <span class="number">1</span>, k );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Kth_elem( R, pivotpos + <span class="number">1</span>, high, k );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>7.n个正整数构成的集合A,将其划分为两个不相交的子集$A1,A2$,元素个数分别是n1和n2.A1和A2中元素之和分别为S1和S2.设计一个时空高效算法,使|n1-n2|最小且|s1-s1|最大.(下标从1开始)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = R[low];</span><br><span class="line">    <span class="keyword">while</span> ( low &lt; high )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high &amp;&amp; R[high].key &gt;= pivot.key ) high--;</span><br><span class="line">        R[low] = R[high];</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high&amp;&amp; R[low].key &lt;= pivot.key ) low++;</span><br><span class="line">        R[high] = R[low];</span><br><span class="line">    &#125;</span><br><span class="line">    R[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetPartition</span><span class="params">( ElemType R[], <span class="keyword">int</span> n, <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = n / <span class="number">2</span>, s1, s2, i;</span><br><span class="line">    <span class="keyword">int</span> pivotpos = Partition( R, low, high );</span><br><span class="line">    <span class="keyword">if</span> ( pivotpos == k )</span><br><span class="line">    &#123;</span><br><span class="line">        s1 = s2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt;= k; i++ ) s1 += R[i];</span><br><span class="line">        <span class="keyword">for</span> ( j = k + <span class="number">1</span>; j &lt;= n; j++ ) s2 += R[j];</span><br><span class="line">        <span class="keyword">return</span> s2 - s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( pivotpos &gt; k )</span><br><span class="line">        <span class="keyword">return</span> SetPartition( R, n, low, pivotpos - <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> SetPartition( R, n, pivotpos + <span class="number">1</span>, high );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-排序算法&quot;&gt;&lt;a href=&quot;#一-排序算法&quot; class=&quot;headerlink&quot; title=&quot;一.排序算法&quot;&gt;&lt;/a&gt;一.排序算法&lt;/h2&gt;&lt;h3 id=&quot;1-插入排序&quot;&gt;&lt;a href=&quot;#1-插入排序&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="algorithm" scheme="https://brianyi.github.io/categories/algorithm/"/>
    
    
      <category term="排序" scheme="https://brianyi.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]133.克隆图</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-133-%E5%85%8B%E9%9A%86%E5%9B%BE/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-133-克隆图/</id>
    <published>2019-05-06T13:21:48.000Z</published>
    <updated>2019-05-06T13:27:25.958Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-133-克隆图/453425-20190430181854853-2091334093.png"><h3 id="方法一-dfs-递归"><a href="#方法一-dfs-递归" class="headerlink" title="方法一:dfs(递归)"></a>方法一:dfs(递归)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;Node*,Node*&gt; dict;</span><br><span class="line"><span class="function">Node* <span class="title">clone</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> node;</span><br><span class="line">    <span class="keyword">if</span> (dict.count(node)) <span class="keyword">return</span> dict[node];</span><br><span class="line">    dict[node]=<span class="keyword">new</span> Node(node-&gt;val,<span class="built_in">vector</span>&lt;Node*&gt;&#123;&#125;);　　<span class="comment">// 这里不能写clone(node),会导致死循环,记住,在new的时候千万不要再递归,递归最低层一定有一个明确结果,所以要把截止条件写清楚</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:node-&gt;neighbors)</span><br><span class="line">        dict[node]-&gt;neighbors.push_back(clone(it));</span><br><span class="line">    <span class="keyword">return</span> dict[node];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> clone(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二-dfs-非递归"><a href="#方法二-dfs-非递归" class="headerlink" title="方法二:dfs(非递归)"></a>方法二:dfs(非递归)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;Node*,Node*&gt; dict;</span><br><span class="line"><span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Node*&gt; S;</span><br><span class="line">    S.push(node);</span><br><span class="line">    <span class="keyword">while</span> (!S.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Node *p = S.top();</span><br><span class="line">        S.pop();</span><br><span class="line">        <span class="keyword">if</span> (!dict.count(p))　　<span class="comment">// 从栈中出来的都是没有进行访问过的点</span></span><br><span class="line">            dict[p]=<span class="keyword">new</span> Node(p-&gt;val,<span class="built_in">vector</span>&lt;Node*&gt;&#123;&#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it:p-&gt;neighbors)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dict.count(it))　　<span class="comment">// 判断是否已经访问过该点</span></span><br><span class="line">            &#123;</span><br><span class="line">                dict[it]=<span class="keyword">new</span> Node(it-&gt;val,<span class="built_in">vector</span>&lt;Node*&gt;&#123;&#125;);</span><br><span class="line">                S.push(it);</span><br><span class="line">            &#125;</span><br><span class="line">            dict[p]-&gt;neighbors.push_back(dict[it]);　　<span class="comment">// 将新点的拷贝放入neighbors中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dict[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-133-克隆图/453425-20190430181854853-2091334093.png&quot;&gt;
&lt;h3 id=&quot;方法一-dfs-递归&quot;&gt;&lt;a href=&quot;#方法一-dfs-递归&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="dfs" scheme="https://brianyi.github.io/tags/dfs/"/>
    
      <category term="图" scheme="https://brianyi.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]138.复制带随机指针的链表</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-138-复制带随机指针的链表/</id>
    <published>2019-05-06T13:20:18.000Z</published>
    <updated>2019-05-06T14:43:56.130Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-138-复制带随机指针的链表/453425-20190430193735900-662137168.png"><h3 id="方法一-递归"><a href="#方法一-递归" class="headerlink" title="方法一:递归"></a>方法一:递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;Node*,Node*&gt; dict;</span><br><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">if</span> (dict.count(head)) <span class="keyword">return</span> dict[head];</span><br><span class="line">    dict[head]=<span class="keyword">new</span> Node(head-&gt;val, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    dict[head]-&gt;next=copyRandomList(head-&gt;next);</span><br><span class="line">    dict[head]-&gt;random=copyRandomList(head-&gt;random);</span><br><span class="line">    <span class="keyword">return</span> dict[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二-非递归"><a href="#方法二-非递归" class="headerlink" title="方法二:非递归"></a>方法二:非递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;Node*,Node*&gt; m;</span><br><span class="line">    Node *p=head;</span><br><span class="line">    <span class="keyword">while</span>(p)    <span class="comment">// make a copy of nodes</span></span><br><span class="line">    &#123;</span><br><span class="line">        m[p]=<span class="keyword">new</span> Node(p-&gt;val,<span class="literal">nullptr</span>,<span class="literal">nullptr</span>);</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p=head;</span><br><span class="line">    <span class="keyword">while</span>(p)    <span class="comment">// link everyone and fill the random field</span></span><br><span class="line">    &#123;</span><br><span class="line">        m[p]-&gt;next=m[p-&gt;next];</span><br><span class="line">        m[p]-&gt;random=m[p-&gt;random];</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-138-复制带随机指针的链表/453425-20190430193735900-662137168.png&quot;&gt;
&lt;h3 id=&quot;方法一-递归&quot;&gt;&lt;a href=&quot;#方法一-递归&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="链表" scheme="https://brianyi.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]144.二叉树的前序遍历</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-144-二叉树的前序遍历/</id>
    <published>2019-05-06T13:17:07.000Z</published>
    <updated>2019-05-06T13:19:44.482Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-144-二叉树的前序遍历/453425-20190501113746021-447522744.png"><p>前往二叉树的:前序,中序,后序 遍历算法</p><h3 id="方法一-递归"><a href="#方法一-递归" class="headerlink" title="方法一:递归"></a>方法一:递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    res.push_back(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) preorderTraversal(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right) preorderTraversal(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二-非递归"><a href="#方法二-非递归" class="headerlink" title="方法二:非递归"></a>方法二:非递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">    TreeNode* p = root;</span><br><span class="line">    <span class="keyword">while</span>(p||!S.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p)  <span class="comment">// 访问左子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(p-&gt;val);</span><br><span class="line">            S.push(p);</span><br><span class="line">            p=p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">// 访问右子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=S.top();</span><br><span class="line">            S.pop();</span><br><span class="line">            p=p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三-非递归-该方法可用于后序遍历-需要修改几处代码"><a href="#方法三-非递归-该方法可用于后序遍历-需要修改几处代码" class="headerlink" title="方法三:非递归(该方法可用于后序遍历,需要修改几处代码)"></a>方法三:非递归(该方法可用于后序遍历,需要修改几处代码)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">    S.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!S.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        root=S.top();</span><br><span class="line">        S.pop();</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) S.push(root-&gt;right);  <span class="comment">// 要实现后序遍历,需要以下两行调换</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) S.push(root-&gt;left);</span><br><span class="line">        res.push_back(root-&gt;val);   <span class="comment">// res.insert(0,root-&gt;val)即为后序遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论:</p><ul><li>方法三这种形式只适合前序和后序遍历,不适合中序遍历,中序遍历较为麻烦</li><li>方法二这种形式只适合前序和中序遍历,不适合后序遍历,后序遍历较为麻烦</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-144-二叉树的前序遍历/453425-20190501113746021-447522744.png&quot;&gt;
&lt;p&gt;前往二叉树的:前序,中序,后序 遍历算法&lt;/p&gt;
&lt;h3 id=&quot;方法一-递归&quot;&gt;&lt;a href=&quot;#方
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="树" scheme="https://brianyi.github.io/tags/%E6%A0%91/"/>
    
      <category term="递归" scheme="https://brianyi.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]94.二叉树的中序遍历</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-94-二叉树的中序遍历/</id>
    <published>2019-05-06T13:14:44.000Z</published>
    <updated>2019-05-06T14:20:07.345Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-94-二叉树的中序遍历/453425-20190501120139941-1568037684.png"><p>前往二叉树的:<a href>前序</a>,<a href>中序</a>,<a href>后序</a> 遍历算法</p><h3 id="方法一-递归"><a href="#方法一-递归" class="headerlink" title="方法一:递归"></a>方法一:递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) inorderTraversal(root-&gt;left);      </span><br><span class="line">    res.push_back(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right) inorderTraversal(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二-非递归"><a href="#方法二-非递归" class="headerlink" title="方法二:非递归"></a>方法二:非递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">    TreeNode* p = root;</span><br><span class="line">    <span class="keyword">while</span>(p||!S.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            S.push(p);</span><br><span class="line">            p=p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=S.top();</span><br><span class="line">            S.pop();</span><br><span class="line">            res.push_back(p-&gt;val);</span><br><span class="line">            p=p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-94-二叉树的中序遍历/453425-20190501120139941-1568037684.png&quot;&gt;
&lt;p&gt;前往二叉树的:&lt;a href&gt;前序&lt;/a&gt;,&lt;a href&gt;中序&lt;/a&gt;,&lt;a href&gt;后序&lt;/a&gt; 
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="树" scheme="https://brianyi.github.io/tags/%E6%A0%91/"/>
    
      <category term="递归" scheme="https://brianyi.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]145.二叉树的后序遍历</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-145-二叉树的后序遍历/</id>
    <published>2019-05-06T13:12:06.000Z</published>
    <updated>2019-05-06T13:14:29.228Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-145-二叉树的后序遍历/453425-20190501122117295-85727166.png"><p>前往二叉树的:前序,中序,后序 遍历算法</p><h3 id="方法一-递归"><a href="#方法一-递归" class="headerlink" title="方法一:递归"></a>方法一:递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) postorderTraversal(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right) postorderTraversal(root-&gt;right);</span><br><span class="line">    res.push_back(root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二-非递归"><a href="#方法二-非递归" class="headerlink" title="方法二:非递归"></a>方法二:非递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">    TreeNode* p=root, *r=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (p||!S.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            S.push(p);</span><br><span class="line">            p=p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=S.top();</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right&amp;&amp;p-&gt;right!=r)</span><br><span class="line">                p=p-&gt;right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                S.pop();</span><br><span class="line">                res.push_back(p-&gt;val);</span><br><span class="line">                r=p;</span><br><span class="line">                p=<span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="方法三-非递归"><a href="#方法三-非递归" class="headerlink" title="方法三:非递归"></a>方法三:非递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">    TreeNode* p=root;</span><br><span class="line">    S.push(p);</span><br><span class="line">    <span class="keyword">while</span> (!S.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        p=S.top();</span><br><span class="line">        S.pop();</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;left) S.push(p-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right) S.push(p-&gt;right);</span><br><span class="line">        res.insert(res.begin(),p-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-145-二叉树的后序遍历/453425-20190501122117295-85727166.png&quot;&gt;
&lt;p&gt;前往二叉树的:前序,中序,后序 遍历算法&lt;/p&gt;
&lt;h3 id=&quot;方法一-递归&quot;&gt;&lt;a href=&quot;#方法
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="树" scheme="https://brianyi.github.io/tags/%E6%A0%91/"/>
    
      <category term="递归" scheme="https://brianyi.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]968.监控二叉树</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-968-监控二叉树/</id>
    <published>2019-05-06T13:08:13.000Z</published>
    <updated>2019-05-06T13:11:46.627Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-968-监控二叉树/453425-20190501230642291-677698823.png"><p>解题思路: 由于叶子节点一定不要安装监视器,这样才能使总监视器数量比较少,因此需要从下往上进行判断当前节点的状态(共:3种状态):</p><ul><li>0: 当前节点安装了监视器</li><li>1: 当前节点可观,但没有安装监视器</li><li>2: 当前节点不可观<br>对于空节点,我们认为是可观,但没有安装监视器,因此,叶子节点就为不可观的了,设想一个节点的左右孩子(为空)都可观且没有安装监视器,那该节点必然是不可观即2</li></ul><p>有了以上对空节点和叶子节点的处理,我们再来正式分析非终端节点:</p><ul><li>若一个节点的左孩子或右孩子不可观,那么该节点必然不可观,需要安装监视器,因此返回0状态</li><li>若一个节点的左孩子或右孩子都可观且至少有一个安装了监视器,那么该节点必然是可观的,返回1状态</li><li>若一个节点的左右孩子都可观且没安装监视器,那么该节点必然是不可观的,返回2状态<br>记住,我们以上的分析都是基于从整个二叉树的叶子节点往根部,即从下往上进行,而且要做的就是将不可观的节点变得可观才行(因此要根据左右孩子的节点的状态来判断当前节点状态并做出调整)</li></ul><p>这里可能会有疑惑,以上的第一条得出当前节点不可观,然后安装了监视器,而第三条也得出当前节点不可观,但却没有安装监视器,而是直接返回的2状态(当前节点不可观).这是为什么?</p><p>因为,对于第一条,因为左右孩子都不可观,为了让左右孩子都可观,则必须给当前节点安装监视器才行,而第三条中,左右孩子都是可观的(没有安装监视器),当前节点的可以直接返回不可观状态,因为后面可以由他的父节点进行摄像头安装,使其变得可观.</p><h3 id="方法一-递归"><a href="#方法一-递归" class="headerlink" title="方法一:递归"></a>方法一:递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0：该节点安装了监视器 1：该节点可观，但没有安装监视器 2：该节点不可观</span></span><br><span class="line"><span class="keyword">int</span> monitor = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">state</span><span class="params">(TreeNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left  = state(node-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> right = state(node-&gt;right);</span><br><span class="line">    <span class="comment">// 该节点为0的情况</span></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">2</span> || right == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        monitor++;  <span class="comment">// 由于左或右节点不可观,则需要给当前节点安装监视器,为0状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="comment">// 为1的情况</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="number">0</span> || right == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">// 当(left!=2&amp;&amp;right!=2)时,才会进行该判断,也就是左右节点一定是可观的,再判断是否有一个安装了监视器,如有安装,则当前节点就不需要安装监视器也可观了,为1状态</span></span><br><span class="line">    <span class="comment">// 为2的情况</span></span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">// 其他:党(left!=2&amp;&amp;right!=2)&amp;&amp;(left!=0&amp;&amp;right!=0),即left==1&amp;&amp;right==1时,左右节点都可观,但没有监视器,当前节点不可观,为2状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (state(root) == <span class="number">2</span>) monitor++;    <span class="comment">// 如果根节点为2的状态,需要加一个监视器</span></span><br><span class="line">    <span class="keyword">return</span> monitor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:这里的if,else if,else的顺序是不能变的,先判断左右都是不可观的,再就是都可观,左或右至少有一个为监视器,最后才是都可观都无监视器.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-968-监控二叉树/453425-20190501230642291-677698823.png&quot;&gt;
&lt;p&gt;解题思路: 由于叶子节点一定不要安装监视器,这样才能使总监视器数量比较少,因此需要从下往上进行判断当前节点的状
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="dp" scheme="https://brianyi.github.io/tags/dp/"/>
    
      <category term="二叉树" scheme="https://brianyi.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]106.从中序与后序遍历序列构造二叉树</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-106-从中序与后序遍历序列构造二叉树/</id>
    <published>2019-05-06T12:16:02.000Z</published>
    <updated>2019-05-06T13:27:31.595Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-106-从中序与后序遍历序列构造二叉树/453425-20190502213938801-1912607084.png"><p>前往 中序,后序遍历构造二叉树, 中序,前序遍历构造二叉树<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> l1, <span class="keyword">int</span> r1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;postorder, <span class="keyword">int</span> l2, <span class="keyword">int</span> r2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1&gt;r1) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> x = postorder[r2], i = <span class="number">0</span>;   <span class="comment">// 确定当前根节点</span></span><br><span class="line">    <span class="keyword">for</span> (i = l1; i &lt;= r1 &amp;&amp; inorder[i] != x; ++i);  <span class="comment">// 在中序遍历序列中找到当前根节点位置(该位置可以划分出左右两个分支)</span></span><br><span class="line">    <span class="keyword">int</span> llen = i - l1;  <span class="comment">// 左子树结点数量</span></span><br><span class="line">    <span class="keyword">int</span> rlen = r1 - i;  <span class="comment">// 右子树结点数量</span></span><br><span class="line">    TreeNode* p = <span class="keyword">new</span> TreeNode(x);  <span class="comment">// 建立根节点</span></span><br><span class="line">    p-&gt;left = build(inorder, l1, l1 + llen - <span class="number">1</span>, postorder, l2, l2 + llen - <span class="number">1</span>);  <span class="comment">// 递归建立左子树,-1,-1是把当前根节点位置去掉</span></span><br><span class="line">    p-&gt;right = build(inorder, r1 - rlen + <span class="number">1</span>, r1, postorder, r2 - rlen, r2 - <span class="number">1</span>); <span class="comment">// 递归建立右子树,+1,-1是把当前根节点位置去掉</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inorder.empty()||postorder.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> build(inorder, <span class="number">0</span>, inorder.size() - <span class="number">1</span>, postorder, <span class="number">0</span>, postorder.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-106-从中序与后序遍历序列构造二叉树/453425-20190502213938801-1912607084.png&quot;&gt;
&lt;p&gt;前往 中序,后序遍历构造二叉树, 中序,前序遍历构造二叉树&lt;br&gt;&lt;figure cla
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="树" scheme="https://brianyi.github.io/tags/%E6%A0%91/"/>
    
      <category term="递归" scheme="https://brianyi.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]105.从前序与中序遍历序列构造二叉树</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-105-从前序与中序遍历序列构造二叉树/</id>
    <published>2019-05-06T12:14:01.000Z</published>
    <updated>2019-05-06T12:15:26.558Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-105-从前序与中序遍历序列构造二叉树/453425-20190502215802448-663626721.png"><p>前往 中序,后序遍历构造二叉树, 中序,前序遍历构造二叉树<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> l1, <span class="keyword">int</span> r1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> l2, <span class="keyword">int</span> r2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1&gt;r1) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> x=preorder[l1], i=<span class="number">0</span>;    <span class="comment">// 确定当前根节点</span></span><br><span class="line">    <span class="keyword">for</span>(i=l2;inorder[i]!=x&amp;&amp;i&lt;r2;++i);  <span class="comment">// 在中序遍历序列中找到当前根节点位置(该位置可以划分出左右两个分支)</span></span><br><span class="line">    <span class="keyword">int</span> llen=i-l2;  <span class="comment">// 左子树结点数量</span></span><br><span class="line">    <span class="keyword">int</span> rlen=r2-i;  <span class="comment">// 右子树结点数量</span></span><br><span class="line">    TreeNode *p = <span class="keyword">new</span> TreeNode(x);  <span class="comment">// 建立根节点</span></span><br><span class="line">    p-&gt;left = build(preorder, l1+<span class="number">1</span>, l1+llen, inorder, l2, l2+llen<span class="number">-1</span>);   <span class="comment">// 递归建立左子树,+1,-1是把当前根节点位置去掉</span></span><br><span class="line">    p-&gt;right= build(preorder, r1-rlen+<span class="number">1</span>, r1, inorder, r2-rlen+<span class="number">1</span>, r2);   <span class="comment">// 递归建立右子树,+1,+1是把当前根节点位置去掉</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.size()<span class="number">-1</span>, inorder, <span class="number">0</span>, inorder.size()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-105-从前序与中序遍历序列构造二叉树/453425-20190502215802448-663626721.png&quot;&gt;
&lt;p&gt;前往 中序,后序遍历构造二叉树, 中序,前序遍历构造二叉树&lt;br&gt;&lt;figure clas
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="树" scheme="https://brianyi.github.io/tags/%E6%A0%91/"/>
    
      <category term="递归" scheme="https://brianyi.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]114.二叉树展开为链表</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-114-二叉树展开为链表/</id>
    <published>2019-05-06T12:12:04.000Z</published>
    <updated>2019-05-06T12:13:26.706Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-114-二叉树展开为链表/453425-20190502231706813-609020347.png"><p>思路:递归,将左子树变成单链表形式,再将右子树变成单链表形式,最后将左子树单链表的末端连接到右子树单链表表头,将根节点的左孩子置空</p><h3 id="方法一-递归"><a href="#方法一-递归" class="headerlink" title="方法一: 递归"></a>方法一: 递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    flatten(root-&gt;left);    <span class="comment">// 将左子树变成单链表形式</span></span><br><span class="line">    flatten(root-&gt;right);   <span class="comment">// 将右子树变成单链表形式</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) <span class="comment">// 将左子树单链表的末端连接到右子树单链表表头</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* p=root-&gt;left;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;right) p=p-&gt;right;</span><br><span class="line">        p-&gt;right=root-&gt;right;</span><br><span class="line">        root-&gt;right=root-&gt;left;</span><br><span class="line">        root-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-114-二叉树展开为链表/453425-20190502231706813-609020347.png&quot;&gt;
&lt;p&gt;思路:递归,将左子树变成单链表形式,再将右子树变成单链表形式,最后将左子树单链表的末端连接到右子树单链表
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="树" scheme="https://brianyi.github.io/tags/%E6%A0%91/"/>
    
      <category term="递归" scheme="https://brianyi.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]239.滑动窗口最大值</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-239-滑动窗口最大值/</id>
    <published>2019-05-06T12:10:15.000Z</published>
    <updated>2019-05-06T12:11:33.534Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-239-滑动窗口最大值/453425-20190503094513334-1691572073.png"><p>思路:滑动窗口的思想,只要是求连续子序列或者子串问题,都可用滑动窗口的思想</p><h3 id="方法一-滑动窗口"><a href="#方法一-滑动窗口" class="headerlink" title="方法一: 滑动窗口"></a>方法一: 滑动窗口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (nums.size()==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;　　</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;nums.size();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!dq.empty()&amp;&amp;nums[i]&gt;nums[dq.back()]) <span class="comment">//在尾部添加元素，并保证左边元素都比尾部大</span></span><br><span class="line">            dq.pop_back();</span><br><span class="line">        dq.push_back(i);</span><br><span class="line">        <span class="keyword">if</span> (i-k==dq.front())    <span class="comment">//在头部移除元素</span></span><br><span class="line">            dq.pop_front();</span><br><span class="line">        <span class="keyword">if</span> (i&gt;=k<span class="number">-1</span>)</span><br><span class="line">            res.push_back(nums[dq.front()]);    <span class="comment">// 存放每次窗口内的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-239-滑动窗口最大值/453425-20190503094513334-1691572073.png&quot;&gt;
&lt;p&gt;思路:滑动窗口的思想,只要是求连续子序列或者子串问题,都可用滑动窗口的思想&lt;/p&gt;
&lt;h3 id=&quot;方法
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="滑动窗口" scheme="https://brianyi.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]76.最小覆盖子串</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-76-最小覆盖子串/</id>
    <published>2019-05-06T12:08:01.000Z</published>
    <updated>2019-05-06T12:09:32.405Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-76-最小覆盖子串/453425-20190503105807149-1455260747.png"><p>思路:滑动窗口思想</p><h3 id="方法一-滑动窗口"><a href="#方法一-滑动窗口" class="headerlink" title="方法一:滑动窗口"></a>方法一:滑动窗口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.tdict记录T中每个字母与字母个数</span></span><br><span class="line">    <span class="comment">// 2.维护一个滑动窗口字母的计数表sdict,计数当前窗口内T中字母出现的次数</span></span><br><span class="line">    <span class="comment">// 3.当窗口内T中字母出现的次数大于等于T中每个字母出现的次数一样,这时第一个最短子串出现,再逐步从左边缩短窗口,直到不满足上述条件,然后再从右边扩大窗口,直到满足条件时,再进行最短子串长度对比,一直更新最短长度子串直到结束</span></span><br><span class="line">    <span class="keyword">if</span> (s.size()&lt;t.size()||s.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; tdict,sdict;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,k=t.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:t)  <span class="comment">// 填充T的字母与字母计数表</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tdict.count(it)) tdict[it]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> tdict[it]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(r=<span class="number">0</span>;r&lt;s.size();++r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tdict.count(s[r])) <span class="comment">// 有字符,则进行记录</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!sdict.count(s[r]))</span><br><span class="line">                sdict[s[r]]=<span class="number">0</span>;</span><br><span class="line">            sdict[s[r]]++;</span><br><span class="line">            <span class="keyword">if</span> (sdict[s[r]]&lt;=tdict[s[r]])</span><br><span class="line">                k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(k==<span class="number">0</span>) <span class="comment">// 满足条件,滑动窗口从左边逐步缩短,直到剔除第一个属于T中的字符为止</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.empty()||r-l+<span class="number">1</span>&lt;res.size())  <span class="comment">// 最短子串更新</span></span><br><span class="line">                res=s.substr(l,r-l+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(tdict.count(s[l]))</span><br><span class="line">            &#123;</span><br><span class="line">                sdict[s[l]]--;</span><br><span class="line">                <span class="keyword">if</span> (sdict[s[l]]&lt;tdict[s[l]])</span><br><span class="line">                    k++;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-76-最小覆盖子串/453425-20190503105807149-1455260747.png&quot;&gt;
&lt;p&gt;思路:滑动窗口思想&lt;/p&gt;
&lt;h3 id=&quot;方法一-滑动窗口&quot;&gt;&lt;a href=&quot;#方法一-滑动窗口&quot; cl
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="滑动窗口" scheme="https://brianyi.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]3.无重复字符的最长子串</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-3-无重复字符的最长子串/</id>
    <published>2019-05-06T12:05:28.000Z</published>
    <updated>2019-05-06T14:39:45.897Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-3-无重复字符的最长子串/453425-20190503112154412-1836563639.png"><p>思路:滑动窗口的思想</p><h3 id="方法一-滑动窗口"><a href="#方法一-滑动窗口" class="headerlink" title="方法一:滑动窗口"></a>方法一:滑动窗口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        控制一个滑动窗口,窗口内的字符都是不重复的,通过set可以做到判断字符是否重复</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">    <span class="keyword">size_t</span> maxL=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;r&lt;s.size();++r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">set</span>.count(s[r]))   <span class="comment">// 当前判断的元素不存在于滑动窗口[l,r-1]中</span></span><br><span class="line">            <span class="built_in">set</span>.insert(s[r]);   <span class="comment">// 将元素放入滑动窗口(即记录不重复字符)</span></span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">// 当前判断的元素已经存在于滑动窗口[l,r-1]中</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">set</span>.count(s[r]))  <span class="comment">// 从左缩短窗口,直到剔除当前判断的元素为止</span></span><br><span class="line">                <span class="built_in">set</span>.erase(s[l++]);</span><br><span class="line">            <span class="built_in">set</span>.insert(s[r]);   <span class="comment">// 将当前判断元素放入到滑动窗口中</span></span><br><span class="line">        &#125;</span><br><span class="line">        maxL=max(maxL,<span class="built_in">set</span>.size());  <span class="comment">// 更新无重复字符的最长子串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-3-无重复字符的最长子串/453425-20190503112154412-1836563639.png&quot;&gt;
&lt;p&gt;思路:滑动窗口的思想&lt;/p&gt;
&lt;h3 id=&quot;方法一-滑动窗口&quot;&gt;&lt;a href=&quot;#方法一-滑动窗口
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="滑动窗口" scheme="https://brianyi.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]1028.从先序遍历还原二叉树</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-1028-%E4%BB%8E%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-1028-从先序遍历还原二叉树/</id>
    <published>2019-05-06T12:00:45.000Z</published>
    <updated>2019-05-06T12:05:01.645Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-1028-从先序遍历还原二叉树/453425-20190503131537591-466226739.png"><p>思路:用一个栈来管理树的层次关系,索引代表节点的深度</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">recoverFromPreorder</span><span class="params">(<span class="built_in">string</span> S)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        由题意知,最上层节点深度为0(数字前面0条横线),而第二层节点前有1条横线,表示深度为1</span></span><br><span class="line"><span class="comment">        树的前序遍历: 根-左-右</span></span><br><span class="line"><span class="comment">        因此,</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (S.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>;  <span class="comment">// 结果栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,depth=<span class="number">0</span>,val=<span class="number">0</span>;i&lt;S.size();)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(depth=<span class="number">0</span>;i&lt;S.size()&amp;&amp;S[i]==<span class="string">'-'</span>;++i)  <span class="comment">// 计算节点的深度</span></span><br><span class="line">            depth++;</span><br><span class="line">        <span class="keyword">for</span>(val=<span class="number">0</span>;i&lt;S.size()&amp;&amp;S[i]!=<span class="string">'-'</span>;++i)    <span class="comment">// 计算数值</span></span><br><span class="line">            val=val*<span class="number">10</span>+S[i]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">stack</span>.size()&gt;depth)    <span class="comment">// 若当前栈的长度(树的高度)大于节点的深度,则可以把栈中最后几个节点pop掉(这些节点各已经成为完整的子树,可以pop掉了)</span></span><br><span class="line">            <span class="built_in">stack</span>.pop_back();</span><br><span class="line">        TreeNode* node=<span class="keyword">new</span> TreeNode(val);   <span class="comment">// 新建节点用于存放当前深度的结点</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">stack</span>.empty()) <span class="comment">// 节点间关联</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">stack</span>.back()-&gt;left)      <span class="built_in">stack</span>.back()-&gt;left=node;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">stack</span>.back()-&gt;right) <span class="built_in">stack</span>.back()-&gt;right=node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>.push_back(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-1028-从先序遍历还原二叉树/453425-20190503131537591-466226739.png&quot;&gt;
&lt;p&gt;思路:用一个栈来管理树的层次关系,索引代表节点的深度&lt;/p&gt;
&lt;h3 id=&quot;方法一&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="树" scheme="https://brianyi.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]5040.边框着色</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-5040-%E8%BE%B9%E6%A1%86%E7%9D%80%E8%89%B2/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-5040-边框着色/</id>
    <published>2019-05-06T11:39:46.000Z</published>
    <updated>2019-05-06T12:02:58.944Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-5040-边框着色/453425-20190430173552247-46622747.png"><h3 id="方法一：dfs的非递归形式"><a href="#方法一：dfs的非递归形式" class="headerlink" title="方法一：dfs的非递归形式"></a>方法一：dfs的非递归形式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ll=<span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> ll MAXN=<span class="number">50L</span>L;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;ll&gt; vis,mark;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; colorBorder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; G, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0, <span class="keyword">int</span> color) &#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;ll&gt; Q;</span><br><span class="line">    Q.push(r0*MAXN+c0);</span><br><span class="line">    <span class="keyword">int</span> c=G[r0][c0];</span><br><span class="line">    <span class="keyword">int</span> dx[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,dy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=Q.front()/MAXN;</span><br><span class="line">        <span class="keyword">int</span> y=Q.front()%MAXN;</span><br><span class="line">        Q.pop();</span><br><span class="line">        vis.insert(x*MAXN+y);</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="number">0</span>||x==G.size()<span class="number">-1</span>||y==<span class="number">0</span>||y==G[<span class="number">0</span>].size()<span class="number">-1</span>)    <span class="comment">// 边界方块可变色</span></span><br><span class="line">            mark.insert(x*MAXN+y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (G[x<span class="number">-1</span>][y]!=c||G[x+<span class="number">1</span>][y]!=c||G[x][y<span class="number">-1</span>]!=c||G[x][y+<span class="number">1</span>]!=c)    <span class="comment">// 四个方向中,任意一个方块颜色不同,则可变色</span></span><br><span class="line">            mark.insert(x*MAXN+y);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d=<span class="number">0</span>;d&lt;<span class="number">4</span>;d++)   <span class="comment">// 放入连通分量的所有方块</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nx=x+dx[d],ny=y+dy[d];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span>&lt;=nx&amp;&amp;nx&lt;G.size()&amp;&amp;<span class="number">0</span>&lt;=ny&amp;&amp;ny&lt;G[<span class="number">0</span>].size()&amp;&amp;!vis.count(nx*MAXN+ny)&amp;&amp;G[nx][ny]==c)</span><br><span class="line">                Q.push(nx*MAXN+ny);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it:mark)</span><br><span class="line">        G[it/MAXN][it%MAXN]=color;</span><br><span class="line">    <span class="keyword">return</span> G;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路:用vis记录访问过的方块,mark标记连通分量中需要修改颜色的方块,并非连通分量中所有的方块都要修改颜色,比如:一个方块如果四周(四个方向邻接的)都是相同颜色,那么只需要修改四周方块的颜色,而自己颜色不变(开始的时候没理解题意,以为只要是连通分量内的方块颜色都需要改变)</p><h3 id="方法二-dfs递归形式-只不过把上面的非递归改为递归了"><a href="#方法二-dfs递归形式-只不过把上面的非递归改为递归了" class="headerlink" title="方法二: dfs递归形式,只不过把上面的非递归改为递归了"></a>方法二: dfs递归形式,只不过把上面的非递归改为递归了</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ll=<span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> ll MAXN=<span class="number">50L</span>L;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;ll&gt; vis,mark;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; G, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dx[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,dy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    vis.insert(x*MAXN+y);</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="number">0</span>||x==G.size()<span class="number">-1</span>||y==<span class="number">0</span>||y==G[<span class="number">0</span>].size()<span class="number">-1</span>)    <span class="comment">// 边界方块可变色</span></span><br><span class="line">        mark.insert(x*MAXN+y);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (G[x<span class="number">-1</span>][y]!=c||G[x+<span class="number">1</span>][y]!=c||G[x][y<span class="number">-1</span>]!=c||G[x][y+<span class="number">1</span>]!=c)    <span class="comment">// 四个方向中,任意一个方块颜色不同,则可变色</span></span><br><span class="line">        mark.insert(x*MAXN+y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d=<span class="number">0</span>;d&lt;<span class="number">4</span>;d++)   <span class="comment">// 放入连通分量的所有方块</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nx=x+dx[d],ny=y+dy[d];</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span>&lt;=nx&amp;&amp;nx&lt;G.size()&amp;&amp;<span class="number">0</span>&lt;=ny&amp;&amp;ny&lt;G[<span class="number">0</span>].size()&amp;&amp;!vis.count(nx*MAXN+ny)&amp;&amp;G[nx][ny]==c)</span><br><span class="line">            dfs(G,nx,ny,c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; colorBorder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; G, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0, <span class="keyword">int</span> color) &#123;</span><br><span class="line">    dfs(G,r0,c0,G[r0][c0]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it:mark)</span><br><span class="line">        G[it/MAXN][it%MAXN]=color;</span><br><span class="line">    <span class="keyword">return</span> G;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三-dfs递归-但通过修改G中的数据-来记录是否访问过-和是否需要修改颜色-国外的一个大佬写的"><a href="#方法三-dfs递归-但通过修改G中的数据-来记录是否访问过-和是否需要修改颜色-国外的一个大佬写的" class="headerlink" title="方法三:dfs递归,但通过修改G中的数据,来记录是否访问过,和是否需要修改颜色,国外的一个大佬写的"></a>方法三:dfs递归,但通过修改G中的数据,来记录是否访问过,和是否需要修改颜色,国外的一个<a href="https://leetcode.com/problems/coloring-a-border/discuss/282847/C%2B%2B-with-picture-DFS" target="_blank" rel="noopener">大佬</a>写的</h3><p>From an initial point, perform DFS and flip the cell color to negative to track visited cells.<br>After DFS is complete for the cell, check if this cell is inside. If so, flip its color back to the positive.<br>In the end, cells with the negative color are on the border. Change their color to the target color.<br><img src="/2019/05/06/leetcode-5040-边框着色/image_1556425139.png"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; g, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> cl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= g.size() || c &gt;= g[r].size() || g[r][c] != cl) <span class="keyword">return</span>;    <span class="comment">// 剪枝(越界,非着色块)</span></span><br><span class="line">    g[r][c] = -cl;    <span class="comment">// 着色</span></span><br><span class="line">    dfs(g, r - <span class="number">1</span>, c, cl), dfs(g, r + <span class="number">1</span>, c, cl), dfs(g, r, c - <span class="number">1</span>, cl), dfs(g, r, c + <span class="number">1</span>, cl);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; <span class="number">0</span> &amp;&amp; r &lt; g.size() - <span class="number">1</span> &amp;&amp; c &gt; <span class="number">0</span> &amp;&amp; c &lt; g[r].size() - <span class="number">1</span> &amp;&amp; cl == <span class="built_in">abs</span>(g[r - <span class="number">1</span>][c]) &amp;&amp;</span><br><span class="line">        cl == <span class="built_in">abs</span>(g[r + <span class="number">1</span>][c]) &amp;&amp; cl == <span class="built_in">abs</span>(g[r][c - <span class="number">1</span>]) &amp;&amp; cl == <span class="built_in">abs</span>(g[r][c + <span class="number">1</span>]))    <span class="comment">// 将原四周同色的块,颜色还原</span></span><br><span class="line">        g[r][c] = cl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; colorBorder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0, <span class="keyword">int</span> color) &#123;</span><br><span class="line">    dfs(grid, r0, c0, grid[r0][c0]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; grid.size(); ++i)    <span class="comment">// 根据dfs标记(负数)过的方块进行着色</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0</span>; j &lt; grid[i].size(); ++j) grid[i][j] = grid[i][j] &lt; <span class="number">0</span> ? color : grid[i][j];</span><br><span class="line">    <span class="keyword">return</span> grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结论: 无论是递归还是非递归,先标记(标记vis),再遍历</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-5040-边框着色/453425-20190430173552247-46622747.png&quot;&gt;
&lt;h3 id=&quot;方法一：dfs的非递归形式&quot;&gt;&lt;a href=&quot;#方法一：dfs的非递归形式&quot; class=&quot;head
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="dfs" scheme="https://brianyi.github.io/tags/dfs/"/>
    
      <category term="图" scheme="https://brianyi.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]5.最长回文子串</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-5-最长回文子串/</id>
    <published>2019-05-06T10:05:20.000Z</published>
    <updated>2019-05-07T03:14:37.772Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-5-最长回文子串/453425-20190505125039549-1852205917.png"><h3 id="方法一-中心扩展算法"><a href="#方法一-中心扩展算法" class="headerlink" title="方法一:中心扩展算法"></a>方法一:中心扩展算法</h3><p>解题思路:从左到右每一个字符都作为中心轴,然后逐渐往两边扩展,只要发现有不相等的字符,则确定了以该字符为轴的最长回文串,但需要考虑长度为奇数和偶数的不同情况的处理(长度为偶数时轴心为中间两个数的中心,长度为奇数时轴心为中间那个数)</p><p>算法时间复杂度: $O(n^{2})$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;        </span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>, maxL = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)　　<span class="comment">// i为轴的位置,j为回文串半径</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; i - j &gt;= <span class="number">0</span> &amp;&amp; i + j &lt; s.size(); ++j)    <span class="comment">// 奇数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i - j] != s[i + j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * j + <span class="number">1</span> &gt; maxL)</span><br><span class="line">            &#123;</span><br><span class="line">                maxL = <span class="number">2</span> * j + <span class="number">1</span>;</span><br><span class="line">                idx = i - j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; i - j &gt;= <span class="number">0</span> &amp;&amp; i + j + <span class="number">1</span> &lt; s.size(); ++j)    <span class="comment">// 偶数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i-j]!=s[i+j+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * j + <span class="number">2</span> &gt; maxL)</span><br><span class="line">            &#123;</span><br><span class="line">                maxL = <span class="number">2</span> * j + <span class="number">2</span>;</span><br><span class="line">                idx = i - j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substr(idx, maxL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="方法二-manacher-马拉车法"><a href="#方法二-manacher-马拉车法" class="headerlink" title="方法二: manacher(马拉车法)"></a>方法二: manacher(马拉车法)</h3><p>解题思路:详见<a href="https://www.luogu.org/problemnew/solution/P3805" target="_blank" rel="noopener">P3805【模板】manacher算法</a><br>为了使奇数串和偶数串一致性处理,首先进行字符填充,使其成为奇数串,即在每个字符的前后填充字符,例如:<br>原串: ABCCBA<br>填充后: ~#A#B#C#C#B#A#<br>原始串在数组中的位置:</p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:left">B</th><th style="text-align:center">C</th><th style="text-align:center">C</th><th style="text-align:center">B</th><th style="text-align:center">A</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:left">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td></tr></tbody></table><p>填充串在数组中的位置</p><table><thead><tr><th style="text-align:center">~</th><th style="text-align:center">#</th><th style="text-align:center">A</th><th style="text-align:center">#</th><th style="text-align:center">B</th><th style="text-align:center">#</th><th style="text-align:center">C</th><th style="text-align:center">#</th><th style="text-align:center">C</th><th style="text-align:center">#</th><th style="text-align:center">B</th><th style="text-align:center">#</th><th style="text-align:center">A</th><th style="text-align:center">#</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">9</td><td style="text-align:center">10</td><td style="text-align:center">11</td><td style="text-align:center">12</td><td style="text-align:center">13</td></tr></tbody></table><p>首先说明: </p><ul><li>奇数+偶数=奇数, 因此,奇数串填充偶数个#后为奇数串,偶数串填充奇数个#后为奇数串</li><li>~字符用来作为边界,用处在于进行两边扩展时做为结束条件</li><li>填充串中字符的最大回文半径 - 1 = 原字符串中该字符的回文串长度</li></ul><p>关于上述第3条我需要解释一下:</p><table><thead><tr><th style="text-align:center">s_copy</th><th style="text-align:center">~</th><th style="text-align:center">#</th><th style="text-align:center">A</th><th style="text-align:center">#</th><th style="text-align:center">B</th><th style="text-align:center">#</th><th style="text-align:center">C</th><th style="text-align:center">#</th><th style="text-align:center">C</th><th style="text-align:center">#</th><th style="text-align:center">B</th><th style="text-align:center">#</th><th style="text-align:center">A</th><th style="text-align:center">#</th></tr></thead><tbody><tr><td style="text-align:center">index</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">9</td><td style="text-align:center">10</td><td style="text-align:center">11</td><td style="text-align:center">12</td><td style="text-align:center">13</td></tr><tr><td style="text-align:center">pos</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">7</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr></tbody></table><p>可以看到index=7的位置,#对应的p为7(即最大回文半径),即在C与C之间,表示原字符串中该字符的回文长度为6,那么原字符串ABCCBA的前面3个字符ABC构成的回文串长度为6</p><blockquote><p>该题思路:</p><ol><li>字符串填充统一为奇数串</li><li>Manacher法,从左到右遍历每个字符<ol><li>记录每个字符的最大回文半径</li><li>确定已经记录的最大回文串右边界r,和中间轴m</li><li>当前字符s[i]是否能关于m找到一个对称点,即要满足:m&lt;=i&lt;=r<ol><li>能:则得到一个有可能的最大回文半径,并从该半径开始扩展</li><li>否:则从新计算最大回文半径</li></ol></li></ol></li></ol></blockquote><p>算法时间复杂度为: $O(n)$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pos[<span class="number">2005</span>],p[<span class="number">2005</span>];  <span class="comment">// pos用于记录填充串与原始字串的位置关系,p用于记录填充串当前字符的最大回文半径</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;        </span><br><span class="line">    <span class="comment">/* 填充字符,统一为奇数串 */</span></span><br><span class="line">    <span class="built_in">string</span> s_new=<span class="string">"~"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,k=<span class="number">1</span>;i&lt;s.size();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        s_new+=<span class="string">"#"</span>;</span><br><span class="line">        s_new+=s[i];</span><br><span class="line">        pos[k++]=i;</span><br><span class="line">        pos[k++]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    s_new+=<span class="string">"#"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* manacher */</span></span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">0</span>,r=<span class="number">0</span>,maxL=<span class="number">0</span>,idx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s_new.size();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取已知的最大回文半径,p[i]用于记录填充串对应字符的最大回文半径</span></span><br><span class="line">        <span class="keyword">if</span> (i&lt;r)</span><br><span class="line">            p[i]=min(p[<span class="number">2</span>*m-i],r-i); <span class="comment">// 当m&lt;=i&lt;=r时,i关于m中心轴对称的点为2*m-i,而p[2*m-i]是一定已经知道的</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p[i]=<span class="number">1</span>; <span class="comment">// 如果i超出了已知的最大回文右边界,则比如不能找到关于m对称的点,只能重新计算最大回文半径</span></span><br><span class="line">        <span class="comment">// 暴力拓展左右两侧,计算当前的最大回文半径</span></span><br><span class="line">        <span class="keyword">while</span> (s_new[i-p[i]]==s_new[i+p[i]])</span><br><span class="line">            p[i]++;</span><br><span class="line">        <span class="comment">// 新的回文半径比较大,则更新</span></span><br><span class="line">        <span class="keyword">if</span> (r-i&lt;p[i])</span><br><span class="line">        &#123;</span><br><span class="line">            m=i;</span><br><span class="line">            r=i+p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新回文长度(原始字串的回文长度为新字串回文半径-1)</span></span><br><span class="line">        <span class="keyword">if</span> (p[i]<span class="number">-1</span>&gt;=maxL)</span><br><span class="line">        &#123;</span><br><span class="line">            maxL=p[i]<span class="number">-1</span>;</span><br><span class="line">            idx=pos[i]-maxL/<span class="number">2</span>;  <span class="comment">// 更新原始回文字串的起始位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substr(idx,maxL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-5-最长回文子串/453425-20190505125039549-1852205917.png&quot;&gt;
&lt;h3 id=&quot;方法一-中心扩展算法&quot;&gt;&lt;a href=&quot;#方法一-中心扩展算法&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="回文串" scheme="https://brianyi.github.io/tags/%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    
  </entry>
  
</feed>
