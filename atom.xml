<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Brian&#39;s Home</title>
  
  <subtitle>Stay Hungry, Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://brianyi.github.io/"/>
  <updated>2019-05-07T05:06:07.090Z</updated>
  <id>https://brianyi.github.io/</id>
  
  <author>
    <name>Brian Yi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[leetcode]214.最短回文串</title>
    <link href="https://brianyi.github.io/2019/05/07/leetcode-214-%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>https://brianyi.github.io/2019/05/07/leetcode-214-最短回文串/</id>
    <published>2019-05-07T04:00:26.000Z</published>
    <updated>2019-05-07T05:06:07.090Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/07/leetcode-214-最短回文串/Image21.png"><h3 id="方法一-KMP算法"><a href="#方法一-KMP算法" class="headerlink" title="方法一: KMP算法"></a>方法一: KMP算法</h3><p>时间复杂度: $O(m+n)$</p><blockquote><p>解题思路: 实际就是求原串从左到右的最长回文串(必须包含左边所有字符),此处采用<strong>倒置+KMP算法</strong>来缩短匹配时间</p><ol><li>将字符串倒置,原串作为模式串pat,倒置串作为主串txt</li><li>求出模式串pat的nextval[]值,然后进行字符串匹配,得到的模式串pat最长匹配长度即为模式串pat从第一个字符开始的最大回文串(匹配过程时间复杂度只需要$O(m+n)$)</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nextval[<span class="number">40005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_nextval</span><span class="params">(<span class="built_in">string</span> pat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">-1</span>,len=pat.size();</span><br><span class="line">    nextval[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;i&lt;len&amp;&amp;j&lt;len;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">-1</span>||pat[i]==pat[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++,j++;</span><br><span class="line">            <span class="keyword">if</span> (pat[i]==pat[j])</span><br><span class="line">                nextval[i]=nextval[j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextval[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j=nextval[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="built_in">string</span> txt)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> pat=txt;</span><br><span class="line">    reverse(txt.begin(),txt.end()); <span class="comment">// O(n)</span></span><br><span class="line">    get_nextval(pat); <span class="comment">// </span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,lenTxt=txt.size(),lenPat=pat.size();</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;lenTxt&amp;&amp;j&lt;lenPat;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">-1</span>||txt[i]==pat[j])</span><br><span class="line">            i++,j++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = nextval[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> txt.substr(<span class="number">0</span>,lenTxt-j)+pat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/07/leetcode-214-最短回文串/Image21.png&quot;&gt;
&lt;h3 id=&quot;方法一-KMP算法&quot;&gt;&lt;a href=&quot;#方法一-KMP算法&quot; class=&quot;headerlink&quot; title=&quot;方法一: KMP算法&quot;&gt;&lt;/a&gt;方法一
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="回文串" scheme="https://brianyi.github.io/tags/%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    
      <category term="KMP" scheme="https://brianyi.github.io/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]TOC汇总</title>
    <link href="https://brianyi.github.io/2019/05/07/leetcode-TOC%E6%B1%87%E6%80%BB/"/>
    <id>https://brianyi.github.io/2019/05/07/leetcode-TOC汇总/</id>
    <published>2019-05-07T00:31:49.000Z</published>
    <updated>2019-05-07T03:06:59.931Z</updated>
    
    <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="请输入文章密码" />    <label for="pass">请输入文章密码</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      文章内容已被加密.&lt;/br&gt;
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="TOC" scheme="https://brianyi.github.io/tags/TOC/"/>
    
  </entry>
  
  <entry>
    <title>[algorithm]排序</title>
    <link href="https://brianyi.github.io/2019/05/06/algorithm-%E6%8E%92%E5%BA%8F/"/>
    <id>https://brianyi.github.io/2019/05/06/algorithm-排序/</id>
    <published>2019-05-06T14:58:06.000Z</published>
    <updated>2019-05-06T15:23:31.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-排序算法"><a href="#一-排序算法" class="headerlink" title="一.排序算法"></a>一.排序算法</h2><h3 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h3><h4 id="1-直接插入排序-插入类"><a href="#1-直接插入排序-插入类" class="headerlink" title="1) 直接插入排序:(插入类)"></a>1) 直接插入排序:(插入类)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( R[i].key &lt; R[i - <span class="number">1</span>].key )</span><br><span class="line">        &#123;</span><br><span class="line">            R[<span class="number">0</span>] = R[i];</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; <span class="number">0</span> &amp;&amp; ( R[<span class="number">0</span>].key &lt; R[j].key ); j-- )</span><br><span class="line">                R[j + <span class="number">1</span>] = R[j];</span><br><span class="line">            R[j + <span class="number">1</span>] = R[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况(顺序有序):</p><p>　　1)比较次数: $\sum_{i=2}^{n} 1=n-1$</p><p>　　2)移动次数: 0</p><p>最坏情况(逆序有序):</p><p>　　1)比较次数: $\sum_{i=2}^{n} i=\frac {(n+2)(n-1)}{2}$</p><p>　　2)移动次数: $\sum_{i=2}^{n} (i+1)=\frac {(n+4)(n-1)}{2}$</p><h4 id="2-折半插入排序-插入类"><a href="#2-折半插入排序-插入类" class="headerlink" title="2)折半插入排序:(插入类)"></a>2)折半插入排序:(插入类)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BiInsertSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        R[<span class="number">0</span>] = R[i];</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>, high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( low &lt;= high )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = ( low + high ) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ( R[<span class="number">0</span>].key &lt; R[m].key ) high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; high; j-- )</span><br><span class="line">            R[j + <span class="number">1</span>] = R[j];</span><br><span class="line">        R[j + <span class="number">1</span>] = R[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-希尔排序-又称缩小增量排序-插入类"><a href="#3-希尔排序-又称缩小增量排序-插入类" class="headerlink" title="3)希尔排序(又称缩小增量排序)(插入类)"></a>3)希尔排序(又称缩小增量排序)(插入类)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当dk=1时,即为直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> dk = n / <span class="number">2</span>; dk &gt;= <span class="number">1</span>; dk /= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = dk + <span class="number">1</span>; i &lt;= n; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( R[i].key &lt; R[i - dk].key )</span><br><span class="line">            &#123;</span><br><span class="line">                R[<span class="number">0</span>] = R[i];</span><br><span class="line">            <span class="keyword">for</span> ( j = i - dk; j &gt; <span class="number">0</span> &amp;&amp; ( R[<span class="number">0</span>].key &lt; R[j].key ); j -= dk )</span><br><span class="line">                    R[j + dk] = R[j];</span><br><span class="line">                R[j + dk] = R[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-交换排序"><a href="#2-交换排序" class="headerlink" title="2.交换排序"></a>2.交换排序</h3><h4 id="1-起泡排序-冒泡排序-交换类"><a href="#1-起泡排序-冒泡排序-交换类" class="headerlink" title="1)起泡排序(冒泡排序)(交换类)"></a>1)起泡排序(冒泡排序)(交换类)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = n; j &gt; i; j-- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (R[j].key &lt; R[j<span class="number">-1</span>].key )</span><br><span class="line">            &#123;</span><br><span class="line">                swap( R[j], R[j - <span class="number">1</span>] );</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( !flag ) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-快速排序-交换类"><a href="#2-快速排序-交换类" class="headerlink" title="2)快速排序:(交换类)"></a>2)快速排序:(交换类)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Partition</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快排</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( low &gt;= high ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivotpos = Partition( R, low, high );</span><br><span class="line">    QuickSort( R, low, pivotpos - <span class="number">1</span> );</span><br><span class="line">    QuickSort( R, pivotpos + <span class="number">1</span>, high );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 划分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Partition</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElemType pivot = R[low];</span><br><span class="line">    <span class="keyword">while</span> ( low &lt; high )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high &amp;&amp; R[high].key &gt;= pivot.key ) high--;</span><br><span class="line">        R[low] = R[high];</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high &amp;&amp; R[low].key &lt;= pivot.key ) low++;</span><br><span class="line">        R[high] = R[low];</span><br><span class="line">    &#125;</span><br><span class="line">    R[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3.选择排序"></a>3.选择排序</h3><h4 id="1-简单选择排序-选择类"><a href="#1-简单选择排序-选择类" class="headerlink" title="1)简单选择排序(选择类)"></a>1)简单选择排序(选择类)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( R[j].key &lt; R[min].key ) min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( min != i ) swap( R[i], R[min] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-堆排序-选择类"><a href="#2-堆排序-选择类" class="headerlink" title="2)堆排序(选择类)"></a>2)堆排序(选择类)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">( ElemType R[], <span class="keyword">int</span> s, <span class="keyword">int</span> n )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt; <span class="number">0</span>; i-- )</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">( R, i, n )</span></span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; i-- )</span><br><span class="line">    &#123;</span><br><span class="line">        swap( R[i], R[<span class="number">1</span>] );</span><br><span class="line">        AdjustDown( R, <span class="number">1</span>, i - <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">( ElemType R[], <span class="keyword">int</span> s, <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    R[<span class="number">0</span>] = R[s];</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span> * s; i &lt;= n; i *= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( i &lt; n&amp;&amp;R[i].key &lt; R[i + <span class="number">1</span>].key ) i++;</span><br><span class="line">        <span class="keyword">if</span> (R[<span class="number">0</span>].key  &gt;=R[i].key ) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            R[s] = R[i]; s = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    R[s] = R[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向上调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustUp</span><span class="params">( ElemType R[], <span class="keyword">int</span> s )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    R[<span class="number">0</span>] = R[s];</span><br><span class="line">    <span class="keyword">int</span> p = s / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> ( p &gt;&amp;&amp; R[p].key &lt; R[<span class="number">0</span>].key )</span><br><span class="line">    &#123;</span><br><span class="line">        R[s] = R[p];</span><br><span class="line">        s = p;</span><br><span class="line">        p /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    R[s] = R[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-归并排序-归并类"><a href="#4-归并排序-归并类" class="headerlink" title="4.归并排序(归并类)"></a>4.归并排序(归并类)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( low &gt;= high ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = ( low + high ) / <span class="number">2</span>;</span><br><span class="line">    MergeSort( R, low, mid );</span><br><span class="line">    MergeSort( R, mid + <span class="number">1</span>, high );</span><br><span class="line">    Merge( R, low, mid, high );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElemType B[MAXSIZE];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span> ( i = low; i &lt;= high; i++ )</span><br><span class="line">        B[i] = R[i];</span><br><span class="line">    i = k = low, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ( i &lt;= mid &amp;&amp; j &lt;= high )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( B[i].key &lt;= B[j].key )</span><br><span class="line">            R[k++] = B[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            R[k++] = B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( i &lt;= mid ) R[k++] = B[i++];</span><br><span class="line">    <span class="keyword">while</span> ( j &lt;= high ) R[k++] = B[j++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-综合题-算法"><a href="#二-综合题-算法" class="headerlink" title="二.综合题(算法)"></a>二.综合题(算法)</h2><p>1.设顺序表用数组R[]表示,表中存储在数组下标1~m+n的范围内,前m个元素递增有序,后n个元素递增有序,设计一个算法,使得整个顺序表有序<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> m, <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = m + <span class="number">1</span>; i &lt;= m + n; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( R[i].key &lt; R[i - <span class="number">1</span>].key )</span><br><span class="line">        &#123;</span><br><span class="line">            R[<span class="number">0</span>] = R[i];</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; <span class="number">0</span> &amp;&amp; ( R[<span class="number">0</span>].key &lt; R[j].key ); j-- )</span><br><span class="line">                R[j + <span class="number">1</span>] = R[j];</span><br><span class="line">            R[j + <span class="number">1</span>] = R[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.计数排序:对表进行排序并将结果放到另一个新的表中,要求表中所有关键码互不相同<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountSort</span><span class="params">( ElemType A[], ElemType B[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++ )</span><br><span class="line">            <span class="keyword">if</span> ( A[i].key &gt; A[j].key )cnt++;</span><br><span class="line">        B[cnt] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.双向冒泡排序<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思想:第一趟通过交换把最大的放最后,第二趟通过交换把最小的放最前,反复进行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">( ElemType A[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = n - <span class="number">1</span>, i;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> ( low &lt; high &amp;&amp; flag )</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = low; i &lt; high; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i]&gt;A[i+<span class="number">1</span>] )</span><br><span class="line">            &#123;</span><br><span class="line">                swap( A[i], A[i + <span class="number">1</span>] ); flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high--;</span><br><span class="line">        <span class="keyword">for</span> ( i = high; i &gt; low; i-- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( A[i] &lt; A[i - <span class="number">1</span>] )</span><br><span class="line">            &#123;</span><br><span class="line">                swap( A[i], A[i - <span class="number">1</span>] ); flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        low++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.单链表的简单选择排序(假设不带表头结点)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">( LinkList&amp; L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList h, p, s, pre, r;</span><br><span class="line">    h = L;</span><br><span class="line">    <span class="keyword">while</span> ( h )</span><br><span class="line">    &#123;</span><br><span class="line">        p = s = h; pre = r = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 找最大结点s</span></span><br><span class="line">        <span class="keyword">while</span> ( p )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;data&gt;s-&gt;data )</span><br><span class="line">            &#123;</span><br><span class="line">                s = p; r = pre;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 脱链</span></span><br><span class="line">        <span class="keyword">if</span> ( s == h ) h = h-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> r-&gt;next = s-&gt;next;</span><br><span class="line">        <span class="comment">// 头插法</span></span><br><span class="line">        s-&gt;next = L; L = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5.顺序表中有n个不同整数(下标1~n),设计算法把所有奇数移动到偶数前面(时,空都最少)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">( ElemType A[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">1</span>, high = n;</span><br><span class="line">    <span class="keyword">while</span> ( low &lt; high )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high&amp;&amp;A[low] % <span class="number">2</span> ) low++;</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high &amp;&amp; A[high] % <span class="number">2</span> == <span class="number">0</span> ) high--;</span><br><span class="line">        <span class="keyword">if</span> ( low &lt; high )</span><br><span class="line">        &#123;</span><br><span class="line">            swap( A[low], A[high] );</span><br><span class="line">            low++; high--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6.在顺序表中找出第k小的元素(时空最少)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思想:划分</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = R[low];</span><br><span class="line">    <span class="keyword">while</span> ( low &lt; high )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high &amp;&amp; R[high].key &gt;= pivot.key ) high--;</span><br><span class="line">        R[low] = R[high];</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high&amp;&amp; R[low].key &lt;= pivot.key ) low++;</span><br><span class="line">            R[high] = R[low];</span><br><span class="line">    &#125;</span><br><span class="line">    R[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">Kth_elem</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> k )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivotpos = Partition( R, low, high );</span><br><span class="line">    <span class="keyword">if</span> ( pivotpos == k ) <span class="keyword">return</span> R[pivotpos];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( pivotpos &gt; k ) <span class="keyword">return</span> Kth_elem( R, low, pivotpos - <span class="number">1</span>, k );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Kth_elem( R, pivotpos + <span class="number">1</span>, high, k );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>7.n个正整数构成的集合A,将其划分为两个不相交的子集$A1,A2$,元素个数分别是n1和n2.A1和A2中元素之和分别为S1和S2.设计一个时空高效算法,使|n1-n2|最小且|s1-s1|最大.(下标从1开始)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = R[low];</span><br><span class="line">    <span class="keyword">while</span> ( low &lt; high )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high &amp;&amp; R[high].key &gt;= pivot.key ) high--;</span><br><span class="line">        R[low] = R[high];</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high&amp;&amp; R[low].key &lt;= pivot.key ) low++;</span><br><span class="line">        R[high] = R[low];</span><br><span class="line">    &#125;</span><br><span class="line">    R[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetPartition</span><span class="params">( ElemType R[], <span class="keyword">int</span> n, <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = n / <span class="number">2</span>, s1, s2, i;</span><br><span class="line">    <span class="keyword">int</span> pivotpos = Partition( R, low, high );</span><br><span class="line">    <span class="keyword">if</span> ( pivotpos == k )</span><br><span class="line">    &#123;</span><br><span class="line">        s1 = s2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt;= k; i++ ) s1 += R[i];</span><br><span class="line">        <span class="keyword">for</span> ( j = k + <span class="number">1</span>; j &lt;= n; j++ ) s2 += R[j];</span><br><span class="line">        <span class="keyword">return</span> s2 - s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( pivotpos &gt; k )</span><br><span class="line">        <span class="keyword">return</span> SetPartition( R, n, low, pivotpos - <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> SetPartition( R, n, pivotpos + <span class="number">1</span>, high );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-排序算法&quot;&gt;&lt;a href=&quot;#一-排序算法&quot; class=&quot;headerlink&quot; title=&quot;一.排序算法&quot;&gt;&lt;/a&gt;一.排序算法&lt;/h2&gt;&lt;h3 id=&quot;1-插入排序&quot;&gt;&lt;a href=&quot;#1-插入排序&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="algorithm" scheme="https://brianyi.github.io/categories/algorithm/"/>
    
    
      <category term="排序" scheme="https://brianyi.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]133.克隆图</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-133-%E5%85%8B%E9%9A%86%E5%9B%BE/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-133-克隆图/</id>
    <published>2019-05-06T13:21:48.000Z</published>
    <updated>2019-05-06T13:27:25.958Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-133-克隆图/453425-20190430181854853-2091334093.png"><h3 id="方法一-dfs-递归"><a href="#方法一-dfs-递归" class="headerlink" title="方法一:dfs(递归)"></a>方法一:dfs(递归)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;Node*,Node*&gt; dict;</span><br><span class="line"><span class="function">Node* <span class="title">clone</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> node;</span><br><span class="line">    <span class="keyword">if</span> (dict.count(node)) <span class="keyword">return</span> dict[node];</span><br><span class="line">    dict[node]=<span class="keyword">new</span> Node(node-&gt;val,<span class="built_in">vector</span>&lt;Node*&gt;&#123;&#125;);　　<span class="comment">// 这里不能写clone(node),会导致死循环,记住,在new的时候千万不要再递归,递归最低层一定有一个明确结果,所以要把截止条件写清楚</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:node-&gt;neighbors)</span><br><span class="line">        dict[node]-&gt;neighbors.push_back(clone(it));</span><br><span class="line">    <span class="keyword">return</span> dict[node];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> clone(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二-dfs-非递归"><a href="#方法二-dfs-非递归" class="headerlink" title="方法二:dfs(非递归)"></a>方法二:dfs(非递归)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;Node*,Node*&gt; dict;</span><br><span class="line"><span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Node*&gt; S;</span><br><span class="line">    S.push(node);</span><br><span class="line">    <span class="keyword">while</span> (!S.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Node *p = S.top();</span><br><span class="line">        S.pop();</span><br><span class="line">        <span class="keyword">if</span> (!dict.count(p))　　<span class="comment">// 从栈中出来的都是没有进行访问过的点</span></span><br><span class="line">            dict[p]=<span class="keyword">new</span> Node(p-&gt;val,<span class="built_in">vector</span>&lt;Node*&gt;&#123;&#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it:p-&gt;neighbors)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dict.count(it))　　<span class="comment">// 判断是否已经访问过该点</span></span><br><span class="line">            &#123;</span><br><span class="line">                dict[it]=<span class="keyword">new</span> Node(it-&gt;val,<span class="built_in">vector</span>&lt;Node*&gt;&#123;&#125;);</span><br><span class="line">                S.push(it);</span><br><span class="line">            &#125;</span><br><span class="line">            dict[p]-&gt;neighbors.push_back(dict[it]);　　<span class="comment">// 将新点的拷贝放入neighbors中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dict[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-133-克隆图/453425-20190430181854853-2091334093.png&quot;&gt;
&lt;h3 id=&quot;方法一-dfs-递归&quot;&gt;&lt;a href=&quot;#方法一-dfs-递归&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="dfs" scheme="https://brianyi.github.io/tags/dfs/"/>
    
      <category term="图" scheme="https://brianyi.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]138.复制带随机指针的链表</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-138-复制带随机指针的链表/</id>
    <published>2019-05-06T13:20:18.000Z</published>
    <updated>2019-05-06T14:43:56.130Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-138-复制带随机指针的链表/453425-20190430193735900-662137168.png"><h3 id="方法一-递归"><a href="#方法一-递归" class="headerlink" title="方法一:递归"></a>方法一:递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;Node*,Node*&gt; dict;</span><br><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">if</span> (dict.count(head)) <span class="keyword">return</span> dict[head];</span><br><span class="line">    dict[head]=<span class="keyword">new</span> Node(head-&gt;val, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    dict[head]-&gt;next=copyRandomList(head-&gt;next);</span><br><span class="line">    dict[head]-&gt;random=copyRandomList(head-&gt;random);</span><br><span class="line">    <span class="keyword">return</span> dict[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二-非递归"><a href="#方法二-非递归" class="headerlink" title="方法二:非递归"></a>方法二:非递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;Node*,Node*&gt; m;</span><br><span class="line">    Node *p=head;</span><br><span class="line">    <span class="keyword">while</span>(p)    <span class="comment">// make a copy of nodes</span></span><br><span class="line">    &#123;</span><br><span class="line">        m[p]=<span class="keyword">new</span> Node(p-&gt;val,<span class="literal">nullptr</span>,<span class="literal">nullptr</span>);</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p=head;</span><br><span class="line">    <span class="keyword">while</span>(p)    <span class="comment">// link everyone and fill the random field</span></span><br><span class="line">    &#123;</span><br><span class="line">        m[p]-&gt;next=m[p-&gt;next];</span><br><span class="line">        m[p]-&gt;random=m[p-&gt;random];</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-138-复制带随机指针的链表/453425-20190430193735900-662137168.png&quot;&gt;
&lt;h3 id=&quot;方法一-递归&quot;&gt;&lt;a href=&quot;#方法一-递归&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="链表" scheme="https://brianyi.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]144.二叉树的前序遍历</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-144-二叉树的前序遍历/</id>
    <published>2019-05-06T13:17:07.000Z</published>
    <updated>2019-05-06T13:19:44.482Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-144-二叉树的前序遍历/453425-20190501113746021-447522744.png"><p>前往二叉树的:前序,中序,后序 遍历算法</p><h3 id="方法一-递归"><a href="#方法一-递归" class="headerlink" title="方法一:递归"></a>方法一:递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    res.push_back(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) preorderTraversal(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right) preorderTraversal(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二-非递归"><a href="#方法二-非递归" class="headerlink" title="方法二:非递归"></a>方法二:非递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">    TreeNode* p = root;</span><br><span class="line">    <span class="keyword">while</span>(p||!S.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p)  <span class="comment">// 访问左子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(p-&gt;val);</span><br><span class="line">            S.push(p);</span><br><span class="line">            p=p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">// 访问右子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=S.top();</span><br><span class="line">            S.pop();</span><br><span class="line">            p=p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三-非递归-该方法可用于后序遍历-需要修改几处代码"><a href="#方法三-非递归-该方法可用于后序遍历-需要修改几处代码" class="headerlink" title="方法三:非递归(该方法可用于后序遍历,需要修改几处代码)"></a>方法三:非递归(该方法可用于后序遍历,需要修改几处代码)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">    S.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!S.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        root=S.top();</span><br><span class="line">        S.pop();</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) S.push(root-&gt;right);  <span class="comment">// 要实现后序遍历,需要以下两行调换</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) S.push(root-&gt;left);</span><br><span class="line">        res.push_back(root-&gt;val);   <span class="comment">// res.insert(0,root-&gt;val)即为后序遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论:</p><ul><li>方法三这种形式只适合前序和后序遍历,不适合中序遍历,中序遍历较为麻烦</li><li>方法二这种形式只适合前序和中序遍历,不适合后序遍历,后序遍历较为麻烦</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-144-二叉树的前序遍历/453425-20190501113746021-447522744.png&quot;&gt;
&lt;p&gt;前往二叉树的:前序,中序,后序 遍历算法&lt;/p&gt;
&lt;h3 id=&quot;方法一-递归&quot;&gt;&lt;a href=&quot;#方
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="树" scheme="https://brianyi.github.io/tags/%E6%A0%91/"/>
    
      <category term="递归" scheme="https://brianyi.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]94.二叉树的中序遍历</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-94-二叉树的中序遍历/</id>
    <published>2019-05-06T13:14:44.000Z</published>
    <updated>2019-05-06T14:20:07.345Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-94-二叉树的中序遍历/453425-20190501120139941-1568037684.png"><p>前往二叉树的:<a href>前序</a>,<a href>中序</a>,<a href>后序</a> 遍历算法</p><h3 id="方法一-递归"><a href="#方法一-递归" class="headerlink" title="方法一:递归"></a>方法一:递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) inorderTraversal(root-&gt;left);      </span><br><span class="line">    res.push_back(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right) inorderTraversal(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二-非递归"><a href="#方法二-非递归" class="headerlink" title="方法二:非递归"></a>方法二:非递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">    TreeNode* p = root;</span><br><span class="line">    <span class="keyword">while</span>(p||!S.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            S.push(p);</span><br><span class="line">            p=p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=S.top();</span><br><span class="line">            S.pop();</span><br><span class="line">            res.push_back(p-&gt;val);</span><br><span class="line">            p=p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-94-二叉树的中序遍历/453425-20190501120139941-1568037684.png&quot;&gt;
&lt;p&gt;前往二叉树的:&lt;a href&gt;前序&lt;/a&gt;,&lt;a href&gt;中序&lt;/a&gt;,&lt;a href&gt;后序&lt;/a&gt; 
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="树" scheme="https://brianyi.github.io/tags/%E6%A0%91/"/>
    
      <category term="递归" scheme="https://brianyi.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]145.二叉树的后序遍历</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-145-二叉树的后序遍历/</id>
    <published>2019-05-06T13:12:06.000Z</published>
    <updated>2019-05-06T13:14:29.228Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-145-二叉树的后序遍历/453425-20190501122117295-85727166.png"><p>前往二叉树的:前序,中序,后序 遍历算法</p><h3 id="方法一-递归"><a href="#方法一-递归" class="headerlink" title="方法一:递归"></a>方法一:递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) postorderTraversal(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right) postorderTraversal(root-&gt;right);</span><br><span class="line">    res.push_back(root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二-非递归"><a href="#方法二-非递归" class="headerlink" title="方法二:非递归"></a>方法二:非递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">    TreeNode* p=root, *r=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (p||!S.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            S.push(p);</span><br><span class="line">            p=p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=S.top();</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right&amp;&amp;p-&gt;right!=r)</span><br><span class="line">                p=p-&gt;right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                S.pop();</span><br><span class="line">                res.push_back(p-&gt;val);</span><br><span class="line">                r=p;</span><br><span class="line">                p=<span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="方法三-非递归"><a href="#方法三-非递归" class="headerlink" title="方法三:非递归"></a>方法三:非递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">    TreeNode* p=root;</span><br><span class="line">    S.push(p);</span><br><span class="line">    <span class="keyword">while</span> (!S.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        p=S.top();</span><br><span class="line">        S.pop();</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;left) S.push(p-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right) S.push(p-&gt;right);</span><br><span class="line">        res.insert(res.begin(),p-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-145-二叉树的后序遍历/453425-20190501122117295-85727166.png&quot;&gt;
&lt;p&gt;前往二叉树的:前序,中序,后序 遍历算法&lt;/p&gt;
&lt;h3 id=&quot;方法一-递归&quot;&gt;&lt;a href=&quot;#方法
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="树" scheme="https://brianyi.github.io/tags/%E6%A0%91/"/>
    
      <category term="递归" scheme="https://brianyi.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]968.监控二叉树</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-968-监控二叉树/</id>
    <published>2019-05-06T13:08:13.000Z</published>
    <updated>2019-05-06T13:11:46.627Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-968-监控二叉树/453425-20190501230642291-677698823.png"><p>解题思路: 由于叶子节点一定不要安装监视器,这样才能使总监视器数量比较少,因此需要从下往上进行判断当前节点的状态(共:3种状态):</p><ul><li>0: 当前节点安装了监视器</li><li>1: 当前节点可观,但没有安装监视器</li><li>2: 当前节点不可观<br>对于空节点,我们认为是可观,但没有安装监视器,因此,叶子节点就为不可观的了,设想一个节点的左右孩子(为空)都可观且没有安装监视器,那该节点必然是不可观即2</li></ul><p>有了以上对空节点和叶子节点的处理,我们再来正式分析非终端节点:</p><ul><li>若一个节点的左孩子或右孩子不可观,那么该节点必然不可观,需要安装监视器,因此返回0状态</li><li>若一个节点的左孩子或右孩子都可观且至少有一个安装了监视器,那么该节点必然是可观的,返回1状态</li><li>若一个节点的左右孩子都可观且没安装监视器,那么该节点必然是不可观的,返回2状态<br>记住,我们以上的分析都是基于从整个二叉树的叶子节点往根部,即从下往上进行,而且要做的就是将不可观的节点变得可观才行(因此要根据左右孩子的节点的状态来判断当前节点状态并做出调整)</li></ul><p>这里可能会有疑惑,以上的第一条得出当前节点不可观,然后安装了监视器,而第三条也得出当前节点不可观,但却没有安装监视器,而是直接返回的2状态(当前节点不可观).这是为什么?</p><p>因为,对于第一条,因为左右孩子都不可观,为了让左右孩子都可观,则必须给当前节点安装监视器才行,而第三条中,左右孩子都是可观的(没有安装监视器),当前节点的可以直接返回不可观状态,因为后面可以由他的父节点进行摄像头安装,使其变得可观.</p><h3 id="方法一-递归"><a href="#方法一-递归" class="headerlink" title="方法一:递归"></a>方法一:递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0：该节点安装了监视器 1：该节点可观，但没有安装监视器 2：该节点不可观</span></span><br><span class="line"><span class="keyword">int</span> monitor = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">state</span><span class="params">(TreeNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left  = state(node-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> right = state(node-&gt;right);</span><br><span class="line">    <span class="comment">// 该节点为0的情况</span></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">2</span> || right == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        monitor++;  <span class="comment">// 由于左或右节点不可观,则需要给当前节点安装监视器,为0状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="comment">// 为1的情况</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="number">0</span> || right == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">// 当(left!=2&amp;&amp;right!=2)时,才会进行该判断,也就是左右节点一定是可观的,再判断是否有一个安装了监视器,如有安装,则当前节点就不需要安装监视器也可观了,为1状态</span></span><br><span class="line">    <span class="comment">// 为2的情况</span></span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">// 其他:党(left!=2&amp;&amp;right!=2)&amp;&amp;(left!=0&amp;&amp;right!=0),即left==1&amp;&amp;right==1时,左右节点都可观,但没有监视器,当前节点不可观,为2状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (state(root) == <span class="number">2</span>) monitor++;    <span class="comment">// 如果根节点为2的状态,需要加一个监视器</span></span><br><span class="line">    <span class="keyword">return</span> monitor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:这里的if,else if,else的顺序是不能变的,先判断左右都是不可观的,再就是都可观,左或右至少有一个为监视器,最后才是都可观都无监视器.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-968-监控二叉树/453425-20190501230642291-677698823.png&quot;&gt;
&lt;p&gt;解题思路: 由于叶子节点一定不要安装监视器,这样才能使总监视器数量比较少,因此需要从下往上进行判断当前节点的状
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="dp" scheme="https://brianyi.github.io/tags/dp/"/>
    
      <category term="二叉树" scheme="https://brianyi.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]106.从中序与后序遍历序列构造二叉树</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-106-从中序与后序遍历序列构造二叉树/</id>
    <published>2019-05-06T12:16:02.000Z</published>
    <updated>2019-05-06T13:27:31.595Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-106-从中序与后序遍历序列构造二叉树/453425-20190502213938801-1912607084.png"><p>前往 中序,后序遍历构造二叉树, 中序,前序遍历构造二叉树<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> l1, <span class="keyword">int</span> r1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;postorder, <span class="keyword">int</span> l2, <span class="keyword">int</span> r2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1&gt;r1) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> x = postorder[r2], i = <span class="number">0</span>;   <span class="comment">// 确定当前根节点</span></span><br><span class="line">    <span class="keyword">for</span> (i = l1; i &lt;= r1 &amp;&amp; inorder[i] != x; ++i);  <span class="comment">// 在中序遍历序列中找到当前根节点位置(该位置可以划分出左右两个分支)</span></span><br><span class="line">    <span class="keyword">int</span> llen = i - l1;  <span class="comment">// 左子树结点数量</span></span><br><span class="line">    <span class="keyword">int</span> rlen = r1 - i;  <span class="comment">// 右子树结点数量</span></span><br><span class="line">    TreeNode* p = <span class="keyword">new</span> TreeNode(x);  <span class="comment">// 建立根节点</span></span><br><span class="line">    p-&gt;left = build(inorder, l1, l1 + llen - <span class="number">1</span>, postorder, l2, l2 + llen - <span class="number">1</span>);  <span class="comment">// 递归建立左子树,-1,-1是把当前根节点位置去掉</span></span><br><span class="line">    p-&gt;right = build(inorder, r1 - rlen + <span class="number">1</span>, r1, postorder, r2 - rlen, r2 - <span class="number">1</span>); <span class="comment">// 递归建立右子树,+1,-1是把当前根节点位置去掉</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inorder.empty()||postorder.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> build(inorder, <span class="number">0</span>, inorder.size() - <span class="number">1</span>, postorder, <span class="number">0</span>, postorder.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-106-从中序与后序遍历序列构造二叉树/453425-20190502213938801-1912607084.png&quot;&gt;
&lt;p&gt;前往 中序,后序遍历构造二叉树, 中序,前序遍历构造二叉树&lt;br&gt;&lt;figure cla
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="树" scheme="https://brianyi.github.io/tags/%E6%A0%91/"/>
    
      <category term="递归" scheme="https://brianyi.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]105.从前序与中序遍历序列构造二叉树</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-105-从前序与中序遍历序列构造二叉树/</id>
    <published>2019-05-06T12:14:01.000Z</published>
    <updated>2019-05-06T12:15:26.558Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-105-从前序与中序遍历序列构造二叉树/453425-20190502215802448-663626721.png"><p>前往 中序,后序遍历构造二叉树, 中序,前序遍历构造二叉树<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> l1, <span class="keyword">int</span> r1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> l2, <span class="keyword">int</span> r2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1&gt;r1) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> x=preorder[l1], i=<span class="number">0</span>;    <span class="comment">// 确定当前根节点</span></span><br><span class="line">    <span class="keyword">for</span>(i=l2;inorder[i]!=x&amp;&amp;i&lt;r2;++i);  <span class="comment">// 在中序遍历序列中找到当前根节点位置(该位置可以划分出左右两个分支)</span></span><br><span class="line">    <span class="keyword">int</span> llen=i-l2;  <span class="comment">// 左子树结点数量</span></span><br><span class="line">    <span class="keyword">int</span> rlen=r2-i;  <span class="comment">// 右子树结点数量</span></span><br><span class="line">    TreeNode *p = <span class="keyword">new</span> TreeNode(x);  <span class="comment">// 建立根节点</span></span><br><span class="line">    p-&gt;left = build(preorder, l1+<span class="number">1</span>, l1+llen, inorder, l2, l2+llen<span class="number">-1</span>);   <span class="comment">// 递归建立左子树,+1,-1是把当前根节点位置去掉</span></span><br><span class="line">    p-&gt;right= build(preorder, r1-rlen+<span class="number">1</span>, r1, inorder, r2-rlen+<span class="number">1</span>, r2);   <span class="comment">// 递归建立右子树,+1,+1是把当前根节点位置去掉</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.size()<span class="number">-1</span>, inorder, <span class="number">0</span>, inorder.size()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-105-从前序与中序遍历序列构造二叉树/453425-20190502215802448-663626721.png&quot;&gt;
&lt;p&gt;前往 中序,后序遍历构造二叉树, 中序,前序遍历构造二叉树&lt;br&gt;&lt;figure clas
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="树" scheme="https://brianyi.github.io/tags/%E6%A0%91/"/>
    
      <category term="递归" scheme="https://brianyi.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]114.二叉树展开为链表</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-114-二叉树展开为链表/</id>
    <published>2019-05-06T12:12:04.000Z</published>
    <updated>2019-05-06T12:13:26.706Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-114-二叉树展开为链表/453425-20190502231706813-609020347.png"><p>思路:递归,将左子树变成单链表形式,再将右子树变成单链表形式,最后将左子树单链表的末端连接到右子树单链表表头,将根节点的左孩子置空</p><h3 id="方法一-递归"><a href="#方法一-递归" class="headerlink" title="方法一: 递归"></a>方法一: 递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    flatten(root-&gt;left);    <span class="comment">// 将左子树变成单链表形式</span></span><br><span class="line">    flatten(root-&gt;right);   <span class="comment">// 将右子树变成单链表形式</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) <span class="comment">// 将左子树单链表的末端连接到右子树单链表表头</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* p=root-&gt;left;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;right) p=p-&gt;right;</span><br><span class="line">        p-&gt;right=root-&gt;right;</span><br><span class="line">        root-&gt;right=root-&gt;left;</span><br><span class="line">        root-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-114-二叉树展开为链表/453425-20190502231706813-609020347.png&quot;&gt;
&lt;p&gt;思路:递归,将左子树变成单链表形式,再将右子树变成单链表形式,最后将左子树单链表的末端连接到右子树单链表
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="树" scheme="https://brianyi.github.io/tags/%E6%A0%91/"/>
    
      <category term="递归" scheme="https://brianyi.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]239.滑动窗口最大值</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-239-滑动窗口最大值/</id>
    <published>2019-05-06T12:10:15.000Z</published>
    <updated>2019-05-06T12:11:33.534Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-239-滑动窗口最大值/453425-20190503094513334-1691572073.png"><p>思路:滑动窗口的思想,只要是求连续子序列或者子串问题,都可用滑动窗口的思想</p><h3 id="方法一-滑动窗口"><a href="#方法一-滑动窗口" class="headerlink" title="方法一: 滑动窗口"></a>方法一: 滑动窗口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (nums.size()==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;　　</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;nums.size();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!dq.empty()&amp;&amp;nums[i]&gt;nums[dq.back()]) <span class="comment">//在尾部添加元素，并保证左边元素都比尾部大</span></span><br><span class="line">            dq.pop_back();</span><br><span class="line">        dq.push_back(i);</span><br><span class="line">        <span class="keyword">if</span> (i-k==dq.front())    <span class="comment">//在头部移除元素</span></span><br><span class="line">            dq.pop_front();</span><br><span class="line">        <span class="keyword">if</span> (i&gt;=k<span class="number">-1</span>)</span><br><span class="line">            res.push_back(nums[dq.front()]);    <span class="comment">// 存放每次窗口内的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-239-滑动窗口最大值/453425-20190503094513334-1691572073.png&quot;&gt;
&lt;p&gt;思路:滑动窗口的思想,只要是求连续子序列或者子串问题,都可用滑动窗口的思想&lt;/p&gt;
&lt;h3 id=&quot;方法
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="滑动窗口" scheme="https://brianyi.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]76.最小覆盖子串</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-76-最小覆盖子串/</id>
    <published>2019-05-06T12:08:01.000Z</published>
    <updated>2019-05-06T12:09:32.405Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-76-最小覆盖子串/453425-20190503105807149-1455260747.png"><p>思路:滑动窗口思想</p><h3 id="方法一-滑动窗口"><a href="#方法一-滑动窗口" class="headerlink" title="方法一:滑动窗口"></a>方法一:滑动窗口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.tdict记录T中每个字母与字母个数</span></span><br><span class="line">    <span class="comment">// 2.维护一个滑动窗口字母的计数表sdict,计数当前窗口内T中字母出现的次数</span></span><br><span class="line">    <span class="comment">// 3.当窗口内T中字母出现的次数大于等于T中每个字母出现的次数一样,这时第一个最短子串出现,再逐步从左边缩短窗口,直到不满足上述条件,然后再从右边扩大窗口,直到满足条件时,再进行最短子串长度对比,一直更新最短长度子串直到结束</span></span><br><span class="line">    <span class="keyword">if</span> (s.size()&lt;t.size()||s.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; tdict,sdict;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,k=t.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:t)  <span class="comment">// 填充T的字母与字母计数表</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tdict.count(it)) tdict[it]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> tdict[it]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(r=<span class="number">0</span>;r&lt;s.size();++r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tdict.count(s[r])) <span class="comment">// 有字符,则进行记录</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!sdict.count(s[r]))</span><br><span class="line">                sdict[s[r]]=<span class="number">0</span>;</span><br><span class="line">            sdict[s[r]]++;</span><br><span class="line">            <span class="keyword">if</span> (sdict[s[r]]&lt;=tdict[s[r]])</span><br><span class="line">                k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(k==<span class="number">0</span>) <span class="comment">// 满足条件,滑动窗口从左边逐步缩短,直到剔除第一个属于T中的字符为止</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.empty()||r-l+<span class="number">1</span>&lt;res.size())  <span class="comment">// 最短子串更新</span></span><br><span class="line">                res=s.substr(l,r-l+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(tdict.count(s[l]))</span><br><span class="line">            &#123;</span><br><span class="line">                sdict[s[l]]--;</span><br><span class="line">                <span class="keyword">if</span> (sdict[s[l]]&lt;tdict[s[l]])</span><br><span class="line">                    k++;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-76-最小覆盖子串/453425-20190503105807149-1455260747.png&quot;&gt;
&lt;p&gt;思路:滑动窗口思想&lt;/p&gt;
&lt;h3 id=&quot;方法一-滑动窗口&quot;&gt;&lt;a href=&quot;#方法一-滑动窗口&quot; cl
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="滑动窗口" scheme="https://brianyi.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]3.无重复字符的最长子串</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-3-无重复字符的最长子串/</id>
    <published>2019-05-06T12:05:28.000Z</published>
    <updated>2019-05-06T14:39:45.897Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-3-无重复字符的最长子串/453425-20190503112154412-1836563639.png"><p>思路:滑动窗口的思想</p><h3 id="方法一-滑动窗口"><a href="#方法一-滑动窗口" class="headerlink" title="方法一:滑动窗口"></a>方法一:滑动窗口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        控制一个滑动窗口,窗口内的字符都是不重复的,通过set可以做到判断字符是否重复</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">    <span class="keyword">size_t</span> maxL=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;r&lt;s.size();++r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">set</span>.count(s[r]))   <span class="comment">// 当前判断的元素不存在于滑动窗口[l,r-1]中</span></span><br><span class="line">            <span class="built_in">set</span>.insert(s[r]);   <span class="comment">// 将元素放入滑动窗口(即记录不重复字符)</span></span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">// 当前判断的元素已经存在于滑动窗口[l,r-1]中</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">set</span>.count(s[r]))  <span class="comment">// 从左缩短窗口,直到剔除当前判断的元素为止</span></span><br><span class="line">                <span class="built_in">set</span>.erase(s[l++]);</span><br><span class="line">            <span class="built_in">set</span>.insert(s[r]);   <span class="comment">// 将当前判断元素放入到滑动窗口中</span></span><br><span class="line">        &#125;</span><br><span class="line">        maxL=max(maxL,<span class="built_in">set</span>.size());  <span class="comment">// 更新无重复字符的最长子串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-3-无重复字符的最长子串/453425-20190503112154412-1836563639.png&quot;&gt;
&lt;p&gt;思路:滑动窗口的思想&lt;/p&gt;
&lt;h3 id=&quot;方法一-滑动窗口&quot;&gt;&lt;a href=&quot;#方法一-滑动窗口
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="滑动窗口" scheme="https://brianyi.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]1028.从先序遍历还原二叉树</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-1028-%E4%BB%8E%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-1028-从先序遍历还原二叉树/</id>
    <published>2019-05-06T12:00:45.000Z</published>
    <updated>2019-05-06T12:05:01.645Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-1028-从先序遍历还原二叉树/453425-20190503131537591-466226739.png"><p>思路:用一个栈来管理树的层次关系,索引代表节点的深度</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">recoverFromPreorder</span><span class="params">(<span class="built_in">string</span> S)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        由题意知,最上层节点深度为0(数字前面0条横线),而第二层节点前有1条横线,表示深度为1</span></span><br><span class="line"><span class="comment">        树的前序遍历: 根-左-右</span></span><br><span class="line"><span class="comment">        因此,</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (S.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>;  <span class="comment">// 结果栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,depth=<span class="number">0</span>,val=<span class="number">0</span>;i&lt;S.size();)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(depth=<span class="number">0</span>;i&lt;S.size()&amp;&amp;S[i]==<span class="string">'-'</span>;++i)  <span class="comment">// 计算节点的深度</span></span><br><span class="line">            depth++;</span><br><span class="line">        <span class="keyword">for</span>(val=<span class="number">0</span>;i&lt;S.size()&amp;&amp;S[i]!=<span class="string">'-'</span>;++i)    <span class="comment">// 计算数值</span></span><br><span class="line">            val=val*<span class="number">10</span>+S[i]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">stack</span>.size()&gt;depth)    <span class="comment">// 若当前栈的长度(树的高度)大于节点的深度,则可以把栈中最后几个节点pop掉(这些节点各已经成为完整的子树,可以pop掉了)</span></span><br><span class="line">            <span class="built_in">stack</span>.pop_back();</span><br><span class="line">        TreeNode* node=<span class="keyword">new</span> TreeNode(val);   <span class="comment">// 新建节点用于存放当前深度的结点</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">stack</span>.empty()) <span class="comment">// 节点间关联</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">stack</span>.back()-&gt;left)      <span class="built_in">stack</span>.back()-&gt;left=node;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">stack</span>.back()-&gt;right) <span class="built_in">stack</span>.back()-&gt;right=node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>.push_back(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-1028-从先序遍历还原二叉树/453425-20190503131537591-466226739.png&quot;&gt;
&lt;p&gt;思路:用一个栈来管理树的层次关系,索引代表节点的深度&lt;/p&gt;
&lt;h3 id=&quot;方法一&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="树" scheme="https://brianyi.github.io/tags/%E6%A0%91/"/>
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]5040.边框着色</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-5040-%E8%BE%B9%E6%A1%86%E7%9D%80%E8%89%B2/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-5040-边框着色/</id>
    <published>2019-05-06T11:39:46.000Z</published>
    <updated>2019-05-06T12:02:58.944Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-5040-边框着色/453425-20190430173552247-46622747.png"><h3 id="方法一：dfs的非递归形式"><a href="#方法一：dfs的非递归形式" class="headerlink" title="方法一：dfs的非递归形式"></a>方法一：dfs的非递归形式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ll=<span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> ll MAXN=<span class="number">50L</span>L;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;ll&gt; vis,mark;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; colorBorder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; G, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0, <span class="keyword">int</span> color) &#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;ll&gt; Q;</span><br><span class="line">    Q.push(r0*MAXN+c0);</span><br><span class="line">    <span class="keyword">int</span> c=G[r0][c0];</span><br><span class="line">    <span class="keyword">int</span> dx[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,dy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=Q.front()/MAXN;</span><br><span class="line">        <span class="keyword">int</span> y=Q.front()%MAXN;</span><br><span class="line">        Q.pop();</span><br><span class="line">        vis.insert(x*MAXN+y);</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="number">0</span>||x==G.size()<span class="number">-1</span>||y==<span class="number">0</span>||y==G[<span class="number">0</span>].size()<span class="number">-1</span>)    <span class="comment">// 边界方块可变色</span></span><br><span class="line">            mark.insert(x*MAXN+y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (G[x<span class="number">-1</span>][y]!=c||G[x+<span class="number">1</span>][y]!=c||G[x][y<span class="number">-1</span>]!=c||G[x][y+<span class="number">1</span>]!=c)    <span class="comment">// 四个方向中,任意一个方块颜色不同,则可变色</span></span><br><span class="line">            mark.insert(x*MAXN+y);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d=<span class="number">0</span>;d&lt;<span class="number">4</span>;d++)   <span class="comment">// 放入连通分量的所有方块</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nx=x+dx[d],ny=y+dy[d];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span>&lt;=nx&amp;&amp;nx&lt;G.size()&amp;&amp;<span class="number">0</span>&lt;=ny&amp;&amp;ny&lt;G[<span class="number">0</span>].size()&amp;&amp;!vis.count(nx*MAXN+ny)&amp;&amp;G[nx][ny]==c)</span><br><span class="line">                Q.push(nx*MAXN+ny);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it:mark)</span><br><span class="line">        G[it/MAXN][it%MAXN]=color;</span><br><span class="line">    <span class="keyword">return</span> G;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路:用vis记录访问过的方块,mark标记连通分量中需要修改颜色的方块,并非连通分量中所有的方块都要修改颜色,比如:一个方块如果四周(四个方向邻接的)都是相同颜色,那么只需要修改四周方块的颜色,而自己颜色不变(开始的时候没理解题意,以为只要是连通分量内的方块颜色都需要改变)</p><h3 id="方法二-dfs递归形式-只不过把上面的非递归改为递归了"><a href="#方法二-dfs递归形式-只不过把上面的非递归改为递归了" class="headerlink" title="方法二: dfs递归形式,只不过把上面的非递归改为递归了"></a>方法二: dfs递归形式,只不过把上面的非递归改为递归了</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ll=<span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> ll MAXN=<span class="number">50L</span>L;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;ll&gt; vis,mark;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; G, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dx[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,dy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    vis.insert(x*MAXN+y);</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="number">0</span>||x==G.size()<span class="number">-1</span>||y==<span class="number">0</span>||y==G[<span class="number">0</span>].size()<span class="number">-1</span>)    <span class="comment">// 边界方块可变色</span></span><br><span class="line">        mark.insert(x*MAXN+y);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (G[x<span class="number">-1</span>][y]!=c||G[x+<span class="number">1</span>][y]!=c||G[x][y<span class="number">-1</span>]!=c||G[x][y+<span class="number">1</span>]!=c)    <span class="comment">// 四个方向中,任意一个方块颜色不同,则可变色</span></span><br><span class="line">        mark.insert(x*MAXN+y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d=<span class="number">0</span>;d&lt;<span class="number">4</span>;d++)   <span class="comment">// 放入连通分量的所有方块</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nx=x+dx[d],ny=y+dy[d];</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span>&lt;=nx&amp;&amp;nx&lt;G.size()&amp;&amp;<span class="number">0</span>&lt;=ny&amp;&amp;ny&lt;G[<span class="number">0</span>].size()&amp;&amp;!vis.count(nx*MAXN+ny)&amp;&amp;G[nx][ny]==c)</span><br><span class="line">            dfs(G,nx,ny,c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; colorBorder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; G, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0, <span class="keyword">int</span> color) &#123;</span><br><span class="line">    dfs(G,r0,c0,G[r0][c0]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it:mark)</span><br><span class="line">        G[it/MAXN][it%MAXN]=color;</span><br><span class="line">    <span class="keyword">return</span> G;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三-dfs递归-但通过修改G中的数据-来记录是否访问过-和是否需要修改颜色-国外的一个大佬写的"><a href="#方法三-dfs递归-但通过修改G中的数据-来记录是否访问过-和是否需要修改颜色-国外的一个大佬写的" class="headerlink" title="方法三:dfs递归,但通过修改G中的数据,来记录是否访问过,和是否需要修改颜色,国外的一个大佬写的"></a>方法三:dfs递归,但通过修改G中的数据,来记录是否访问过,和是否需要修改颜色,国外的一个<a href="https://leetcode.com/problems/coloring-a-border/discuss/282847/C%2B%2B-with-picture-DFS" target="_blank" rel="noopener">大佬</a>写的</h3><p>From an initial point, perform DFS and flip the cell color to negative to track visited cells.<br>After DFS is complete for the cell, check if this cell is inside. If so, flip its color back to the positive.<br>In the end, cells with the negative color are on the border. Change their color to the target color.<br><img src="/2019/05/06/leetcode-5040-边框着色/image_1556425139.png"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; g, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> cl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= g.size() || c &gt;= g[r].size() || g[r][c] != cl) <span class="keyword">return</span>;    <span class="comment">// 剪枝(越界,非着色块)</span></span><br><span class="line">    g[r][c] = -cl;    <span class="comment">// 着色</span></span><br><span class="line">    dfs(g, r - <span class="number">1</span>, c, cl), dfs(g, r + <span class="number">1</span>, c, cl), dfs(g, r, c - <span class="number">1</span>, cl), dfs(g, r, c + <span class="number">1</span>, cl);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; <span class="number">0</span> &amp;&amp; r &lt; g.size() - <span class="number">1</span> &amp;&amp; c &gt; <span class="number">0</span> &amp;&amp; c &lt; g[r].size() - <span class="number">1</span> &amp;&amp; cl == <span class="built_in">abs</span>(g[r - <span class="number">1</span>][c]) &amp;&amp;</span><br><span class="line">        cl == <span class="built_in">abs</span>(g[r + <span class="number">1</span>][c]) &amp;&amp; cl == <span class="built_in">abs</span>(g[r][c - <span class="number">1</span>]) &amp;&amp; cl == <span class="built_in">abs</span>(g[r][c + <span class="number">1</span>]))    <span class="comment">// 将原四周同色的块,颜色还原</span></span><br><span class="line">        g[r][c] = cl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; colorBorder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0, <span class="keyword">int</span> color) &#123;</span><br><span class="line">    dfs(grid, r0, c0, grid[r0][c0]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; grid.size(); ++i)    <span class="comment">// 根据dfs标记(负数)过的方块进行着色</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0</span>; j &lt; grid[i].size(); ++j) grid[i][j] = grid[i][j] &lt; <span class="number">0</span> ? color : grid[i][j];</span><br><span class="line">    <span class="keyword">return</span> grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结论: 无论是递归还是非递归,先标记(标记vis),再遍历</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-5040-边框着色/453425-20190430173552247-46622747.png&quot;&gt;
&lt;h3 id=&quot;方法一：dfs的非递归形式&quot;&gt;&lt;a href=&quot;#方法一：dfs的非递归形式&quot; class=&quot;head
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="dfs" scheme="https://brianyi.github.io/tags/dfs/"/>
    
      <category term="图" scheme="https://brianyi.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]5.最长回文子串</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-5-最长回文子串/</id>
    <published>2019-05-06T10:05:20.000Z</published>
    <updated>2019-05-07T03:14:37.772Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-5-最长回文子串/453425-20190505125039549-1852205917.png"><h3 id="方法一-中心扩展算法"><a href="#方法一-中心扩展算法" class="headerlink" title="方法一:中心扩展算法"></a>方法一:中心扩展算法</h3><p>解题思路:从左到右每一个字符都作为中心轴,然后逐渐往两边扩展,只要发现有不相等的字符,则确定了以该字符为轴的最长回文串,但需要考虑长度为奇数和偶数的不同情况的处理(长度为偶数时轴心为中间两个数的中心,长度为奇数时轴心为中间那个数)</p><p>算法时间复杂度: $O(n^{2})$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;        </span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>, maxL = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)　　<span class="comment">// i为轴的位置,j为回文串半径</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; i - j &gt;= <span class="number">0</span> &amp;&amp; i + j &lt; s.size(); ++j)    <span class="comment">// 奇数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i - j] != s[i + j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * j + <span class="number">1</span> &gt; maxL)</span><br><span class="line">            &#123;</span><br><span class="line">                maxL = <span class="number">2</span> * j + <span class="number">1</span>;</span><br><span class="line">                idx = i - j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; i - j &gt;= <span class="number">0</span> &amp;&amp; i + j + <span class="number">1</span> &lt; s.size(); ++j)    <span class="comment">// 偶数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i-j]!=s[i+j+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * j + <span class="number">2</span> &gt; maxL)</span><br><span class="line">            &#123;</span><br><span class="line">                maxL = <span class="number">2</span> * j + <span class="number">2</span>;</span><br><span class="line">                idx = i - j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substr(idx, maxL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="方法二-manacher-马拉车法"><a href="#方法二-manacher-马拉车法" class="headerlink" title="方法二: manacher(马拉车法)"></a>方法二: manacher(马拉车法)</h3><p>解题思路:详见<a href="https://www.luogu.org/problemnew/solution/P3805" target="_blank" rel="noopener">P3805【模板】manacher算法</a><br>为了使奇数串和偶数串一致性处理,首先进行字符填充,使其成为奇数串,即在每个字符的前后填充字符,例如:<br>原串: ABCCBA<br>填充后: ~#A#B#C#C#B#A#<br>原始串在数组中的位置:</p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:left">B</th><th style="text-align:center">C</th><th style="text-align:center">C</th><th style="text-align:center">B</th><th style="text-align:center">A</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:left">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td></tr></tbody></table><p>填充串在数组中的位置</p><table><thead><tr><th style="text-align:center">~</th><th style="text-align:center">#</th><th style="text-align:center">A</th><th style="text-align:center">#</th><th style="text-align:center">B</th><th style="text-align:center">#</th><th style="text-align:center">C</th><th style="text-align:center">#</th><th style="text-align:center">C</th><th style="text-align:center">#</th><th style="text-align:center">B</th><th style="text-align:center">#</th><th style="text-align:center">A</th><th style="text-align:center">#</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">9</td><td style="text-align:center">10</td><td style="text-align:center">11</td><td style="text-align:center">12</td><td style="text-align:center">13</td></tr></tbody></table><p>首先说明: </p><ul><li>奇数+偶数=奇数, 因此,奇数串填充偶数个#后为奇数串,偶数串填充奇数个#后为奇数串</li><li>~字符用来作为边界,用处在于进行两边扩展时做为结束条件</li><li>填充串中字符的最大回文半径 - 1 = 原字符串中该字符的回文串长度</li></ul><p>关于上述第3条我需要解释一下:</p><table><thead><tr><th style="text-align:center">s_copy</th><th style="text-align:center">~</th><th style="text-align:center">#</th><th style="text-align:center">A</th><th style="text-align:center">#</th><th style="text-align:center">B</th><th style="text-align:center">#</th><th style="text-align:center">C</th><th style="text-align:center">#</th><th style="text-align:center">C</th><th style="text-align:center">#</th><th style="text-align:center">B</th><th style="text-align:center">#</th><th style="text-align:center">A</th><th style="text-align:center">#</th></tr></thead><tbody><tr><td style="text-align:center">index</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">9</td><td style="text-align:center">10</td><td style="text-align:center">11</td><td style="text-align:center">12</td><td style="text-align:center">13</td></tr><tr><td style="text-align:center">pos</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">7</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr></tbody></table><p>可以看到index=7的位置,#对应的p为7(即最大回文半径),即在C与C之间,表示原字符串中该字符的回文长度为6,那么原字符串ABCCBA的前面3个字符ABC构成的回文串长度为6</p><blockquote><p>该题思路:</p><ol><li>字符串填充统一为奇数串</li><li>Manacher法,从左到右遍历每个字符<ol><li>记录每个字符的最大回文半径</li><li>确定已经记录的最大回文串右边界r,和中间轴m</li><li>当前字符s[i]是否能关于m找到一个对称点,即要满足:m&lt;=i&lt;=r<ol><li>能:则得到一个有可能的最大回文半径,并从该半径开始扩展</li><li>否:则从新计算最大回文半径</li></ol></li></ol></li></ol></blockquote><p>算法时间复杂度为: $O(n)$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pos[<span class="number">2005</span>],p[<span class="number">2005</span>];  <span class="comment">// pos用于记录填充串与原始字串的位置关系,p用于记录填充串当前字符的最大回文半径</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;        </span><br><span class="line">    <span class="comment">/* 填充字符,统一为奇数串 */</span></span><br><span class="line">    <span class="built_in">string</span> s_new=<span class="string">"~"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,k=<span class="number">1</span>;i&lt;s.size();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        s_new+=<span class="string">"#"</span>;</span><br><span class="line">        s_new+=s[i];</span><br><span class="line">        pos[k++]=i;</span><br><span class="line">        pos[k++]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    s_new+=<span class="string">"#"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* manacher */</span></span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">0</span>,r=<span class="number">0</span>,maxL=<span class="number">0</span>,idx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s_new.size();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取已知的最大回文半径,p[i]用于记录填充串对应字符的最大回文半径</span></span><br><span class="line">        <span class="keyword">if</span> (i&lt;r)</span><br><span class="line">            p[i]=min(p[<span class="number">2</span>*m-i],r-i); <span class="comment">// 当m&lt;=i&lt;=r时,i关于m中心轴对称的点为2*m-i,而p[2*m-i]是一定已经知道的</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p[i]=<span class="number">1</span>; <span class="comment">// 如果i超出了已知的最大回文右边界,则比如不能找到关于m对称的点,只能重新计算最大回文半径</span></span><br><span class="line">        <span class="comment">// 暴力拓展左右两侧,计算当前的最大回文半径</span></span><br><span class="line">        <span class="keyword">while</span> (s_new[i-p[i]]==s_new[i+p[i]])</span><br><span class="line">            p[i]++;</span><br><span class="line">        <span class="comment">// 新的回文半径比较大,则更新</span></span><br><span class="line">        <span class="keyword">if</span> (r-i&lt;p[i])</span><br><span class="line">        &#123;</span><br><span class="line">            m=i;</span><br><span class="line">            r=i+p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新回文长度(原始字串的回文长度为新字串回文半径-1)</span></span><br><span class="line">        <span class="keyword">if</span> (p[i]<span class="number">-1</span>&gt;=maxL)</span><br><span class="line">        &#123;</span><br><span class="line">            maxL=p[i]<span class="number">-1</span>;</span><br><span class="line">            idx=pos[i]-maxL/<span class="number">2</span>;  <span class="comment">// 更新原始回文字串的起始位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substr(idx,maxL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-5-最长回文子串/453425-20190505125039549-1852205917.png&quot;&gt;
&lt;h3 id=&quot;方法一-中心扩展算法&quot;&gt;&lt;a href=&quot;#方法一-中心扩展算法&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="回文串" scheme="https://brianyi.github.io/tags/%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    
  </entry>
  
</feed>
