<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Brian&#39;s Home</title>
  
  <subtitle>Stay Hungry, Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://brianyi.github.io/"/>
  <updated>2019-05-08T10:55:56.340Z</updated>
  <id>https://brianyi.github.io/</id>
  
  <author>
    <name>Brian Yi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[leetcode]312. Burst Balloons</title>
    <link href="https://brianyi.github.io/2019/05/08/leetcode-312-Burst-Balloons/"/>
    <id>https://brianyi.github.io/2019/05/08/leetcode-312-Burst-Balloons/</id>
    <published>2019-05-08T09:01:59.000Z</published>
    <updated>2019-05-08T10:55:56.340Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/08/leetcode-312-Burst-Balloons/2019050817052623.png"><blockquote><p>题目含义: $n$个气球,下标从$0$到$n-1$,对应于数组$nums$.每个气球都有一个编号$nums[i]$,每当你扎破一个气球就可以得到$nums[left]\cdot{nums[i]}\cdot{nums[right]}$的硬币,这里的$left$和$right$是紧挨着气球i的两个气球,当气球$i$被扎破后,气球$left$和$right$就相邻了.请你求出将所有气球扎破后,你能获取的最大的金币数.</p></blockquote><p>注意: 题目要求你假设$nums[-1]=nums[n]=1$,也就是说当你要扎破第一个气球时,得到的硬币是$nums[-1]\cdot{nums[0]}\cdot{nums<a href="/2019/05/07/leetcode-1039-Minimum-Score-Triangulation-of-Polygon/">1</a>}$,扎破最后一个气球时,得到的硬币是$nums[n-2]\cdot{nums[n-1]}\cdot{nums[n]}$的,即假设只有一个气球,且编号为3,那么扎破它得到的硬币数为$nums[-1]\cdot{nums[0]}\cdot{nums<a href="/2019/05/07/leetcode-1039-Minimum-Score-Triangulation-of-Polygon/">1</a>} = 1\cdot{3}\cdot{1} = 3$</p><h3 id="解题思路-DP的思想"><a href="#解题思路-DP的思想" class="headerlink" title="解题思路: DP的思想"></a>解题思路: DP的思想</h3><p>该问题与<a href="/2019/05/07/leetcode-1039-Minimum-Score-Triangulation-of-Polygon/">[leetcode]1039. Minimum Score Triangulation of Polygon</a>相似,DP的思想即将一个大问题,划分为多个小问题来求解,并且大问题和小问题应当存在一种递推(堆叠)的关系.<br>在此问题中,我们将$dp[i][j]$用于表示把气球$i$到气球$j$全部扎破后所得到的最大金币数.假设我们最后扎破的气球为$k$,满足$i\leq{k}\leq{j}$的关系,那么这里就有一个递推关系,如下图所示</p><img src="/2019/05/08/leetcode-312-Burst-Balloons/20190508052601.png"><blockquote><p>如何理解上述的递推关系呢?</p></blockquote><p>我们做下处理将原题的下标0~n-1变成1~n(后面会解释原因),假设现在有n个气球,则:<br>$1$表示左边界,$n$表示右边界,那么两边确定了,通过枚举最后扎破的气球k来解答.<br>假设要扎破气球$1~n$,那么最后扎破的气球可能为$1,…,n-1,n$有如下三种情况</p><ul><li>$k=1$时,即最后扎破的气球为序号最前的气球,那么最大硬币数为$dp[1][n]=0+dp[k+1][n]+1\cdot{nums[k]}\cdot{1}$</li><li>$k=n$时,即最后扎破的气球为序号最后的气球,那么最大硬币数为$dp[1][n]=dp[1][k-1]+0+1\cdot{nums[k]}\cdot{1}$</li><li>$1\le{k}\le{n}$时,即最后扎破的气球为中间的这些气球的一个(不在两端),那么最大硬币数为$dp[1][n]=dp[1][k-1]+dp[k+1][n]+1\cdot{nums[k]}\cdot{1}$</li></ul><p>需要注意的是,从1到n的总硬币数是要从小到大来计算的,即,上述的d[k+1][n],d[1][k-1],d[k+1][n]都是通过之前的计算算出,那么递推公式如下,假设要扎破气球$i~j(1\le{i}\leq{j}\le{n})$,那么最后扎破的气球可能为$i,…,j$有如下三种情况</p><ul><li>$k=i$,即最后扎破的气球为序号最前的气球,那么最大硬币数为$dp[i][j]=0+dp[k+1][j]+nums[i-1]\cdot{nums[k]}\cdot{nums[k]}$</li><li>$k=j$,即最后扎破的气球为序号最后的气球,那么最大硬币数为$dp[i][j]=dp[i][k-1]+0+nums[i-1]\cdot{nums[k]}\cdot{nums[k]}$</li><li>$i\le{k}\le{j}$,即最后扎破的气球为中间的这些气球的一个(不在两端),那么最大硬币数为$dp[i][j]=dp[i][k-1]+dp[k+1][j]+nums[i-1]\cdot{nums[k]}\cdot{nums[k]}$</li></ul><p>将以上两种情况都考虑进去(包含两端和不包含两端的),则即为代码部分的特殊处理,代码用A来代表nums了,将A的首部插入一个1,尾部也插入一个1,而气球真正的数量为n个,气球的标号为A<a href="/2019/05/07/leetcode-1039-Minimum-Score-Triangulation-of-Polygon/">1</a>~A[n],A[0]和A<a href="/2019/05/07/leetcode-1039-Minimum-Score-Triangulation-of-Polygon/">1</a>设置为1,即为题目的条件nums[-1]=nums[n]=1,则计算过程中无论是否是端点的情况,都可以正常计算了,说起来很麻烦,如果文字部分没理解的话可以看看下面的视频讲解</p><p>下面是一位老哥的视频讲解:<br><div class="video-container"><iframe src="//www.youtube.com/embed/IFNibRVgFBo" frameborder="0" allowfullscreen></iframe></div></p><h3 id="实现代码-DP的思想"><a href="#实现代码-DP的思想" class="headerlink" title="实现代码: DP的思想"></a>实现代码: DP的思想</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[<span class="number">600</span>][<span class="number">600</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len=A.size();</span><br><span class="line">    A.insert(A.begin(),<span class="number">1</span>);</span><br><span class="line">    A.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d=<span class="number">0</span>;d&lt;len;++d) <span class="comment">// d为i与j之间的间隔</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i+d&lt;=len;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=i+d;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=i;k&lt;=j;++k)  <span class="comment">// 在i与j之间(包含i,j)枚举k</span></span><br><span class="line">                <span class="comment">// start i, end j, final burst k</span></span><br><span class="line">                dp[i][j] = max(dp[i][j], dp[i][k<span class="number">-1</span>]+A[i<span class="number">-1</span>]*A[k]*A[j+<span class="number">1</span>]+dp[k+<span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>][len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/08/leetcode-312-Burst-Balloons/2019050817052623.png&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;题目含义: $n$个气球,下标从$0$到$n-1$,对应于数组$nums$.每个气球都有一个编号$nu
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="dp" scheme="https://brianyi.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]1039. Minimum Score Triangulation of Polygon</title>
    <link href="https://brianyi.github.io/2019/05/07/leetcode-1039-Minimum-Score-Triangulation-of-Polygon/"/>
    <id>https://brianyi.github.io/2019/05/07/leetcode-1039-Minimum-Score-Triangulation-of-Polygon/</id>
    <published>2019-05-07T12:11:08.000Z</published>
    <updated>2019-05-08T09:10:46.349Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/07/leetcode-1039-Minimum-Score-Triangulation-of-Polygon/20190507422058.png"><p>题目含义: 一个凸多边形由$N$个顶点构成,每个顶点有一个数值,顶点顺时针排列为$A[0],A[1],…,A[N-1]$,假设你将多边形分成$N-2$个三角形,每一个三角形的值为三个顶点值的乘积,多边形的总分数是构成它的$N-2$个三角形的值的总和,求一个$N$多边形的最小总分数.</p><h3 id="解题思路-DP动态规划的思想"><a href="#解题思路-DP动态规划的思想" class="headerlink" title="解题思路: DP动态规划的思想"></a>解题思路: DP动态规划的思想</h3><p>首先,$dp[i][j]$表示顺时针从$i$到$j$构成的多边形的最小分数,于是取一点$k$,满足$i&lt;k&lt;j$,再取$d$表示$i$到$j$的距离,进行枚举,在一个大的多边形中,$d=2$先把周边一圈小三角形枚举一边,$d=3$再把周边一圈的四边形枚举一遍(由$d=2$时求出了小三角形的分数计算得出四边形的最小分数),…,$d=N-1$再把$N$边形枚举一边,如下图所示:</p><img src="/2019/05/07/leetcode-1039-Minimum-Score-Triangulation-of-Polygon/20190508122646.jpg"><p>核心公式为: </p><p>$$<br>dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j]+A[i]\cdot{A[k]}\cdot{A[j]})<br>$$</p><h3 id="代码实现-DP思想"><a href="#代码实现-DP思想" class="headerlink" title="代码实现: DP思想"></a>代码实现: DP思想</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minScoreTriangulation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=A.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d=<span class="number">2</span>;d&lt;len;++d) <span class="comment">// d作为i与j之间的间距</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i+d&lt;len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=i+d;</span><br><span class="line">            dp[i][j]=INT_MAX;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;j;++k)</span><br><span class="line">                dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]+A[i]*A[k]*A[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][len<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/07/leetcode-1039-Minimum-Score-Triangulation-of-Polygon/20190507422058.png&quot;&gt;
&lt;p&gt;题目含义: 一个凸多边形由$N$个顶点构成,每个顶点有一个数值,顶点顺时针排列为$
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="dp" scheme="https://brianyi.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>[algorithm]线性表</title>
    <link href="https://brianyi.github.io/2019/05/07/algorithm-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>https://brianyi.github.io/2019/05/07/algorithm-线性表/</id>
    <published>2019-05-07T10:35:10.000Z</published>
    <updated>2019-05-07T11:08:01.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-线性表基础算法"><a href="#一-线性表基础算法" class="headerlink" title="一. 线性表基础算法"></a>一. 线性表基础算法</h2><h3 id="1-线性表插入操作"><a href="#1-线性表插入操作" class="headerlink" title="1.线性表插入操作"></a>1.线性表插入操作</h3><p>线性表插入操作(在第$i(1≤i≤L.length+1)$个位置上插入新元素$elem$)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertSeq</span><span class="params">( SeqList&amp; L, <span class="keyword">int</span> i, ElemType elem )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( i &lt; <span class="number">1</span> || i&gt;L.length + <span class="number">1</span> || L.length &gt;= MAXSIZE )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> ( j = L.length - <span class="number">1</span>; j &gt;= i - <span class="number">1</span>; j-- )</span><br><span class="line">        L.elem[j + <span class="number">1</span>] = L.elem[j];</span><br><span class="line">    L.elem[j + <span class="number">1</span>] = elem;</span><br><span class="line">    L.length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明:</p><ul><li>插入操作: 可选位置为$1≤i≤L.length+1$</li><li>最好情况: 表尾$(i=n+1)$插入, $O(1)$</li><li>最坏情况: 表头$(i=1)$插入, $O(n)$</li><li>平均情况: 设 $P_i=\frac{1}{(n+1)}$ 是在第$i$个位置插入一个结点的概率,则在长度为$n$的线性表中插入一个结点所需的移动结点的平均次数为$\frac {n}{2}$次,即$O(n)$:</li></ul><p>$$<br>\sum_{i=1}^{n+1}{P_i}⋅(n+1−i)=\frac{1}{n+1}\cdot\sum_{i=1}^{n+1}(n−i+1)=\frac{1}{n+1}\cdot\frac{n(n+1)}{2}=\frac{n}{2}<br>$$</p><h3 id="2-线性表删除操作"><a href="#2-线性表删除操作" class="headerlink" title="2.线性表删除操作"></a>2.线性表删除操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteSeq</span><span class="params">( SeqList&amp; L, <span class="keyword">int</span> i, ElemType&amp; elem )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( i&lt;<span class="number">1</span> || i&gt;L.length ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    elem = L.elem[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> ( j = i; j &lt; L.length; j++ )</span><br><span class="line">        L.elem[j - <span class="number">1</span>] = L.elem[j];</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明:</p><ul><li>最好情况: 删除表位$(i=n)$,$O(1)$</li><li>最坏情况: 删除表头$(i=1)$,$O(n)$</li><li>平均情况: 设$P_i=\frac{1}{n}$是删除第$i$个位置上结点的概率,则在长度为$n$的线性表中删除一个结点所需移动结点的平均次数为$\frac{n−1}{2}$次,即$O(n)$:</li></ul><p>$$<br>\sum_{i=1}^{n}{Pi}\cdot{(n−i)}=\frac{1}{n}\sum_{i=1}^{n}n(n−i)=\frac{1}{n}\cdot\frac{n(n−1)}{2}=\frac{n−1}{2}<br>$$</p><h3 id="3-线性表查找操作"><a href="#3-线性表查找操作" class="headerlink" title="3.线性表查找操作"></a>3.线性表查找操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateSeq</span><span class="params">( SeqList&amp; L, ElemType elem )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; L.length; i++ )</span><br><span class="line">        <span class="keyword">if</span> ( L.elem[i].key == elem.key )</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明:</p><ul><li>最好情况: 查找到表头,$O(1)$</li><li>最坏情况: 查找到表尾,$O(n)$</li><li>平均情况: 设$P_i=\frac{1}{n}$是查找元素在第$i(1≤i≤L.length)$个位置上的概率,则在长度为$n$的线性表中查找值为$elem$的元素所需比较的平均次数为$\frac{n+1}{2}$次,$O(n)$:</li></ul><p>$$<br>\sum_{i=1}^{n}P_i\cdot{i}=\frac{1}{n}\cdot\sum_{i=1}^{n}i=\frac{1}{n}\cdot\frac{n(n+1)}{2}=\frac{n+1}{2}<br>$$</p><h2 id="二-线性表综合应用"><a href="#二-线性表综合应用" class="headerlink" title="二.线性表综合应用"></a>二.线性表综合应用</h2><h3 id="1-删除线性表中所有值为-x-的数据元素"><a href="#1-删除线性表中所有值为-x-的数据元素" class="headerlink" title="1.删除线性表中所有值为$x$的数据元素"></a>1.删除线性表中所有值为$x$的数据元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteX</span><span class="params">( SeqList&amp; L, ElemType x )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt;= L.length; i++ )</span><br><span class="line">        <span class="keyword">if</span> ( L.elem[i].key != x.key )</span><br><span class="line">            L.elem[k++] = L.elem[i];</span><br><span class="line">    L.length = k;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-从有序顺序表中删除值在-s-t-的所有元素"><a href="#2-从有序顺序表中删除值在-s-t-的所有元素" class="headerlink" title="2.从有序顺序表中删除值在$[s,t]$的所有元素"></a>2.从有序顺序表中删除值在$[s,t]$的所有元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteS2TOrderedSeq</span><span class="params">( SeqList&amp; L, <span class="keyword">int</span> s, <span class="keyword">int</span> t )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt;= L.length&amp;&amp;L.elem[i].key &lt; s; i++ );    <span class="comment">// 找≥s的第一个元素</span></span><br><span class="line">    <span class="keyword">for</span> ( j = i; j &lt;= L.length&amp;&amp;L.elem[j].key &lt;= t; j++ );    <span class="comment">// 找&gt;t的第一个元素</span></span><br><span class="line">    <span class="keyword">while</span> ( j &lt;= L.length )</span><br><span class="line">        L.elem[i++] = L.elem[j++];</span><br><span class="line">    L.length = i;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-从顺序表中删除值在-s-t-的所有元素"><a href="#3-从顺序表中删除值在-s-t-的所有元素" class="headerlink" title="3.从顺序表中删除值在$[s,t]$的所有元素"></a>3.从顺序表中删除值在$[s,t]$的所有元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteS2TSeq</span><span class="params">( SeqList&amp; L, <span class="keyword">int</span> s, <span class="keyword">int</span> t )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt;= L.length; i++ )</span><br><span class="line">        <span class="keyword">if</span> ( L.elem[i].key&lt;s || L.elem[i].key&gt;t )</span><br><span class="line">            L.elem[k++] = L.elem[i];</span><br><span class="line">    L.length = k;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-从有序顺序表中删除所有值重复的元素"><a href="#4-从有序顺序表中删除所有值重复的元素" class="headerlink" title="4.从有序顺序表中删除所有值重复的元素"></a>4.从有序顺序表中删除所有值重复的元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteSameOrderedSeq</span><span class="params">( SeqList&amp; L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">2</span>; i &lt;= L.length; i++ )</span><br><span class="line">        <span class="keyword">if</span> ( L.elem[i].key != L.elem[k].key )</span><br><span class="line">            L.elem[++k] = L.elem[i];</span><br><span class="line">    L.length = k;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-将两个有序顺序表合并为一个新的有序顺序表"><a href="#5-将两个有序顺序表合并为一个新的有序顺序表" class="headerlink" title="5.将两个有序顺序表合并为一个新的有序顺序表"></a>5.将两个有序顺序表合并为一个新的有序顺序表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Merge</span><span class="params">( SeqList A, SeqList B, SeqList&amp; C )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>, k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ( i&lt;=A.length&amp;&amp;j&lt;=B.length )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( A.elem[i].key &lt;= B.elem[j].key )</span><br><span class="line">            C.elem[k++] = A.elem[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            C.elem[k++] = B.elem[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( i &lt;= A.length ) C.elem[k++] = A.elem[i++];</span><br><span class="line">    <span class="keyword">while</span> ( j &lt;= B.length ) C.elem[k++] = B.elem[j++];</span><br><span class="line">    C.length = k - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-原数组-A-m-n-a-1-a-2-…-a-m-b-1-b-2-…-b-n-现要求转变为-A-m-n-b-1-b-2-…-b-n-a-1-a-2-…-a-m"><a href="#6-原数组-A-m-n-a-1-a-2-…-a-m-b-1-b-2-…-b-n-现要求转变为-A-m-n-b-1-b-2-…-b-n-a-1-a-2-…-a-m" class="headerlink" title="6.原数组$A[m+n]={a_1,a_2,…,a_m,b_1,b_2,…,b_n}$,现要求转变为$A[m+n]={b_1,b_2,…,b_n,a_1,a_2,…,a_m}$"></a>6.原数组$A[m+n]={a_1,a_2,…,a_m,b_1,b_2,…,b_n}$,现要求转变为$A[m+n]={b_1,b_2,…,b_n,a_1,a_2,…,a_m}$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元素倒置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">( ElemType A[], <span class="keyword">int</span> s, <span class="keyword">int</span> e )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = s; i &lt; ( s + e ) / <span class="number">2</span>; i++ )</span><br><span class="line">        swap( A[i], A[s + e - i - <span class="number">1</span>] );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExChange</span><span class="params">( ElemType A[], <span class="keyword">int</span> m, <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Reverse( A, <span class="number">0</span>, m );</span><br><span class="line">    Reverse( A, m, m + n );</span><br><span class="line">    Reverse( A, <span class="number">0</span>, m + n );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-线性表-a-1-a-2-…-a-n-递增有序-设计算法花最少时间找到数值为-x-的元素"><a href="#7-线性表-a-1-a-2-…-a-n-递增有序-设计算法花最少时间找到数值为-x-的元素" class="headerlink" title="7.线性表$(a_1,a_2,…,a_n)$递增有序,设计算法花最少时间找到数值为$x$的元素:"></a>7.线性表$(a_1,a_2,…,a_n)$递增有序,设计算法花最少时间找到数值为$x$的元素:</h3><blockquote><p>1)找到,则与其后继元素位置互换<br>2)未找到,将其插入表中并使表中元素仍然递增有序</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用折半查找的方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SearchExchangeInsert</span><span class="params">( ElemType A[], <span class="keyword">int</span> n, ElemType x )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">1</span>, high = n;</span><br><span class="line">    <span class="keyword">while</span> ( low &lt;= high )</span><br><span class="line">    &#123;</span><br><span class="line">        mid = ( low + high ) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ( x.key == A[mid].key )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( mid != n )</span><br><span class="line">                swap( A[mid], A[mid + <span class="number">1</span>] );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( x.key &lt; A[mid].key ) high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( j = n; j &gt;= high + <span class="number">1</span>; j-- )</span><br><span class="line">        A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">    A[j + <span class="number">1</span>] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-设计算法将一维数组-R-中的序列循环左移-p-0-lt-p-lt-n-个位置-算法思想和6-相同"><a href="#8-设计算法将一维数组-R-中的序列循环左移-p-0-lt-p-lt-n-个位置-算法思想和6-相同" class="headerlink" title="8.设计算法将一维数组$R$中的序列循环左移$p(0&lt;p&lt;n)$个位置(算法思想和6.相同)"></a>8.设计算法将一维数组$R$中的序列循环左移$p(0&lt;p&lt;n)$个位置(算法思想和6.相同)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元素倒置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">( ElemType A[], <span class="keyword">int</span> s, <span class="keyword">int</span> e )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = s; i &lt; ( s + e ) / <span class="number">2</span>; i++ )</span><br><span class="line">        swap( A[i], A[s + e - i - <span class="number">1</span>] );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShiftLeft</span><span class="params">( ElemType R[], <span class="keyword">int</span> n, <span class="keyword">int</span> p )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Reverse( R, <span class="number">0</span>, p );</span><br><span class="line">    Reverse( R, p, n );</span><br><span class="line">    Reverse( R, <span class="number">0</span>, n );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-长度为-L-L≥1-的升序序列-S-处在-⌈L2⌉-个位置的数成为-S-的中位数-设计一个在时空都尽量高效的算法找出两个等长序列-A-和-B-的中位数"><a href="#9-长度为-L-L≥1-的升序序列-S-处在-⌈L2⌉-个位置的数成为-S-的中位数-设计一个在时空都尽量高效的算法找出两个等长序列-A-和-B-的中位数" class="headerlink" title="9.长度为$L(L≥1)$的升序序列$S$,处在$⌈L2⌉$个位置的数成为$S$的中位数,设计一个在时空都尽量高效的算法找出两个等长序列$A$和$B$的中位数"></a>9.长度为$L(L≥1)$的升序序列$S$,处在$⌈L2⌉$个位置的数成为$S$的中位数,设计一个在时空都尽量高效的算法找出两个等长序列$A$和$B$的中位数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindMidFromABOrderedSeq</span><span class="params">( <span class="keyword">int</span> A[], <span class="keyword">int</span> B[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s1, s2, e1, e2, m1, m2;</span><br><span class="line">    s1 = s2 = <span class="number">0</span>;</span><br><span class="line">    e1 = e2 = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ( s1 != e1 || s2 != e2 )</span><br><span class="line">    &#123;</span><br><span class="line">        m1 = ( s1 + e1 ) / <span class="number">2</span>;</span><br><span class="line">        m2 = ( s2 + e2 ) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ( A[m1] == B[m2] )</span><br><span class="line">            <span class="keyword">return</span> A[m1];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( A[m1] &lt; B[m2] )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !( ( s1 + e1 ) % <span class="number">2</span> ) )</span><br><span class="line">                s1 = m1, e2 = m2;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s1 = m1 + <span class="number">1</span>, e2 = m2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !( ( s2 + e2 ) % <span class="number">2</span> ) )</span><br><span class="line">                s2 = m2, e1 = m1;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s2 = m2 + <span class="number">1</span>, e1 = m1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A[s1] &lt; B[s2] ? A[s1] : B[s2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-线性表的链式表示"><a href="#三-线性表的链式表示" class="headerlink" title="三.线性表的链式表示"></a>三.线性表的链式表示</h2><h3 id="1-采用头插法建立单链表"><a href="#1-采用头插法建立单链表" class="headerlink" title="1.采用头插法建立单链表"></a>1.采用头插法建立单链表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">CreateList</span><span class="params">( LinkList&amp; L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L = ( LinkList ) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span>( LNode ) );</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>( <span class="string">"%d"</span>, &amp;x );</span><br><span class="line">    <span class="keyword">while</span> ( x != <span class="number">9999</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        s = ( LNode* ) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span>( LNode ) );</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = s;</span><br><span class="line">        <span class="built_in">scanf</span>( <span class="string">"%d"</span>, &amp;x );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-采用尾插法建立单链表"><a href="#2-采用尾插法建立单链表" class="headerlink" title="2.采用尾插法建立单链表"></a>2.采用尾插法建立单链表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">CreateList</span><span class="params">( LinkList&amp; L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L = ( LinkList ) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span>( LNode ) );</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    r = L;</span><br><span class="line">    <span class="built_in">scanf</span>( <span class="string">"%d"</span>, &amp;x );</span><br><span class="line">    <span class="keyword">while</span> ( x != <span class="number">9999</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        s = ( LNode* ) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span>( LNode ) );</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next=s;</span><br><span class="line">        r = s;</span><br><span class="line">        <span class="built_in">scanf</span>( <span class="string">"%d"</span>, &amp;x );</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-线性表相关综合算法"><a href="#四-线性表相关综合算法" class="headerlink" title="四.线性表相关综合算法"></a>四.线性表相关综合算法</h2><h3 id="1-递归删除不带头结点的单列表-L-中所有值为-x-的结点"><a href="#1-递归删除不带头结点的单列表-L-中所有值为-x-的结点" class="headerlink" title="1.递归删除不带头结点的单列表$L$中所有值为$x$的结点"></a>1.递归删除不带头结点的单列表$L$中所有值为$x$的结点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteX</span><span class="params">( LinkList&amp; L, ElemType x )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !L ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> ( L-&gt;data == x )</span><br><span class="line">    &#123;</span><br><span class="line">        q = L;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>( q );</span><br><span class="line">        DeleteX( L, x );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        DeleteX( L-&gt;next, x );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-删除带头结点的单链表-L-中所有值为-x-的结点"><a href="#2-删除带头结点的单链表-L-中所有值为-x-的结点" class="headerlink" title="2.删除带头结点的单链表$L$中所有值为$x$的结点"></a>2.删除带头结点的单链表$L$中所有值为$x$的结点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteX</span><span class="params">( LinkList&amp; L, ElemType x )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pre = L;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> ( p )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( p-&gt;data == x )</span><br><span class="line">        &#123;</span><br><span class="line">            q = p;</span><br><span class="line">            pre-&gt;next = p-&gt;next;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>( q );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre = p; p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-反向输出带头结点的单链表-L-的每个结点的值"><a href="#3-反向输出带头结点的单链表-L-的每个结点的值" class="headerlink" title="3.反向输出带头结点的单链表$L$的每个结点的值"></a>3.反向输出带头结点的单链表$L$的每个结点的值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintX</span><span class="params">( LinkList L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !L )<span class="keyword">return</span>;</span><br><span class="line">    PrintX( L-&gt;next );</span><br><span class="line">    visit( L );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-删除带头结点单链表-L-中最小值结点"><a href="#4-删除带头结点单链表-L-中最小值结点" class="headerlink" title="4.删除带头结点单链表$L$中最小值结点"></a>4.删除带头结点单链表$L$中最小值结点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">DeleteMin</span><span class="params">( LinkList&amp; L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p, s, pre, q;</span><br><span class="line">    p = s = L-&gt;next;</span><br><span class="line">    pre = q = L;</span><br><span class="line">    <span class="keyword">while</span> ( p )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data&lt;s-&gt;data )</span><br><span class="line">        &#123;</span><br><span class="line">            s = p; q = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;next = s-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>( s );</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-将带头结点的单链表就地逆置-”就地”指辅助空间复杂度为-O-1"><a href="#5-将带头结点的单链表就地逆置-”就地”指辅助空间复杂度为-O-1" class="headerlink" title="5.将带头结点的单链表就地逆置,”就地”指辅助空间复杂度为$O(1)$"></a>5.将带头结点的单链表就地逆置,”就地”指辅助空间复杂度为$O(1)$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Reverse</span><span class="params">( LinkList L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p, q;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> ( p )</span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-将带头结点的单链表-L-排序-使其递增有序"><a href="#6-将带头结点的单链表-L-排序-使其递增有序" class="headerlink" title="6.将带头结点的单链表$L$排序,使其递增有序"></a>6.将带头结点的单链表$L$排序,使其递增有序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">( LinkList&amp; L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p, pre, r;</span><br><span class="line">    p = L-&gt;next; r = p-&gt;next;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>; p = r;</span><br><span class="line">    <span class="keyword">while</span> ( p )</span><br><span class="line">    &#123;</span><br><span class="line">        r = p-&gt;next;</span><br><span class="line">        pre = L;</span><br><span class="line">        <span class="keyword">while</span> ( pre-&gt;next&amp;&amp;pre-&gt;next-&gt;data &lt; p-&gt;data )</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        p-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = p;</span><br><span class="line">        p = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-在带头结点的单链表中-删除值介于-s-t-之间的元素"><a href="#7-在带头结点的单链表中-删除值介于-s-t-之间的元素" class="headerlink" title="7.在带头结点的单链表中,删除值介于$(s,t)$之间的元素"></a>7.在带头结点的单链表中,删除值介于$(s,t)$之间的元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteS2T</span><span class="params">( LinkList&amp; L, <span class="keyword">int</span> s, <span class="keyword">int</span> t )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList pre, p;</span><br><span class="line">    pre = L; p = pre-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> ( p )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( p-&gt;data &gt; s &amp;&amp; p-&gt;data &lt; t )</span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;next = p-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>( p );</span><br><span class="line">            p = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-找出两个单链表的公共结点"><a href="#8-找出两个单链表的公共结点" class="headerlink" title="8.找出两个单链表的公共结点"></a>8.找出两个单链表的公共结点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">SearchCommon</span><span class="params">( LinkList L1, LinkList L2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList pA, pB;</span><br><span class="line">    <span class="keyword">int</span> lenA, lenB, dist;</span><br><span class="line">    pA = L1-&gt;next, pB = L2-&gt;next;</span><br><span class="line">    lenA = lenB = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( pA ) &#123; pA = pA-&gt;next; lenA++; &#125;</span><br><span class="line">    <span class="keyword">while</span> ( pB ) &#123; pB = pB-&gt;next; lenB++; &#125;</span><br><span class="line">    pA = L1-&gt;next, pB = L2-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> ( lenA &gt; lenB )</span><br><span class="line">    &#123;</span><br><span class="line">        dist = lenA - lenB;</span><br><span class="line">        <span class="keyword">while</span> ( dist-- ) pA = pA-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        dist = lenB - lenA;</span><br><span class="line">        <span class="keyword">while</span> ( dist-- ) pB = pB-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( pA )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( pA == pB ) <span class="keyword">return</span> pA;</span><br><span class="line">        pA = pA-&gt;next, pB = pB-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-带表头结点的单链表-按递增次序输出单链表中各结点的数据元素-并释放空间"><a href="#9-带表头结点的单链表-按递增次序输出单链表中各结点的数据元素-并释放空间" class="headerlink" title="9.带表头结点的单链表,按递增次序输出单链表中各结点的数据元素,并释放空间"></a>9.带表头结点的单链表,按递增次序输出单链表中各结点的数据元素,并释放空间</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AscDelete</span><span class="params">( LinkList&amp; L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p, s, pre, r;</span><br><span class="line">    <span class="keyword">while</span> ( L-&gt;next )</span><br><span class="line">    &#123;</span><br><span class="line">        s = p = L-&gt;next; r = pre = L;</span><br><span class="line">        <span class="keyword">while</span> ( p )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( p-&gt;data &lt; s-&gt;data )</span><br><span class="line">            &#123;</span><br><span class="line">                s = p; r = pre;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        r-&gt;next = s-&gt;next;</span><br><span class="line">        visit( s );</span><br><span class="line">        <span class="built_in">free</span>( s );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>( L );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-将带头结点的单链表-A-分解成两个带头结点的单链表-A-和-B-A-中含有奇数序号元素-B-中含有偶数序号元素且相对位置不变"><a href="#10-将带头结点的单链表-A-分解成两个带头结点的单链表-A-和-B-A-中含有奇数序号元素-B-中含有偶数序号元素且相对位置不变" class="headerlink" title="10.将带头结点的单链表$A$分解成两个带头结点的单链表$A$和$B$,$A$中含有奇数序号元素,$B$中含有偶数序号元素且相对位置不变"></a>10.将带头结点的单链表$A$分解成两个带头结点的单链表$A$和$B$,$A$中含有奇数序号元素,$B$中含有偶数序号元素且相对位置不变</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 法一</span></span><br><span class="line"><span class="function">LinkList <span class="title">Split</span><span class="params">( LinkList&amp; A )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p, B, rA, rB;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    p = A-&gt;next;</span><br><span class="line">    B = ( LinkList ) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span>( LNode ) );</span><br><span class="line">    rA = A; A-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    rB = B; B-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> ( p )</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (i%<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rA-&gt;next = p; rA = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            rB-&gt;next = p; rB = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    rA-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    rB-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 法二</span></span><br><span class="line"><span class="function">LinkList <span class="title">Split</span><span class="params">( LinkList&amp; A )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p, B, rB, pre;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    B = ( LinkList ) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span>( LNode ) );</span><br><span class="line">    rB = B;</span><br><span class="line">    pre = A; p = pre-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> ( p )</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> ( i % <span class="number">2</span> == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;next = p-&gt;next;</span><br><span class="line">            rB-&gt;next = p;</span><br><span class="line">            rB = p;</span><br><span class="line">            p = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-C-a-1-b-1-a-2-b-2-…-a-n-b-n-为线性表-带有头结点-设计一个就地算法将其拆分为两个线性表-使-A-a-1-a-2-…-a-n-B-b-n-…-b-2-b-1"><a href="#11-C-a-1-b-1-a-2-b-2-…-a-n-b-n-为线性表-带有头结点-设计一个就地算法将其拆分为两个线性表-使-A-a-1-a-2-…-a-n-B-b-n-…-b-2-b-1" class="headerlink" title="11.$C={a_1,b_1,a_2,b_2,…,a_n,b_n}$为线性表,带有头结点,设计一个就地算法将其拆分为两个线性表,使$A={a_1,a_2,…,a_n}$,$B={b_n,…,b_2,b_1}$"></a>11.$C={a_1,b_1,a_2,b_2,…,a_n,b_n}$为线性表,带有头结点,设计一个就地算法将其拆分为两个线性表,使$A={a_1,a_2,…,a_n}$,$B={b_n,…,b_2,b_1}$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Split</span><span class="params">( LinkList&amp; A )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList B, pre, p;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    B = ( LinkList ) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span>( LNode ) );</span><br><span class="line">    pre = A; p = pre-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> ( p )</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> ( i % <span class="number">2</span> == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = B-&gt;next;</span><br><span class="line">            B-&gt;next = p;</span><br><span class="line">            p = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-在递增有序的带头结点的单链表中-数值相同的只保留一个-使表中不再有重复的元素"><a href="#12-在递增有序的带头结点的单链表中-数值相同的只保留一个-使表中不再有重复的元素" class="headerlink" title="12.在递增有序的带头结点的单链表中,数值相同的只保留一个,使表中不再有重复的元素"></a>12.在递增有序的带头结点的单链表中,数值相同的只保留一个,使表中不再有重复的元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteSame</span><span class="params">( LinkList&amp; L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p, q;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> ( p )</span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> ( q&amp;&amp;q-&gt;data == p-&gt;data )</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = q-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>( q );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-将两个按元素值递增的单链表合并为一个按元素值递减的单链表"><a href="#13-将两个按元素值递增的单链表合并为一个按元素值递减的单链表" class="headerlink" title="13.将两个按元素值递增的单链表合并为一个按元素值递减的单链表"></a>13.将两个按元素值递增的单链表合并为一个按元素值递减的单链表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList</span><span class="params">( LinkList&amp; LA, LinkList&amp; LB )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList pA, pB, q;</span><br><span class="line">    pA = LA-&gt;next; pB = LB-&gt;next;</span><br><span class="line">    LA-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> ( pA&amp;&amp;pB )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( pA-&gt;data &lt;= pB-&gt;data )</span><br><span class="line">        &#123;</span><br><span class="line">            q = pA-&gt;next;</span><br><span class="line">            pA-&gt;next = LA-&gt;next;</span><br><span class="line">            LA-&gt;next = pA;</span><br><span class="line">            pA = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            q = pB-&gt;next;</span><br><span class="line">            pB-&gt;next = LA-&gt;next;</span><br><span class="line">            LA-&gt;next = pB;</span><br><span class="line">            pB = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( pA )</span><br><span class="line">        pB = pA;</span><br><span class="line">    <span class="keyword">while</span>(pB )</span><br><span class="line">    &#123;</span><br><span class="line">        q = pB-&gt;next;</span><br><span class="line">        pB-&gt;next = LA-&gt;next;</span><br><span class="line">        LA-&gt;next = pB;</span><br><span class="line">        pB = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>( LB );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-A-B-为两个元素递增有序的单链表-带头结点-设计算法从-A-B-中公共元素产生单链表-C-要求"><a href="#14-A-B-为两个元素递增有序的单链表-带头结点-设计算法从-A-B-中公共元素产生单链表-C-要求" class="headerlink" title="14.$A,B$为两个元素递增有序的单链表(带头结点),设计算法从$A,B$中公共元素产生单链表$C$,要求"></a>14.$A,B$为两个元素递增有序的单链表(带头结点),设计算法从$A,B$中公共元素产生单链表$C$,要求</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList</span><span class="params">( LinkList&amp; LA, LinkList&amp; LB )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList pA, pB, q;</span><br><span class="line">    pA = LA-&gt;next; pB = LB-&gt;next;</span><br><span class="line">    LA-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> ( pA&amp;&amp;pB )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( pA-&gt;data &lt;= pB-&gt;data )</span><br><span class="line">        &#123;</span><br><span class="line">            q = pA-&gt;next;</span><br><span class="line">            pA-&gt;next = LA-&gt;next;</span><br><span class="line">            LA-&gt;next = pA;</span><br><span class="line">            pA = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            q = pB-&gt;next;</span><br><span class="line">            pB-&gt;next = LA-&gt;next;</span><br><span class="line">            LA-&gt;next = pB;</span><br><span class="line">            pB = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( pA )</span><br><span class="line">        pB = pA;</span><br><span class="line">    <span class="keyword">while</span> ( pB )</span><br><span class="line">    &#123;</span><br><span class="line">        q = pB-&gt;next;</span><br><span class="line">        pB-&gt;next = LA-&gt;next;</span><br><span class="line">        LA-&gt;next = pB;</span><br><span class="line">        pB = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>( LB );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-求两个元素递增排列的链表-带头结点-A-和-B-的交集并存放于-A-链表中-并释放其他结点"><a href="#15-求两个元素递增排列的链表-带头结点-A-和-B-的交集并存放于-A-链表中-并释放其他结点" class="headerlink" title="15.求两个元素递增排列的链表(带头结点)$A$和$B$的交集并存放于$A$链表中,并释放其他结点"></a>15.求两个元素递增排列的链表(带头结点)$A$和$B$的交集并存放于$A$链表中,并释放其他结点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Intersect</span><span class="params">( LinkList&amp; LA, LinkList&amp; LB )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList pA, pB, r, q;</span><br><span class="line">    pA = LA-&gt;next; pB = LB-&gt;next;</span><br><span class="line">    r = LA; LA-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> ( pA&amp;&amp;pB )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( pA-&gt;data == pB-&gt;data )</span><br><span class="line">        &#123;</span><br><span class="line">            r-&gt;next = pA;</span><br><span class="line">            r = pA;</span><br><span class="line">            pA = pA-&gt;next;</span><br><span class="line">            q = pB;</span><br><span class="line">            pB = pB-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>( q );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( pA-&gt;data &lt; pB-&gt;data )</span><br><span class="line">        &#123;</span><br><span class="line">            q = pA;</span><br><span class="line">            pA = pA-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>( q );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            q = pB;</span><br><span class="line">            pB = pB-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>( q );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> ( pA )</span><br><span class="line">    &#123;</span><br><span class="line">        q = pA;</span><br><span class="line">        pA = pA-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>( q );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( pB )</span><br><span class="line">    &#123;</span><br><span class="line">        q = pB;</span><br><span class="line">        pB = pB-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>( q );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>( LB );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-判断单链表序列-B-是否是-A-的连续子序列-不带头结点"><a href="#16-判断单链表序列-B-是否是-A-的连续子序列-不带头结点" class="headerlink" title="16.判断单链表序列$B$是否是$A$的连续子序列(不带头结点)"></a>16.判断单链表序列$B$是否是$A$的连续子序列(不带头结点)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsSubsequence</span><span class="params">( LinkList A, LinkList B )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList pA, pB, h;</span><br><span class="line">    pA = A; pB = B;</span><br><span class="line">    h = pA;</span><br><span class="line">    <span class="keyword">while</span> ( pA&amp;&amp;pB )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( pA-&gt;data == pB-&gt;data )</span><br><span class="line">        &#123;</span><br><span class="line">            pA = pA-&gt;next;</span><br><span class="line">            pB = pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            h = h-&gt;next;</span><br><span class="line">            pA = h;</span><br><span class="line">            pB = B;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( pB ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-判断带头结点的循环双链表是否对称"><a href="#17-判断带头结点的循环双链表是否对称" class="headerlink" title="17.判断带头结点的循环双链表是否对称"></a>17.判断带头结点的循环双链表是否对称</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsSymmetry</span><span class="params">( DLinkList L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DLinkList p, q;</span><br><span class="line">    p = L-&gt;next; q = L-&gt;prior;</span><br><span class="line">    <span class="keyword">while</span> ( p != q &amp;&amp; q-&gt;next != p )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( p-&gt;data != q-&gt;data )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-将循环单链表-h2-链接到-h1-之后"><a href="#18-将循环单链表-h2-链接到-h1-之后" class="headerlink" title="18.将循环单链表$h2$链接到$h1$之后"></a>18.将循环单链表$h2$链接到$h1$之后</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Link</span><span class="params">( LinkList&amp; h1, LinkList&amp; h2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    p = h1;</span><br><span class="line">    <span class="keyword">while</span> ( p-&gt;next != h1 )p = p-&gt;next;</span><br><span class="line">    p-&gt;next = h2;</span><br><span class="line">    p = h2;</span><br><span class="line">    <span class="keyword">while</span> ( p-&gt;next != h2 )p = p-&gt;next;</span><br><span class="line">    p-&gt;next = h1;</span><br><span class="line">    <span class="keyword">return</span> h1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19-带头结点的循环链表-按递增次序输出循环链表中各结点的数据元素-并释放空间"><a href="#19-带头结点的循环链表-按递增次序输出循环链表中各结点的数据元素-并释放空间" class="headerlink" title="19.带头结点的循环链表,按递增次序输出循环链表中各结点的数据元素,并释放空间"></a>19.带头结点的循环链表,按递增次序输出循环链表中各结点的数据元素,并释放空间</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AscDelete</span><span class="params">( LinkList&amp; L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p, s, r, pre;</span><br><span class="line">    <span class="keyword">while</span> ( L-&gt;next != L )</span><br><span class="line">    &#123;</span><br><span class="line">        s = p = L-&gt;next; r = pre = L;</span><br><span class="line">        <span class="keyword">while</span> ( p != L )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( p-&gt;data &lt; s-&gt;data )</span><br><span class="line">            &#123;</span><br><span class="line">                s = p; r = pre;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        visit( s );</span><br><span class="line">        r-&gt;next = s-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>( s );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>( L );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20-查找单链表-带头结点-中倒数第-k-个位置的结点-成功-则输出并返回-true-否则只返回-false"><a href="#20-查找单链表-带头结点-中倒数第-k-个位置的结点-成功-则输出并返回-true-否则只返回-false" class="headerlink" title="20.查找单链表(带头结点)中倒数第$k$个位置的结点,成功:则输出并返回$true$,否则只返回$false$"></a>20.查找单链表(带头结点)中倒数第$k$个位置的结点,成功:则输出并返回$true$,否则只返回$false$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SearchBackwardK</span><span class="params">( LinkList L, <span class="keyword">int</span> k )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p, q;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    p = q = L-&gt;next;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( count &lt; k ) count++;</span><br><span class="line">        <span class="keyword">else</span> q = q-&gt;next;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( count &lt; k ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    visit( q );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="21-链表中-data-绝对值相等的点-只保留第一次出现的结点-data-≤n"><a href="#21-链表中-data-绝对值相等的点-只保留第一次出现的结点-data-≤n" class="headerlink" title="21.链表中$data$绝对值相等的点,只保留第一次出现的结点$(|data|≤n)$"></a>21.链表中$data$绝对值相等的点,只保留第一次出现的结点$(|data|≤n)$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteSameAbs</span><span class="params">( LinkList L, <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList pre, p;</span><br><span class="line">    <span class="keyword">int</span> *B, pos;</span><br><span class="line">    B = ( <span class="keyword">int</span> * ) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span>( <span class="keyword">int</span> )*( n + <span class="number">1</span> ) );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++ )</span><br><span class="line">        B[i] = <span class="number">0</span>;</span><br><span class="line">    pre = L; p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> ( p )</span><br><span class="line">    &#123;</span><br><span class="line">        pos = p-&gt;data &gt; <span class="number">0</span> ? p-&gt;data : -p-&gt;data;</span><br><span class="line">        <span class="keyword">if</span> ( B[pos] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            B[pos] = <span class="number">1</span>; pre = p; p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;next = p-&gt;next; <span class="built_in">free</span>( p ); p = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>( B );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22-带头结点的循环双链表递增排序"><a href="#22-带头结点的循环双链表递增排序" class="headerlink" title="22.带头结点的循环双链表递增排序"></a>22.带头结点的循环双链表递增排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AscSort</span><span class="params">( DLinkList L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DLinkList p, q, r;</span><br><span class="line">    <span class="keyword">if</span> ( !L ) <span class="keyword">return</span>;</span><br><span class="line">    p = L-&gt;next; q = p-&gt;next; r = q-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> ( q!=L )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ( p != L &amp;&amp; p-&gt;data &gt; q-&gt;data )</span><br><span class="line">            p = p-&gt;prior;</span><br><span class="line">        <span class="comment">// 脱链结点p</span></span><br><span class="line">        q-&gt;prior-&gt;next = r;</span><br><span class="line">        r-&gt;prior = q-&gt;prior;</span><br><span class="line">        <span class="comment">// 插入节点p</span></span><br><span class="line">        q-&gt;next = p-&gt;next;</span><br><span class="line">        q-&gt;prior = p;</span><br><span class="line">        p-&gt;next-&gt;prior = q;</span><br><span class="line">        p-&gt;next = q;</span><br><span class="line">        <span class="comment">// 归位(相对位置)</span></span><br><span class="line">        q = r;</span><br><span class="line">        p = q-&gt;prior;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-线性表基础算法&quot;&gt;&lt;a href=&quot;#一-线性表基础算法&quot; class=&quot;headerlink&quot; title=&quot;一. 线性表基础算法&quot;&gt;&lt;/a&gt;一. 线性表基础算法&lt;/h2&gt;&lt;h3 id=&quot;1-线性表插入操作&quot;&gt;&lt;a href=&quot;#1-线性表插入操作&quot; cla
      
    
    </summary>
    
      <category term="algorithm" scheme="https://brianyi.github.io/categories/algorithm/"/>
    
    
      <category term="链表" scheme="https://brianyi.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="顺序表" scheme="https://brianyi.github.io/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>[algorithm]栈和队列</title>
    <link href="https://brianyi.github.io/2019/05/07/algorithm-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://brianyi.github.io/2019/05/07/algorithm-栈和队列/</id>
    <published>2019-05-07T10:18:40.000Z</published>
    <updated>2019-05-07T10:33:38.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-栈和队列综合-算法"><a href="#一-栈和队列综合-算法" class="headerlink" title="一.栈和队列综合(算法)"></a>一.栈和队列综合(算法)</h2><h3 id="1-判断单链表-带头结点-的结点值-字符型-是否中心对称"><a href="#1-判断单链表-带头结点-的结点值-字符型-是否中心对称" class="headerlink" title="1.判断单链表(带头结点)的结点值(字符型)是否中心对称"></a>1.判断单链表(带头结点)的结点值(字符型)是否中心对称</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsSymmetry</span><span class="params">( LinkList&amp; L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> S[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>, len = <span class="number">0</span>, i;</span><br><span class="line">    LinkList p;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> ( p ) &#123; p = p-&gt;next; len++; &#125;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;len/<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        S[++top] = p-&gt;data;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    i--;</span><br><span class="line">    <span class="keyword">if</span> ( len % <span class="number">2</span> )</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> ( top != <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( p-&gt;data != S[top] )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        top--;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-共享栈由两个顺序栈S1-S2构成-总大小为100-请设计S1-S2入栈-出栈的算法"><a href="#2-共享栈由两个顺序栈S1-S2构成-总大小为100-请设计S1-S2入栈-出栈的算法" class="headerlink" title="2.共享栈由两个顺序栈S1,S2构成,总大小为100,请设计S1,S2入栈,出栈的算法"></a>2.共享栈由两个顺序栈S1,S2构成,总大小为100,请设计S1,S2入栈,出栈的算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line">ElemType S[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> top[<span class="number">2</span>] = &#123; <span class="number">-1</span>,MAXSIZE &#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">( <span class="keyword">int</span> i, ElemType x )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( i &lt; <span class="number">0</span> || i&gt;<span class="number">1</span> || top[<span class="number">1</span>] - top[<span class="number">0</span>] == <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> ( i == <span class="number">0</span> ) S[++top[<span class="number">0</span>]] = x;</span><br><span class="line">    <span class="keyword">else</span> S[--top[<span class="number">1</span>]] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">( <span class="keyword">int</span> i, ElemType x )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( i &lt; <span class="number">0</span> || i&gt;<span class="number">1</span> </span><br><span class="line">         || ( i == <span class="number">0</span> &amp;&amp; top[<span class="number">0</span>] == <span class="number">-1</span> ) </span><br><span class="line">         || ( i == <span class="number">1</span> &amp;&amp; top[<span class="number">1</span>] == MAXSIZE ) )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> ( i == <span class="number">0</span> ) x = S[top[<span class="number">0</span>]--];</span><br><span class="line">    <span class="keyword">else</span> x = S[top[<span class="number">1</span>]++];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-如果希望循环队列中的元素都能得到利用-则需设置一个标志域tag-并以tag的值为0或1来区分队头指针front和队尾rear相同时的队列状态是”空”还是”满”-编写与此结构相应的入队和出队算法"><a href="#3-如果希望循环队列中的元素都能得到利用-则需设置一个标志域tag-并以tag的值为0或1来区分队头指针front和队尾rear相同时的队列状态是”空”还是”满”-编写与此结构相应的入队和出队算法" class="headerlink" title="3.如果希望循环队列中的元素都能得到利用,则需设置一个标志域tag,并以tag的值为0或1来区分队头指针front和队尾rear相同时的队列状态是”空”还是”满”,编写与此结构相应的入队和出队算法"></a>3.如果希望循环队列中的元素都能得到利用,则需设置一个标志域tag,并以tag的值为0或1来区分队头指针front和队尾rear相同时的队列状态是”空”还是”满”,编写与此结构相应的入队和出队算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ElemType Q[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 队空条件:    front==rear&amp;&amp;tag==0</span></span><br><span class="line"><span class="comment">// 队满条件:    front==rear&amp;&amp;tag==1</span></span><br><span class="line"><span class="comment">// 进队操作:    rear=(rear+1)%MAXSIZE;</span></span><br><span class="line"><span class="comment">//            Q[rear]=x;</span></span><br><span class="line"><span class="comment">//            tag=1;</span></span><br><span class="line"><span class="comment">// 出队操作:    front=(front+1)%MAXSIZE;</span></span><br><span class="line"><span class="comment">//            x=Q[front];</span></span><br><span class="line"><span class="comment">//            tag=0;</span></span><br></pre></td></tr></table></figure><h4 id="1-”tag”法循环队列入队算法"><a href="#1-”tag”法循环队列入队算法" class="headerlink" title="1)”tag”法循环队列入队算法"></a>1)”tag”法循环队列入队算法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">( ElemType x )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( front == rear &amp;&amp; tag == <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    rear = ( rear + <span class="number">1</span> ) % MAXSIZE;</span><br><span class="line">    Q[rear] = x;</span><br><span class="line">    tag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-”tag”法循环队列出队算法"><a href="#2-”tag”法循环队列出队算法" class="headerlink" title="2)”tag”法循环队列出队算法"></a>2)”tag”法循环队列出队算法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">( ElemType&amp; x )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( front == rear &amp;&amp; tag == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    front = ( front + <span class="number">1</span> ) % MAXSIZE;</span><br><span class="line">    x = Q[front];</span><br><span class="line">    tag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Q是一个队列-S是一个空栈-实现将队列中的元素逆置的算法"><a href="#4-Q是一个队列-S是一个空栈-实现将队列中的元素逆置的算法" class="headerlink" title="4.Q是一个队列,S是一个空栈,实现将队列中的元素逆置的算法"></a>4.Q是一个队列,S是一个空栈,实现将队列中的元素逆置的算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ElemType S[MAXSIZE], Q[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">-1</span>, front = <span class="number">-1</span>, rear = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inverse</span><span class="params">(ElemType S[], ElemType Q[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElemType x;</span><br><span class="line">    <span class="keyword">while</span> ( front != rear )</span><br><span class="line">    &#123;</span><br><span class="line">        x = Q[++front];</span><br><span class="line">        S[++top] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( top != <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        x = S[top--];</span><br><span class="line">        Q[++rear] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-利用两个栈S1-S2模拟一个队列"><a href="#5-利用两个栈S1-S2模拟一个队列" class="headerlink" title="5.利用两个栈S1,S2模拟一个队列"></a>5.利用两个栈S1,S2模拟一个队列</h3><blockquote><p>  已知栈的4个运算如下:<br><strong>    void Push(Stack&amp; S, ElemType x);<br>    void Pop(Stack&amp; S, ElemType&amp; x)<br>    bool IsEmpty(Stack&amp; S);<br>    bool IsOverflow( Stack&amp; S );</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">( Stack&amp; S1, Stack&amp; S2, ElemType x )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !IsOverflow( S1 ) )</span><br><span class="line">    &#123;</span><br><span class="line">        Push( S1, x );</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !IsEmpty( S2 ) )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!IsEmpty(S1))</span><br><span class="line">    &#123;</span><br><span class="line">        Pop( S1, t );</span><br><span class="line">        Push( S2, t );</span><br><span class="line">    &#125;</span><br><span class="line">    Push( S1, x );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">( Stack&amp; S1, Stack&amp; S2, ElemType&amp; x )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!IsEmpty(S2))</span><br><span class="line">    &#123;</span><br><span class="line">        Pop( S2, x ); <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( IsEmpty( S1 ) )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!IsEmpty(S1))</span><br><span class="line">    &#123;</span><br><span class="line">        Pop( S1, t ); </span><br><span class="line">        Push( S2, t );</span><br><span class="line">    &#125;</span><br><span class="line">    Pop( S2, x );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">( Stack&amp; S1, Stack&amp; S2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( IsEmpty( S1 ) &amp;&amp; IsEmpty( S2 ) )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-括号匹配问题-判别表达式中括号是否匹配-只含有"><a href="#6-括号匹配问题-判别表达式中括号是否匹配-只含有" class="headerlink" title="6.括号匹配问题:判别表达式中括号是否匹配(只含有(),[],{})"></a>6.括号匹配问题:判别表达式中括号是否匹配(只含有(),[],{})</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBracketMatch</span><span class="params">( <span class="keyword">char</span>*str )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> S[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c = str[i];</span><br><span class="line">        <span class="keyword">switch</span> ( c )</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'['</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'&#123;'</span>:</span><br><span class="line">            S[++top] = c;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">            c = S[top--];</span><br><span class="line">            <span class="keyword">if</span> ( c != <span class="string">'('</span> )<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">']'</span>:</span><br><span class="line">            c = S[top--];</span><br><span class="line">            <span class="keyword">if</span> ( c != <span class="string">'['</span> )<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'&#125;'</span>:</span><br><span class="line">            c = S[top--];</span><br><span class="line">            <span class="keyword">if</span> ( c != <span class="string">'&#123;'</span> )<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-利用栈实现以下递归函数的非递归计算"><a href="#7-利用栈实现以下递归函数的非递归计算" class="headerlink" title="7.利用栈实现以下递归函数的非递归计算:"></a>7.利用栈实现以下递归函数的非递归计算:</h3><p>$$<br>Pn(x)=<br>\begin{cases}<br>    1,  &amp; n=0 \<br>    2x, &amp; n=1 \<br>    2x\cdot{P_{n-1}}(x)-2(n-1)\cdot{P_{n-2}}(x) &amp; n&gt;1<br>\end{cases}<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">P</span><span class="params">( <span class="keyword">int</span> n, <span class="keyword">double</span> x )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> n;        <span class="comment">// 层</span></span><br><span class="line">        <span class="keyword">double</span> val;    <span class="comment">// 数值结果</span></span><br><span class="line">    &#125;S[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>, fv1 = <span class="number">1</span>, fv2 = <span class="number">2</span> * x;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; i-- )</span><br><span class="line">        S[++top].n = i;</span><br><span class="line">    <span class="keyword">while</span> ( top != <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        S[top].val = <span class="number">2</span> * x*fv2 - <span class="number">2</span> * ( S[top].n - <span class="number">1</span> )*fv1;</span><br><span class="line">        fv1 = fv2;</span><br><span class="line">        fv2 = S[top--].val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( n == <span class="number">0</span> ) <span class="keyword">return</span> fv1;</span><br><span class="line">    <span class="keyword">return</span> fv2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-栈和队列综合-算法&quot;&gt;&lt;a href=&quot;#一-栈和队列综合-算法&quot; class=&quot;headerlink&quot; title=&quot;一.栈和队列综合(算法)&quot;&gt;&lt;/a&gt;一.栈和队列综合(算法)&lt;/h2&gt;&lt;h3 id=&quot;1-判断单链表-带头结点-的结点值-字符型-是否中心对
      
    
    </summary>
    
      <category term="algorithm" scheme="https://brianyi.github.io/categories/algorithm/"/>
    
    
      <category term="栈" scheme="https://brianyi.github.io/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="https://brianyi.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>[algorithm]树与二叉树</title>
    <link href="https://brianyi.github.io/2019/05/07/algorithm-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://brianyi.github.io/2019/05/07/algorithm-树与二叉树/</id>
    <published>2019-05-07T10:01:12.000Z</published>
    <updated>2019-05-07T10:19:31.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-树与二叉树相关算法"><a href="#一-树与二叉树相关算法" class="headerlink" title="一.树与二叉树相关算法"></a>一.树与二叉树相关算法</h2><h3 id="1-二叉树按顺序结构存储-求编号为i和j的两个结点的最近公共祖先结点的值"><a href="#1-二叉树按顺序结构存储-求编号为i和j的两个结点的最近公共祖先结点的值" class="headerlink" title="1.二叉树按顺序结构存储,求编号为i和j的两个结点的最近公共祖先结点的值"></a>1.二叉树按顺序结构存储,求编号为i和j的两个结点的最近公共祖先结点的值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElemType <span class="title">CommonAncestor</span><span class="params">( SeqTree T, <span class="keyword">int</span> i, <span class="keyword">int</span> j )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( i != j )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( i &gt; j ) i /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> j /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-二叉树前序遍历非递归算法"><a href="#2-二叉树前序遍历非递归算法" class="headerlink" title="2.二叉树前序遍历非递归算法"></a>2.二叉树前序遍历非递归算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">( BiTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTree S[MAXSIZE], p;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    p = T;</span><br><span class="line">    <span class="keyword">while</span> ( p || top != <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            visit( p );</span><br><span class="line">            S[++top] = p; p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = S[top--]; p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-二叉树中序遍历非递归算法"><a href="#3-二叉树中序遍历非递归算法" class="headerlink" title="3.二叉树中序遍历非递归算法"></a>3.二叉树中序遍历非递归算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">( BiTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTree S[MAXSIZE], p;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    p = T;</span><br><span class="line">    <span class="keyword">while</span> ( p || top != <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p )</span><br><span class="line">        &#123;</span><br><span class="line">            S[++top] = p; p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = S[top--]; visit( p ); p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-二叉树后序遍历非递归算法"><a href="#4-二叉树后序遍历非递归算法" class="headerlink" title="4.二叉树后序遍历非递归算法"></a>4.二叉树后序遍历非递归算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">( BiTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTree Q[MAXSIZE], p, r;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    p = T; r = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> ( p || top != <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p)    <span class="comment">// 走到最左边</span></span><br><span class="line">        &#123;</span><br><span class="line">            S[++top] = p; p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">// 向右</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = S[top];</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;rchild&amp;&amp;p-&gt;rchild!=r)    <span class="comment">// 转向右</span></span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">// 根</span></span><br><span class="line">            &#123;</span><br><span class="line">                p = S[top--];</span><br><span class="line">                visit( p );</span><br><span class="line">                r = p;</span><br><span class="line">                p = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-二叉树层次遍历算法"><a href="#5-二叉树层次遍历算法" class="headerlink" title="5.二叉树层次遍历算法"></a>5.二叉树层次遍历算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">( BiTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTree Q[MAXSIZE], p;</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>;</span><br><span class="line">    Q[++rear] = T;</span><br><span class="line">    <span class="keyword">while</span> ( front != rear )</span><br><span class="line">    &#123;</span><br><span class="line">        p = Q[++front];</span><br><span class="line">        visit( p );</span><br><span class="line">        <span class="keyword">if</span> ( p-&gt;lchild ) Q[++rear] = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">if</span> ( p-&gt;rchild ) Q[++rear] = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-二叉树的自下而上-从右到左的层次遍历算法"><a href="#6-二叉树的自下而上-从右到左的层次遍历算法" class="headerlink" title="6.二叉树的自下而上,从右到左的层次遍历算法"></a>6.二叉树的自下而上,从右到左的层次遍历算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InvertLevel</span><span class="params">( BiTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTree S[MAXSIZE], Q[MAXSIZE], p;</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>, top = <span class="number">-1</span>;</span><br><span class="line">    Q[++rear] = T;</span><br><span class="line">    <span class="keyword">while</span> ( front != rear )</span><br><span class="line">    &#123;</span><br><span class="line">        p = Q[++front];</span><br><span class="line">        S[++top] = p;</span><br><span class="line">        <span class="keyword">if</span> ( p-&gt;lchild ) Q[++rear] = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">if</span> ( p-&gt;rchild ) Q[++rear] = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( top!=<span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        p = S[top--]; visit( p );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-求二叉树高度-递归"><a href="#7-求二叉树高度-递归" class="headerlink" title="7.求二叉树高度(递归)"></a>7.求二叉树高度(递归)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BtDepth</span><span class="params">( BiTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( T == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ldepth, rdepth;</span><br><span class="line">    ldepth = BtDepth( T-&gt;lchild );</span><br><span class="line">    rdepth = BtDepth( T-&gt;rchild );</span><br><span class="line">    <span class="keyword">return</span> ldepth &gt; rdepth ? ldepth + <span class="number">1</span> : rdepth + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-求二叉树高度-非递归"><a href="#8-求二叉树高度-非递归" class="headerlink" title="8.求二叉树高度(非递归)"></a>8.求二叉树高度(非递归)</h3><blockquote><p>法一思路:后序遍历,最大栈长即为树的高度</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BtDepth</span><span class="params">( BiTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTree S[MAXSIZE], p, r;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>, depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( p || top != <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( p )</span><br><span class="line">        &#123;</span><br><span class="line">            S[++top] = p; p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = S[top];</span><br><span class="line">            <span class="keyword">if</span> ( p-&gt;rchild&amp;&amp;p-&gt;rchild != r )</span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (top+<span class="number">1</span>&gt;depth)</span><br><span class="line">                    depth = top + <span class="number">1</span>;</span><br><span class="line">                p = S[top--];</span><br><span class="line">                r = p;</span><br><span class="line">                p = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>法二思路:层次遍历,层数即为高度</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BtDepth</span><span class="params">( BiTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTree Q[MAXSIZE], p;</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>, last = <span class="number">0</span>, depth = <span class="number">0</span>;</span><br><span class="line">    Q[++rear] = T;</span><br><span class="line">    <span class="keyword">while</span> ( front != rear )</span><br><span class="line">    &#123;</span><br><span class="line">        p = Q[++front];</span><br><span class="line">        <span class="keyword">if</span> ( p-&gt;lchild )</span><br><span class="line">            Q[++rear] = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">if</span> ( p-&gt;rchild )</span><br><span class="line">            Q[++rear] = p-&gt;rchild;</span><br><span class="line">        <span class="keyword">if</span> ( front == last )</span><br><span class="line">        &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            last = rear;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-先许遍历序列和中序遍历序列分别存放于两个一维数组A-1…n-B-1…n-中-编写算法建立该二叉树的二叉链表"><a href="#9-先许遍历序列和中序遍历序列分别存放于两个一维数组A-1…n-B-1…n-中-编写算法建立该二叉树的二叉链表" class="headerlink" title="9.先许遍历序列和中序遍历序列分别存放于两个一维数组A[1…n],B[1…n]中,编写算法建立该二叉树的二叉链表"></a>9.先许遍历序列和中序遍历序列分别存放于两个一维数组A[1…n],B[1…n]中,编写算法建立该二叉树的二叉链表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTree <span class="title">PreInCreate</span><span class="params">( ElemType A[], ElemType B[], <span class="keyword">int</span> l1, <span class="keyword">int</span> h1, <span class="keyword">int</span> l2, <span class="keyword">int</span> h2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTree root = ( BiTree ) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span>( BiTNode ) );</span><br><span class="line">    <span class="keyword">int</span> i, llen, rlen;</span><br><span class="line">    root-&gt;data = A[l1];</span><br><span class="line">    <span class="keyword">for</span> ( i = l2; B[i] != root-&gt;data; i++ );</span><br><span class="line">    llen = i - l2;</span><br><span class="line">    rlen = h2 - i;</span><br><span class="line">    <span class="keyword">if</span> ( llen )</span><br><span class="line">        root-&gt;lchild = PreInCreate( A, B, l1 + <span class="number">1</span>, l1 + llen, l2, l2 + llen - <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        root-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( rlen )</span><br><span class="line">        root-&gt;rchild = PreInCreate( A, B, h1 - rlen + <span class="number">1</span>, h1, h2 - rlen + <span class="number">1</span>, h2 );</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        root-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-判断二叉树是否是完全二叉树"><a href="#10-判断二叉树是否是完全二叉树" class="headerlink" title="10.判断二叉树是否是完全二叉树"></a>10.判断二叉树是否是完全二叉树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsComplete</span><span class="params">( BiTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( T == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    BiTree Q[MAXSIZE], p;</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>;</span><br><span class="line">    Q[++rear] = T;</span><br><span class="line">    <span class="keyword">while</span> ( front != rear )</span><br><span class="line">    &#123;</span><br><span class="line">        p = Q[++front];</span><br><span class="line">        <span class="keyword">if</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            Q[++rear] = p-&gt;lchild;</span><br><span class="line">            Q[++rear] = p-&gt;rchild;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> ( front != rear )</span><br><span class="line">            &#123;</span><br><span class="line">                p = Q[++front];</span><br><span class="line">                <span class="keyword">if</span> ( p ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-计算一棵给定二叉树的所有双分支结点个数"><a href="#11-计算一棵给定二叉树的所有双分支结点个数" class="headerlink" title="11.计算一棵给定二叉树的所有双分支结点个数"></a>11.计算一棵给定二叉树的所有双分支结点个数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">N2Nodes</span><span class="params">( BiTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( T == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( T-&gt;lchild &amp;&amp; T-&gt;rchild )</span><br><span class="line">        <span class="keyword">return</span> N2Nodes( T-&gt;lchild ) + N2Nodes( T-&gt;rchild ) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> N2Nodes( T-&gt;lchild ) + N2Nodes( T-&gt;rchild );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-将二叉树中所有结点的左-右子树进行交换"><a href="#12-将二叉树中所有结点的左-右子树进行交换" class="headerlink" title="12.将二叉树中所有结点的左,右子树进行交换"></a>12.将二叉树中所有结点的左,右子树进行交换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SwapTree</span><span class="params">( BiTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( T == <span class="literal">NULL</span> ) <span class="keyword">return</span>;</span><br><span class="line">    SwapTree( T-&gt;lchild );</span><br><span class="line">    SwapTree( T-&gt;rchild );</span><br><span class="line">    swap( T-&gt;lchild, T-&gt;rchild );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-求二叉树先序遍历序列中第k-1≤k≤二叉树结点个数-个结点的值"><a href="#13-求二叉树先序遍历序列中第k-1≤k≤二叉树结点个数-个结点的值" class="headerlink" title="13.求二叉树先序遍历序列中第k(1≤k≤二叉树结点个数)个结点的值"></a>13.求二叉树先序遍历序列中第k(1≤k≤二叉树结点个数)个结点的值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="function">ElemType <span class="title">PreNodeK</span><span class="params">( BiTree T, <span class="keyword">int</span> k )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( T == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    <span class="keyword">if</span> ( i == k ) <span class="keyword">return</span> T-&gt;data;</span><br><span class="line">    i++;    <span class="comment">// 下一个结点</span></span><br><span class="line">    ElemType ch = PreNodeK( T-&gt;lchild, k );</span><br><span class="line">    <span class="keyword">if</span> ( ch != <span class="string">'#'</span> ) <span class="keyword">return</span> ch;</span><br><span class="line">    ch = PreNodeK( T-&gt;rchild, k );</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-二叉树中-对于每一个元素值为x的结点-删去以它为根的子树-并释放相应的空间"><a href="#14-二叉树中-对于每一个元素值为x的结点-删去以它为根的子树-并释放相应的空间" class="headerlink" title="14.二叉树中,对于每一个元素值为x的结点,删去以它为根的子树,并释放相应的空间"></a>14.二叉树中,对于每一个元素值为x的结点,删去以它为根的子树,并释放相应的空间</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">( BiTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( T == <span class="literal">NULL</span> ) <span class="keyword">return</span>;</span><br><span class="line">    DeleteNode( T-&gt;lchild );</span><br><span class="line">    DeleteNode( T-&gt;rchild );</span><br><span class="line">    <span class="built_in">free</span>( T );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>法一:递归</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteAllXNode</span><span class="params">( BiTree T, ElemType x )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( T == <span class="literal">NULL</span> ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> ( T-&gt;data == x )</span><br><span class="line">    &#123;</span><br><span class="line">        DeleteNode( T ); <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DeleteAllXNode( T-&gt;lchild, x );</span><br><span class="line">    DeleteAllXNode( T-&gt;rchild, x );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>法二:非递归</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteAllXNode</span><span class="params">( BiTree T, ElemType x )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( T == <span class="literal">NULL</span> ) <span class="keyword">return</span>;</span><br><span class="line">    BiTree Q[MAXSIZE], p;</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>;</span><br><span class="line">    Q[++rear] = T;</span><br><span class="line">    <span class="keyword">while</span> ( front != rear )</span><br><span class="line">    &#123;</span><br><span class="line">        p = Q[++front];</span><br><span class="line">        <span class="keyword">if</span> ( p-&gt;data == x ) DeleteNode( p );</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( p-&gt;lchild ) Q[++rear] = p-&gt;lchild;</span><br><span class="line">            <span class="keyword">if</span> ( p-&gt;rchild ) Q[++rear] = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-输出二叉树中值为x的结点-≤1-个的所有祖先"><a href="#15-输出二叉树中值为x的结点-≤1-个的所有祖先" class="headerlink" title="15.输出二叉树中值为x的结点(≤1)个的所有祖先"></a>15.输出二叉树中值为x的结点(≤1)个的所有祖先</h3><blockquote><p>法一:递归</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AllAncestorX</span><span class="params">( BiTree T, ElemType x )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( T == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> ( T-&gt;data == x ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> b1, b2;</span><br><span class="line">    b1 = AllAncestorX( T-&gt;lchild, x );</span><br><span class="line">    b2 = AllAncestorX( T-&gt;rchild, x );</span><br><span class="line">    <span class="keyword">if</span> ( b1 || b2 ) visit( T );</span><br><span class="line">    <span class="keyword">return</span> b1 || b2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>法二:非递归<br>思路: 后序遍历非递归方式中,保留在栈中所有元素(除栈顶外)必然是栈顶的祖先结点,只要找到x结点,将所有结点出栈即可</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AllAncestorX</span><span class="params">( BiTree T, ElemType x )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( T == <span class="literal">NULL</span> ) <span class="keyword">return</span>;</span><br><span class="line">    BiTree S[MAXSIZE], p, r;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    p = T; r = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> ( p||top!=<span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            S[++top] = p; p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = S[top];</span><br><span class="line">            <span class="keyword">if</span> ( p-&gt;rchild&amp;&amp;p-&gt;rchild != r )</span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p = S[top--];</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;data==x)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span> ( top != <span class="number">-1</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        p = S[top--]; visit( p );</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                r = p;</span><br><span class="line">                p = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-p-q为二叉树中任意两个结点的指针-编写算法找到p-q的最近公共祖先结点-递归"><a href="#16-p-q为二叉树中任意两个结点的指针-编写算法找到p-q的最近公共祖先结点-递归" class="headerlink" title="16.p,q为二叉树中任意两个结点的指针,编写算法找到p,q的最近公共祖先结点(递归)"></a>16.p,q为二叉树中任意两个结点的指针,编写算法找到p,q的最近公共祖先结点(递归)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路: ①左子树中能找到p(或q),右子树中能找到q(或p),的结点一定为p,q的最近公共结点</span></span><br><span class="line"><span class="comment">//       ②p,q都在右子树上,则深度低的为公共祖先</span></span><br><span class="line"><span class="comment">//       ③p,q都在左子树上,则深度低的为公共祖先</span></span><br><span class="line"><span class="comment">//    三种情况      o  &lt;-root(此时为公共祖先)     o  &lt;-root                             o &lt;-root</span></span><br><span class="line"><span class="comment">//                / \                            \                                   /</span></span><br><span class="line"><span class="comment">//           p-&gt; o   o  &lt;-q                       o  &lt;-p(此时为公共祖先为right)      o  &lt;-p(此时为公共祖先left)</span></span><br><span class="line"><span class="comment">//                                                 \                               /</span></span><br><span class="line"><span class="comment">//                                                  o  &lt;-q                        o  &lt;-q</span></span><br><span class="line"><span class="function">BiTree <span class="title">Ancestor</span><span class="params">( BiTree root, BiTNode *p, BiTNode *q )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !root || !p || !q ) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( p == root || q == root ) <span class="keyword">return</span> root;</span><br><span class="line">    BiTree left, right;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * ①在左子树中,若找到p,q中一个,则返回一个</span></span><br><span class="line"><span class="comment">     * ②在左子树中,若找到p,q(全),则返回较近的一个(高度较低的)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    left = Ancestor( root-&gt;lchild, p, q );</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * ①在右子树中,若找到p,q中一个,则返回一个</span></span><br><span class="line"><span class="comment">     * ②在右子树中,若找到p,q(全),则返回较近的一个(高度较低的)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    right = Ancestor( root-&gt;rchild, p, q );    </span><br><span class="line">    <span class="keyword">if</span> ( left&amp;&amp;right ) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">return</span> left ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-求非空二叉树的宽度"><a href="#17-求非空二叉树的宽度" class="headerlink" title="17.求非空二叉树的宽度"></a>17.求非空二叉树的宽度</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeWidth</span><span class="params">( BiTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTree Q[MAXSIZE], p;</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>, maxWidth = <span class="number">0</span>;</span><br><span class="line">    Q[++rear] = T;</span><br><span class="line">    <span class="keyword">while</span> ( front != rear )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> width = rear - front;</span><br><span class="line">        <span class="keyword">if</span> ( maxWidth &lt; width )</span><br><span class="line">            maxWidth = width;</span><br><span class="line">        <span class="keyword">while</span> ( width-- )</span><br><span class="line">        &#123;</span><br><span class="line">            p = Q[++front];</span><br><span class="line">            <span class="keyword">if</span> ( p-&gt;lchild ) Q[++rear] = p-&gt;lchild;</span><br><span class="line">            <span class="keyword">if</span> ( p-&gt;rchild ) Q[++rear] = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-一棵满二叉树-所有结点值均不同-已知其先序序列为pre-设计算法求其后序序列post"><a href="#18-一棵满二叉树-所有结点值均不同-已知其先序序列为pre-设计算法求其后序序列post" class="headerlink" title="18.一棵满二叉树(所有结点值均不同),已知其先序序列为pre,设计算法求其后序序列post"></a>18.一棵满二叉树(所有结点值均不同),已知其先序序列为pre,设计算法求其后序序列post</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路: 每次都会确定出后序的一个位置并划分为左右两块,再分别在这左右两块中继续确定其他元素 </span></span><br><span class="line"><span class="comment">//  先序: x|    |    |</span></span><br><span class="line"><span class="comment">//  后序:  |    |    |x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreToPost</span><span class="params">( ElemType pre[], <span class="keyword">int</span> l1, <span class="keyword">int</span> h1, ElemType post[], <span class="keyword">int</span> l2, <span class="keyword">int</span> h2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( h1 &lt; l1 ) <span class="keyword">return</span>;</span><br><span class="line">    post[h2] = pre[l1]; <span class="comment">// 确定出一个后序位置</span></span><br><span class="line">    <span class="keyword">int</span> half = ( h1 - l1 ) / <span class="number">2</span>;</span><br><span class="line">    PreToPost( pre, l1 + <span class="number">1</span>, l1 + half, post, l2, l2 + half - <span class="number">1</span> );</span><br><span class="line">    PreToPost( pre, h1 - half + <span class="number">1</span>, h1, post, h2 - half, h2 - <span class="number">1</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19-将二叉树叶子结点按从左到右连成单链表-表头指针为head-叶结点的右指针域存放单链表指针"><a href="#19-将二叉树叶子结点按从左到右连成单链表-表头指针为head-叶结点的右指针域存放单链表指针" class="headerlink" title="19.将二叉树叶子结点按从左到右连成单链表,表头指针为head,叶结点的右指针域存放单链表指针"></a>19.将二叉树叶子结点按从左到右连成单链表,表头指针为head,叶结点的右指针域存放单链表指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BiTree head, pre = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function">BiTree <span class="title">InOrder</span><span class="params">( BiTree bt )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( bt == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    InOrder( bt-&gt;lchild );</span><br><span class="line">    <span class="keyword">if</span> ( !bt-&gt;lchild &amp;&amp; !bt-&gt;rchild )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pre)</span><br><span class="line">        &#123;</span><br><span class="line">            head = pre = bt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;rchild = bt; pre = bt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    InOrder( bt-&gt;rchild );</span><br><span class="line">    pre-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20-判断两棵二叉树是否相似-注-不要求结点值相同-只要树的外形相同即可"><a href="#20-判断两棵二叉树是否相似-注-不要求结点值相同-只要树的外形相同即可" class="headerlink" title="20.判断两棵二叉树是否相似.(注:不要求结点值相同,只要树的外形相同即可)"></a>20.判断两棵二叉树是否相似.(注:不要求结点值相同,只要树的外形相同即可)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Similar</span><span class="params">( BiTree T1, BiTree T2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( T1 == <span class="literal">NULL</span> &amp;&amp; T2 == <span class="literal">NULL</span> ) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( T1 == <span class="literal">NULL</span> || T2 == <span class="literal">NULL</span> ) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( Similar( T1-&gt;lchild, T2-&gt;lchild ) &amp;&amp; Similar( T1-&gt;rchild, T2-&gt;rchild ) )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="21-将表达式树转换为等价的中缀表达式-通过括号反映操作符的计算次序-并输出"><a href="#21-将表达式树转换为等价的中缀表达式-通过括号反映操作符的计算次序-并输出" class="headerlink" title="21.将表达式树转换为等价的中缀表达式(通过括号反映操作符的计算次序)并输出"></a>21.将表达式树转换为等价的中缀表达式(通过括号反映操作符的计算次序)并输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路: 表达式树的中序序列加上必要的括号即为等价的中缀表达式.除根结点外,遍历到其他结点时在遍历其左子树之前加上左括号,在遍历完右子树后加上右括号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BiTreeToExp</span><span class="params">( BiTree T, <span class="keyword">int</span> deep )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( T == <span class="literal">NULL</span> ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( !T-&gt;lchild &amp;&amp; !T-&gt;rchild ) visit( T );</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( deep &gt; <span class="number">1</span> ) <span class="built_in">printf</span>( <span class="string">"("</span> );</span><br><span class="line">        BiTreeToExp( T-&gt;lchild, deep + <span class="number">1</span> );</span><br><span class="line">        visit( T );</span><br><span class="line">        BiTreeToExp( T-&gt;rchild, deep + <span class="number">1</span> );</span><br><span class="line">        <span class="keyword">if</span> ( deep &gt; <span class="number">1</span> ) <span class="built_in">printf</span>( <span class="string">"("</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22-求孩子兄弟表示法存储的森林的叶子节点数"><a href="#22-求孩子兄弟表示法存储的森林的叶子节点数" class="headerlink" title="22.求孩子兄弟表示法存储的森林的叶子节点数"></a>22.求孩子兄弟表示法存储的森林的叶子节点数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;CSNode, *CSTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Leaves</span><span class="params">( CSTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( T == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( T-&gt;firstchild == <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Leaves( T-&gt;nextsibling );</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Leaves( T-&gt;firstchild ) + Leaves( T-&gt;nextsibling );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23-以孩子兄弟链表为存储结构-求树的高度-深度-递归"><a href="#23-以孩子兄弟链表为存储结构-求树的高度-深度-递归" class="headerlink" title="23.以孩子兄弟链表为存储结构,求树的高度(深度)(递归)"></a>23.以孩子兄弟链表为存储结构,求树的高度(深度)(递归)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Height</span><span class="params">( CSTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( T == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hc, hs;</span><br><span class="line">    hc = Height( T-&gt;firstchild ) + <span class="number">1</span>;</span><br><span class="line">    hs = Height( T-&gt;nextsibling );</span><br><span class="line">    <span class="keyword">return</span> hc &gt; hs ? hc : hs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="24-二叉排序树的查找-非递归"><a href="#24-二叉排序树的查找-非递归" class="headerlink" title="24.二叉排序树的查找(非递归)"></a>24.二叉排序树的查找(非递归)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTree <span class="title">BSTSearch</span><span class="params">( BiTree T, ElemType key )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( T &amp;&amp; key != T-&gt;data )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( key &lt; T-&gt;data )</span><br><span class="line">            T = T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T = T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTree <span class="title">BSTSearch</span><span class="params">( BiTree T, ElemType key )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( T )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( T-&gt;data == key ) <span class="keyword">return</span> T;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( T-&gt;data &gt; key )</span><br><span class="line">            T = T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T = T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="25-二叉排序树的插入-递归"><a href="#25-二叉排序树的插入-递归" class="headerlink" title="25.二叉排序树的插入(递归)"></a>25.二叉排序树的插入(递归)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BSTInsert</span><span class="params">( BiTree&amp; T, ElemType key )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T)</span><br><span class="line">    &#123;</span><br><span class="line">        T = ( BiTree ) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span>( BiTNode ) );</span><br><span class="line">        T-&gt;data = key;</span><br><span class="line">        T-&gt;lchild = T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( T-&gt;data == key ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( T-&gt;data &gt; key ) <span class="keyword">return</span> BSTInsert( T-&gt;lchild, key );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> BSTInsert( T-&gt;rchild, key );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="26-计算二叉树的带权路径长度-递归"><a href="#26-计算二叉树的带权路径长度-递归" class="headerlink" title="26.计算二叉树的带权路径长度(递归)"></a>26.计算二叉树的带权路径长度(递归)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> wpl = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WPL_PreOrder</span><span class="params">( BiTree T, <span class="keyword">int</span> deep )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( T == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !T-&gt;lchild &amp;&amp; !T-&gt;rchild )</span><br><span class="line">        wpl += deep * T-&gt;weight;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( T-&gt;lchild ) WPL_PreOrder( T-&gt;lchild, deep + <span class="number">1</span> );</span><br><span class="line">        <span class="keyword">if</span> ( T-&gt;rchild ) WPL_PreOrder( T-&gt;rchild, deep + <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wpl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="27-计算二叉树的带权路径长度-非递归"><a href="#27-计算二叉树的带权路径长度-非递归" class="headerlink" title="27.计算二叉树的带权路径长度(非递归)"></a>27.计算二叉树的带权路径长度(非递归)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路: 层序遍历的思想</span></span><br><span class="line"><span class="keyword">int</span> wpl = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WPL_LevelOrder</span><span class="params">( BiTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( T == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    BiTree Q[MAXSIZE], p;</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>, depth = <span class="number">0</span>, last = <span class="number">0</span>;</span><br><span class="line">    Q[++rear] = T;</span><br><span class="line">    <span class="keyword">while</span> ( front != rear )</span><br><span class="line">    &#123;</span><br><span class="line">        p = Q[++front];</span><br><span class="line">        <span class="keyword">if</span> ( !p-&gt;lchild &amp;&amp; !p-&gt;rchild )</span><br><span class="line">            wpl += depth * p-&gt;weight;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( p-&gt;lchild ) Q[++rear] = p-&gt;lchild;</span><br><span class="line">            <span class="keyword">if</span> ( p-&gt;rchild ) Q[++rear] = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( front == last )</span><br><span class="line">        &#123;</span><br><span class="line">            depth++; last = rear;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wpl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="28-判断二叉树是否为二叉排序树"><a href="#28-判断二叉树是否为二叉排序树" class="headerlink" title="28.判断二叉树是否为二叉排序树"></a>28.判断二叉树是否为二叉排序树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ElemType preVal = MIN;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBST</span><span class="params">( BiTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( T == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !IsBST( T-&gt;lchild ) ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> ( preVal &gt;= T-&gt;data )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        preVal = T-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> ( !IsBST( T-&gt;rchild ) ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="29-求出指定结点在二叉排序树中的层次"><a href="#29-求出指定结点在二叉排序树中的层次" class="headerlink" title="29.求出指定结点在二叉排序树中的层次"></a>29.求出指定结点在二叉排序树中的层次</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Level</span><span class="params">( BiTree T, BiTree p )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( T == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ( T-&gt;data != p-&gt;data )</span><br><span class="line">    &#123;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">if</span> ( p-&gt;data &lt; T-&gt;data )</span><br><span class="line">            T = T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T = T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="30-判断二叉树是否为平衡二叉树"><a href="#30-判断二叉树是否为平衡二叉树" class="headerlink" title="30.判断二叉树是否为平衡二叉树"></a>30.判断二叉树是否为平衡二叉树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsAVL</span><span class="params">( BiTree T, <span class="keyword">int</span>&amp; h )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h1 = <span class="number">0</span>, h2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (T==<span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        h = <span class="number">0</span>; <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( IsAVL( T-&gt;lchild, h1 ) &amp;&amp; IsAVL( T-&gt;rchild, h2 ) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">abs</span>( h1 - h2 ) &lt;= <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            h = <span class="number">1</span> + ( h1 &gt; h2 ? h1 : h2 );</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="31-从大到小输出二叉排序中所有值不小于k的关键字"><a href="#31-从大到小输出二叉排序中所有值不小于k的关键字" class="headerlink" title="31.从大到小输出二叉排序中所有值不小于k的关键字"></a>31.从大到小输出二叉排序中所有值不小于k的关键字</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DesOutput</span><span class="params">( BiTree T, ElemType k )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( T == <span class="literal">NULL</span> ) <span class="keyword">return</span>;</span><br><span class="line">    DesOutput( T-&gt;rchild, k );</span><br><span class="line">    <span class="keyword">if</span> ( T-&gt;data &gt;= k )</span><br><span class="line">        visit( T );</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    DesOutput( T-&gt;lchild, k );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="32-在二叉排序树上查找第k-1≤k≤n-小的元素-要求平均时间复杂度为O-log2n-二叉排序树上的每个结点中除data-lchild-rchild外-还增加一个count成员-保存以该结点为根的子树上的结点个数"><a href="#32-在二叉排序树上查找第k-1≤k≤n-小的元素-要求平均时间复杂度为O-log2n-二叉排序树上的每个结点中除data-lchild-rchild外-还增加一个count成员-保存以该结点为根的子树上的结点个数" class="headerlink" title="32.在二叉排序树上查找第k(1≤k≤n)小的元素,要求平均时间复杂度为O(log2n)二叉排序树上的每个结点中除data,lchild,rchild外,还增加一个count成员,保存以该结点为根的子树上的结点个数"></a>32.在二叉排序树上查找第k(1≤k≤n)小的元素,要求平均时间复杂度为O(log2n)二叉排序树上的每个结点中除data,lchild,rchild外,还增加一个count成员,保存以该结点为根的子树上的结点个数</h3><blockquote><p>法一</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTree <span class="title">SearchSmallK</span><span class="params">( BiTree T, <span class="keyword">int</span> k )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( k&lt;<span class="number">1</span> || k&gt;T-&gt;count ) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( T-&gt;lchild )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( k &lt;= T-&gt;lchild-&gt;count )</span><br><span class="line">            <span class="keyword">return</span> SearchSmallK( T-&gt;lchild, k );</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( k == T-&gt;lchild-&gt;count + <span class="number">1</span> )</span><br><span class="line">            <span class="keyword">return</span> T;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> SearchSmallK( T-&gt;rchild, k - ( T-&gt;lchild-&gt;count + <span class="number">1</span> ) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( k == <span class="number">1</span> ) <span class="keyword">return</span> T;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> SearchSmallK( T-&gt;rchild, k - <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>法二</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTree <span class="title">SearchSmallK</span><span class="params">( BiTree T, <span class="keyword">int</span> k )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( k&lt;<span class="number">1</span> || k&gt;T-&gt;count ) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( T-&gt;lchild )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( k &lt;= T-&gt;lchild-&gt;count )</span><br><span class="line">            <span class="keyword">return</span> SearchSmallK( T-&gt;lchild, k );</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            k -= T-&gt;lchild-&gt;count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( k == <span class="number">1</span> ) <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">if</span> ( T-&gt;rchild )</span><br><span class="line">        <span class="keyword">return</span> SearchSmallK( T-&gt;rchild, k - <span class="number">1</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="33-对于含有-−-∗-及括号的算术表达式-中缀表达式-写一个算法-将该表达式构造成相应的二叉树表示"><a href="#33-对于含有-−-∗-及括号的算术表达式-中缀表达式-写一个算法-将该表达式构造成相应的二叉树表示" class="headerlink" title="33.对于含有+,−,∗,/及括号的算术表达式(中缀表达式)写一个算法,将该表达式构造成相应的二叉树表示"></a>33.对于含有+,−,∗,/及括号的算术表达式(中缀表达式)写一个算法,将该表达式构造成相应的二叉树表示</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思想: 最后使用的操作符作为根.即:先+,-后*,/</span></span><br><span class="line"><span class="comment">// 例如: a+b*(c-d)-e/f构造的表达式树如下:</span></span><br><span class="line"><span class="comment">//                -</span></span><br><span class="line"><span class="comment">//               /  \</span></span><br><span class="line"><span class="comment">//              +    /</span></span><br><span class="line"><span class="comment">//             / \  / \</span></span><br><span class="line"><span class="comment">//            a  *  e  f</span></span><br><span class="line"><span class="comment">//              / \</span></span><br><span class="line"><span class="comment">//             b   -</span></span><br><span class="line"><span class="comment">//                / \</span></span><br><span class="line"><span class="comment">//               c   d</span></span><br><span class="line"><span class="comment">// 通过该表达式树,可以很容易得到:</span></span><br><span class="line"><span class="comment">// 前缀表达式: -+a*b-cd/ef</span></span><br><span class="line"><span class="comment">// 中缀表达式: a+b*c-d-e/f</span></span><br><span class="line"><span class="comment">// 后缀表达式: abcd-*+ef/-</span></span><br><span class="line"><span class="function">BiTNode* <span class="title">BuildTree</span><span class="params">( <span class="keyword">char</span>* <span class="built_in">exp</span>, <span class="keyword">int</span> s, <span class="keyword">int</span> e )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( e - s == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        BiTNode* p = ( BiTNode* ) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span>( BiTNode ) );</span><br><span class="line">        p-&gt;data = <span class="built_in">exp</span>[s];</span><br><span class="line">        p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c1 = <span class="number">-1</span>, c2 = <span class="number">-1</span>, c = <span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">for</span> ( i = s; i &lt; e; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">exp</span>[i] == <span class="string">'('</span> ) c++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( ( <span class="built_in">exp</span>[i] == <span class="string">'+'</span> || <span class="built_in">exp</span>[i] == <span class="string">'-'</span> ) &amp;&amp; !c )</span><br><span class="line">            c1 = i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( ( <span class="built_in">exp</span>[i] == <span class="string">'*'</span> || <span class="built_in">exp</span>[i] == <span class="string">'/'</span> ) &amp;&amp; !c )</span><br><span class="line">            c2 = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( c1 &lt; <span class="number">0</span> ) c1 = c2;</span><br><span class="line">    <span class="keyword">if</span> ( c1 &lt; <span class="number">0</span> ) <span class="keyword">return</span> BuildTree( <span class="built_in">exp</span>, s + <span class="number">1</span>, e - <span class="number">1</span> );</span><br><span class="line">    BiTree* p = ( BiTNode* ) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span>( BiTNode ) );</span><br><span class="line">    p-&gt;data = <span class="built_in">exp</span>[c1];</span><br><span class="line">    p-&gt;lchild = BuildTree( <span class="built_in">exp</span>, s, c1 );</span><br><span class="line">    p-&gt;rchild = BuildTree( <span class="built_in">exp</span>, c1 + <span class="number">1</span>, e );</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-树与二叉树相关算法&quot;&gt;&lt;a href=&quot;#一-树与二叉树相关算法&quot; class=&quot;headerlink&quot; title=&quot;一.树与二叉树相关算法&quot;&gt;&lt;/a&gt;一.树与二叉树相关算法&lt;/h2&gt;&lt;h3 id=&quot;1-二叉树按顺序结构存储-求编号为i和j的两个结点的最近公
      
    
    </summary>
    
      <category term="algorithm" scheme="https://brianyi.github.io/categories/algorithm/"/>
    
    
      <category term="树" scheme="https://brianyi.github.io/tags/%E6%A0%91/"/>
    
      <category term="二叉树" scheme="https://brianyi.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[algorithm]图</title>
    <link href="https://brianyi.github.io/2019/05/07/algorithm-%E5%9B%BE/"/>
    <id>https://brianyi.github.io/2019/05/07/algorithm-图/</id>
    <published>2019-05-07T09:42:02.000Z</published>
    <updated>2019-05-07T10:00:06.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-图的算法"><a href="#一-图的算法" class="headerlink" title="一.图的算法"></a>一.图的算法</h2><h3 id="1-邻接矩阵和邻接表的表示"><a href="#1-邻接矩阵和邻接表的表示" class="headerlink" title="1. 邻接矩阵和邻接表的表示"></a>1. 邻接矩阵和邻接表的表示</h3><h4 id="1-邻接矩阵表示的数据结构"><a href="#1-邻接矩阵表示的数据结构" class="headerlink" title="1). 邻接矩阵表示的数据结构"></a>1). 邻接矩阵表示的数据结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY INT_MAX <span class="comment">// 无穷大</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM 20 <span class="comment">// 限制顶点最大数值为20个</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ARC_NUM  MAX_VERTEX_NUM * (MAX_VERTEX_NUM - 1) <span class="comment">// 由n个顶点，最多可以确定n(n-2)/2条直线,有向图为2倍</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_INFO 20 <span class="comment">// 用户输入的弧信息，最多20个字符</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*数组表示法*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>        VRType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>    InfoType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>    VertexType[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>    &#123;DG, DN, UDG, UDN&#125; GraphKind; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcCell</span> &#123;</span></span><br><span class="line">    VRType adj;</span><br><span class="line">    InfoType *info;</span><br><span class="line">&#125;ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VertexType    vexs[MAX_VERTEX_NUM];</span><br><span class="line">    AdjMatrix    arcs;</span><br><span class="line">    <span class="keyword">int</span>            vexnum, arcnum;</span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><h4 id="2-邻接表表示的数据结构"><a href="#2-邻接表表示的数据结构" class="headerlink" title="2). 邻接表表示的数据结构"></a>2). 邻接表表示的数据结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*邻接表表示法*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>                adjvex;</span><br><span class="line">    <span class="keyword">int</span>                w; <span class="comment">// 存储权值，书中的程序没有表示权值的数据成员(书中说用info来存储权值，但是上面的程序又是单独用的adj存权值，为了一致性，info还是用来存储其他信息算了)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>    *<span class="title">nextarc</span>;</span></span><br><span class="line">    InfoType *info; <span class="comment">// 用来存储权值以外的有关弧的信息</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VertexType    data;</span><br><span class="line">    ArcNode        *firstarc;</span><br><span class="line">&#125;VNode, AdjList[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AdjList        vertices;</span><br><span class="line">    <span class="keyword">int</span>            vexnum, arcnum;</span><br><span class="line">    <span class="keyword">int</span>            kind;</span><br><span class="line">&#125;ALGraph;</span><br></pre></td></tr></table></figure><h3 id="2-写出从图的邻接表表示转换成邻接矩阵表示的算法"><a href="#2-写出从图的邻接表表示转换成邻接矩阵表示的算法" class="headerlink" title="2.写出从图的邻接表表示转换成邻接矩阵表示的算法"></a>2.写出从图的邻接表表示转换成邻接矩阵表示的算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Convert</span><span class="params">( ALGraph G, <span class="keyword">int</span> arcs[][<span class="number">10</span>] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.vexnum; v++ )</span><br><span class="line">        <span class="keyword">for</span> ( ArcNode* p = G.vertices[v].firstarc; p; p-&gt;nextarc )</span><br><span class="line">            arcs[v][p-&gt;adjvex] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-图的遍历"><a href="#二-图的遍历" class="headerlink" title="二.图的遍历"></a>二.图的遍历</h2><blockquote><p>说明: 以下图的算法既可以使用邻接矩阵的方式也可以使用邻接表存储的方式,因此每种算法都可以换成另一种存储形式,只需要把MGraph(邻接矩阵存储)换成ALGraph(邻接表存储)即可</p></blockquote><h3 id="1-寻找邻接点"><a href="#1-寻找邻接点" class="headerlink" title="1. 寻找邻接点"></a>1. 寻找邻接点</h3><h4 id="1-邻接矩阵下-通用找邻接的函数"><a href="#1-邻接矩阵下-通用找邻接的函数" class="headerlink" title="1). 邻接矩阵下,通用找邻接的函数:"></a>1). 邻接矩阵下,通用找邻接的函数:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个邻居</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstNeighbor</span><span class="params">( MGraph G, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++ )</span><br><span class="line">        <span class="keyword">if</span> ( G.arcs[v][i] == <span class="number">1</span> )</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前的下一个邻居</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextNeighbor</span><span class="params">( MGraph G, <span class="keyword">int</span> v, <span class="keyword">int</span> w )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = w+<span class="number">1</span>; i &lt; G.vexnum; i++ )</span><br><span class="line">        <span class="keyword">if</span> ( G.arcs[v][i] == <span class="number">1</span> )</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-邻接表下-通用找邻接的函数"><a href="#2-邻接表下-通用找邻接的函数" class="headerlink" title="2). 邻接表下,通用找邻接的函数:"></a>2). 邻接表下,通用找邻接的函数:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*全局变量*/</span></span><br><span class="line"><span class="keyword">bool</span> Visited[MAX_VERTEX_NUM]; <span class="comment">// 记录每个顶点是否被访问过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到第一个v相邻的顶点，返回它的下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstAdjVex</span><span class="params">(ALGraph &amp;AL, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ArcNode *p = <span class="literal">NULL</span>;</span><br><span class="line">    p = AL.vertices[v].firstarc;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;adjvex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到下一个与v相邻的顶点，返回它的下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextAdjVex</span><span class="params">(ALGraph &amp;AL, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ArcNode *p = <span class="literal">NULL</span>;</span><br><span class="line">    p = AL.vertices[v].firstarc;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;adjvex != w) <span class="comment">// 找到下标为w的结点</span></span><br><span class="line">        p = p-&gt;nextarc;</span><br><span class="line">    p = p-&gt;nextarc; <span class="comment">// 指针指向下标为w的结点的后面一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;adjvex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-遍历方法-BFS-DFS"><a href="#2-遍历方法-BFS-DFS" class="headerlink" title="2. 遍历方法(BFS+DFS)"></a>2. 遍历方法(BFS+DFS)</h3><h4 id="1-广度优先搜索-Breadth-First-Search-BFS"><a href="#1-广度优先搜索-Breadth-First-Search-BFS" class="headerlink" title="1). 广度优先搜索(Breadth-First-Search, BFS)"></a>1). 广度优先搜索(Breadth-First-Search, BFS)</h4><blockquote><p>法一:采用邻接矩阵</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MAX_VERTEX_NUM] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">( MGraph G, <span class="keyword">int</span> v )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">( MGraph G )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Q[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.vexnum; v++ )</span><br><span class="line">        <span class="keyword">if</span> ( !visited[v] )</span><br><span class="line">            BFS( G, v );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">( MGraph G, <span class="keyword">int</span> v )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Q[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// BFS顶点三连</span></span><br><span class="line">    visit( v );</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    Q[++rear] = v;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ( front != rear )</span><br><span class="line">    &#123;</span><br><span class="line">        v = Q[++front];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> w = FirstNeighbor( G, v ); w &gt;= <span class="number">0</span>; w = NextNeighbor( G, v, w ) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[w])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// BFS顶点三连</span></span><br><span class="line">                visit( w );</span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">                Q[++rear] = w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>法二:采用邻接表</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MAX_VERTEX_NUM] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">( ALGraph G, <span class="keyword">int</span> v )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">( ALGraph G )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Q[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.vexnum; v++ )</span><br><span class="line">        <span class="keyword">if</span> ( !visited[v] )</span><br><span class="line">            BFS( G, v );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">( ALGraph G, <span class="keyword">int</span> v )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Q[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// BFS顶点三连</span></span><br><span class="line">    visit( v );</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    Q[++rear] = v;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ( front != rear )</span><br><span class="line">    &#123;</span><br><span class="line">        v = Q[++front];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> w = FirstNeighbor( G, v ); w &gt;= <span class="number">0</span>; w = NextNeighbor( G, v, w ) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[w])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// BFS顶点三连</span></span><br><span class="line">                visit( w );</span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">                Q[++rear] = w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-深度优先搜索-Depth-First-Search-DFS"><a href="#2-深度优先搜索-Depth-First-Search-DFS" class="headerlink" title="2). 深度优先搜索(Depth-First-Search, DFS)"></a>2). 深度优先搜索(Depth-First-Search, DFS)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MAX_VERTEX_NUM] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">( ALGraph &amp;G, <span class="keyword">int</span> v )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">( ALGraph &amp;G )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.vexnum; v++ )</span><br><span class="line">        <span class="keyword">if</span> ( !visited[v] )</span><br><span class="line">            DFS( G, v );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">( ALGraph &amp;G, <span class="keyword">int</span> v )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    visit( v );</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> w = FirstNeighbor( G, v ); w &gt;= <span class="number">0</span>; w = NextNeighbor( G, v, w ) )</span><br><span class="line">        <span class="keyword">if</span> ( !visited[w] )</span><br><span class="line">            DFS( G, w );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-综合算法"><a href="#三-综合算法" class="headerlink" title="三.综合算法"></a>三.综合算法</h2><h4 id="1-BFS算法求解单源最短路径问题"><a href="#1-BFS算法求解单源最短路径问题" class="headerlink" title="1. BFS算法求解单源最短路径问题"></a>1. BFS算法求解单源最短路径问题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MAXSIZE] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> d[MAXSIZE] = &#123; INFINITE &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS_MIN_Distance</span><span class="params">( ALGraph G, <span class="keyword">int</span> u )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTree Q[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>, v, w;</span><br><span class="line">    <span class="comment">// BFS路径三连</span></span><br><span class="line">    d[u] = <span class="number">0</span>;</span><br><span class="line">    visited[u] = <span class="literal">true</span>;</span><br><span class="line">    Q[++rear] = u;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ( front != rear )</span><br><span class="line">    &#123;</span><br><span class="line">        v = Q[++front];</span><br><span class="line">        <span class="keyword">for</span> ( w = FirstNeighbor( G, v ); w &gt;= <span class="number">0</span>; w = NextNeighbor( G, v, w ) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[w])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// BFS路径三连</span></span><br><span class="line">                d[w] = d[v] + <span class="number">1</span>;</span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">                Q[++rear] = w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-设计一个算法-判断一个无向图G是否为一棵树"><a href="#2-设计一个算法-判断一个无向图G是否为一棵树" class="headerlink" title="2.设计一个算法,判断一个无向图G是否为一棵树"></a>2.设计一个算法,判断一个无向图G是否为一棵树</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> visited[MAXSIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">( MGraph G, <span class="keyword">int</span> v, <span class="keyword">int</span>&amp; Vnum, <span class="keyword">int</span>&amp; TD )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsTree</span><span class="params">( MGraph G )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Vnum = <span class="number">0</span>, TD = <span class="number">0</span>;    <span class="comment">// TD=total degree总度数</span></span><br><span class="line">    DFS( G, <span class="number">0</span>, Vnum, TD );    <span class="comment">// 从第一个顶点开始遍历</span></span><br><span class="line">    <span class="keyword">if</span> ( Vnum == G.vexnum&amp;&amp;TD == <span class="number">2</span> * ( G.vexnum - <span class="number">1</span> ) )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">( MGraph G, <span class="keyword">int</span> v, <span class="keyword">int</span>&amp; Vnum, <span class="keyword">int</span>&amp; TD )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>; Vnum++;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> w = FirstNeighbor( G, v ); w &gt;= <span class="number">0</span>; w = NextNeighbor( G, v, w ) )</span><br><span class="line">        <span class="keyword">if</span> ( !visited[w] )</span><br><span class="line">            DFS( G, w, Vnum, TD );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-写出图的深度优先搜索DFS算法的非递归算法"><a href="#3-写出图的深度优先搜索DFS算法的非递归算法" class="headerlink" title="3.写出图的深度优先搜索DFS算法的非递归算法"></a>3.写出图的深度优先搜索DFS算法的非递归算法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MAXSIZE] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_NON_RC</span><span class="params">( MGraph G, <span class="keyword">int</span> v )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> S[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++ )</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 顶点二连</span></span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    S[++top] = v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( top != <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        v = S[top--]; </span><br><span class="line">        visit( v );</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> w = FirstNeighbor( G, v ); w &gt;= <span class="number">0</span>; w = NextNeighbor( G, v, w ) )</span><br><span class="line">            <span class="keyword">if</span> ( !visited[w] )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 顶点二连</span></span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">                S[++top] = w;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-分别采用基于广度优先遍历和深度优先遍历算法判别以邻接表或邻接矩阵存储的有向图中是否存在由顶点v到顶点u的路径-v≠u"><a href="#4-分别采用基于广度优先遍历和深度优先遍历算法判别以邻接表或邻接矩阵存储的有向图中是否存在由顶点v到顶点u的路径-v≠u" class="headerlink" title="4.分别采用基于广度优先遍历和深度优先遍历算法判别以邻接表或邻接矩阵存储的有向图中是否存在由顶点v到顶点u的路径(v≠u)"></a>4.分别采用基于广度优先遍历和深度优先遍历算法判别以邻接表或邻接矩阵存储的有向图中是否存在由顶点v到顶点u的路径(v≠u)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用BFS的方法</span></span><br><span class="line"><span class="keyword">bool</span> visited[MAXSIZE] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Exist_Path_BFS</span><span class="params">( MGraph G, <span class="keyword">int</span> v, <span class="keyword">int</span> u )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Q[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    Q[++rear] = v;</span><br><span class="line">    <span class="keyword">while</span> ( front != rear )</span><br><span class="line">    &#123;</span><br><span class="line">        v = Q[++front];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> w = FirstNeighbor( G, v ); w &gt;= <span class="number">0</span>; w = NextNeighbor( G, v, w ) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[w])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( w == u ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">                Q[++rear] = w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用DFS的方法</span></span><br><span class="line"><span class="keyword">bool</span> visited[MAXSIZE] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Exist_Path_DFS</span><span class="params">( MGraph G, <span class="keyword">int</span> v, <span class="keyword">int</span> u )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( v == u ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> w = FirstNeighbor( G, v ); w &gt;= <span class="number">0</span>; w = NextNeighbor( G, v, w ) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !visited[w] )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( Exist_Path_DFS( G, w, u ) ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-拓扑排序-判断并输出有向图的拓扑序列"><a href="#5-拓扑排序-判断并输出有向图的拓扑序列" class="headerlink" title="5.拓扑排序:判断并输出有向图的拓扑序列"></a>5.拓扑排序:判断并输出有向图的拓扑序列</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Topological</span><span class="params">( MGraph G, <span class="keyword">int</span> indegree[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> S[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>, Vnum = <span class="number">0</span>, v = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( v = <span class="number">0</span>; v &lt; G.vexnum; v++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( indegree[v] == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            visit( v );</span><br><span class="line">            Vnum++;</span><br><span class="line">            S[++top] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( top != <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        v = S[top--];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> w = FirstNeighbor( G, v ); w &gt;= <span class="number">0</span>; w = NextNeighbor( G, v, w ) )</span><br><span class="line">        &#123;</span><br><span class="line">            indegree[w]--;</span><br><span class="line">            <span class="keyword">if</span> ( indegree[w] == <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                visit( w );</span><br><span class="line">                Vnum++;</span><br><span class="line">                S[++top] = w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( Vnum == G.vexnum )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-拓扑排序-DFS-有向无环图的拓扑排序"><a href="#6-拓扑排序-DFS-有向无环图的拓扑排序" class="headerlink" title="6.拓扑排序(DFS):有向无环图的拓扑排序"></a>6.拓扑排序(DFS):有向无环图的拓扑排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MAXSIZE] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> time = <span class="number">0</span>, finishTime[MAXSIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">( MGraph G, <span class="keyword">int</span> v )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Topological_DFS</span><span class="params">( MGraph G )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.vexnum; v++ )</span><br><span class="line">        <span class="keyword">if</span> ( !visited[v] )</span><br><span class="line">            DFS( G, v );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> t = time - <span class="number">1</span>; t &gt;= <span class="number">0</span>; t-- )</span><br><span class="line">        visit( finishTime[t] );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">( MGraph G, <span class="keyword">int</span> v )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> w = FirstNeighbor( G, v ); w &gt;= <span class="number">0</span>; w = NextNeighbor( G, v, w ) )</span><br><span class="line">        <span class="keyword">if</span> ( !visited[w] )</span><br><span class="line">            DFS( G, w );</span><br><span class="line">    finishTime[time++] = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-图的算法&quot;&gt;&lt;a href=&quot;#一-图的算法&quot; class=&quot;headerlink&quot; title=&quot;一.图的算法&quot;&gt;&lt;/a&gt;一.图的算法&lt;/h2&gt;&lt;h3 id=&quot;1-邻接矩阵和邻接表的表示&quot;&gt;&lt;a href=&quot;#1-邻接矩阵和邻接表的表示&quot; class=&quot;he
      
    
    </summary>
    
      <category term="algorithm" scheme="https://brianyi.github.io/categories/algorithm/"/>
    
    
      <category term="图" scheme="https://brianyi.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>[algorithm]查找</title>
    <link href="https://brianyi.github.io/2019/05/07/algorithm-%E6%9F%A5%E6%89%BE/"/>
    <id>https://brianyi.github.io/2019/05/07/algorithm-查找/</id>
    <published>2019-05-07T09:11:18.000Z</published>
    <updated>2019-05-07T09:29:57.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-查找的算法"><a href="#一-查找的算法" class="headerlink" title="一.查找的算法"></a>一.查找的算法</h2><h3 id="1-折半查找-二分查找"><a href="#1-折半查找-二分查找" class="headerlink" title="1.折半查找(二分查找)"></a>1.折半查找(二分查找)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">( <span class="built_in">string</span> s, <span class="keyword">char</span> ch )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = s.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = ( low + high ) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ( ch ==  s[mid] )</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( ch &lt; s[mid] )</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度: $O(log_2{n})$</p><h3 id="3-折半查找-二分查找-递归"><a href="#3-折半查找-二分查找-递归" class="headerlink" title="3.折半查找(二分查找)递归"></a>3.折半查找(二分查找)递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search_rc</span><span class="params">( <span class="built_in">string</span> s, <span class="keyword">char</span> ch, <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( low &gt; high ) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = ( low + high ) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ( ch == s[mid] ) </span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( ch &lt; s[mid] )  </span><br><span class="line">        high = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        low = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> binary_search_rc( s, ch, low, high );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度: $O(log_2{n})$</p><hr><h2 id="二-字符串匹配"><a href="#二-字符串匹配" class="headerlink" title="二.字符串匹配"></a>二.字符串匹配</h2><h3 id="1-简单的模式匹配算法-朴素模式匹配算法"><a href="#1-简单的模式匹配算法-朴素模式匹配算法" class="headerlink" title="1.简单的模式匹配算法(朴素模式匹配算法)"></a>1.简单的模式匹配算法(朴素模式匹配算法)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">naive_search</span><span class="params">( <span class="built_in">string</span> S, <span class="built_in">string</span> T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, lenS = S.size(), lenT = T.size();</span><br><span class="line">    <span class="keyword">while</span> ( i &lt; lenS &amp;&amp; j &lt; lenT )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( S[i] == T[j] ) &#123; i++; j++; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; i = i - j + <span class="number">1</span>; j = <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( j &gt;= lenS ) <span class="keyword">return</span> i - lenT;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度: $O(m*n)$</p><h3 id="2-KMP算法"><a href="#2-KMP算法" class="headerlink" title="2.KMP算法"></a>2.KMP算法</h3><p>算法需要先求出模式串的next值:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">( <span class="built_in">string</span> T, <span class="keyword">int</span> next[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>, lenT = T.size();</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;lenT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">-1</span>||T[i]==T[j] )</span><br><span class="line">        &#123;</span><br><span class="line">            i++; j++; next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可求出改进后的nextval值:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_nextval</span><span class="params">( <span class="built_in">string</span> T, <span class="keyword">int</span> nextval[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>, lenT = T.size();</span><br><span class="line">    nextval[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> ( i &lt; lenT )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( j == <span class="number">-1</span> || T[i] == T[j] )</span><br><span class="line">        &#123;</span><br><span class="line">            i++, j++;</span><br><span class="line">            <span class="keyword">if</span> ( T[i] == T[j] )</span><br><span class="line">                nextval[i] = nextval[j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextval[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j = nextval[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是KMP算法:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">( <span class="built_in">string</span> S, <span class="built_in">string</span> T, <span class="keyword">int</span> next[], <span class="keyword">int</span> pos )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = pos, j = <span class="number">0</span>, lenS = S.size(), lenT = T.size();</span><br><span class="line">    <span class="keyword">while</span> ( i&lt;lenS&amp;&amp;j&lt;lenT )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( j == <span class="number">-1</span> || S[i] == T[j] ) &#123; i++; j++; &#125;</span><br><span class="line">        <span class="keyword">else</span> j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( j &gt;= lenT ) <span class="keyword">return</span> i - lenT;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>时间复杂度: $O(m+n)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-查找的算法&quot;&gt;&lt;a href=&quot;#一-查找的算法&quot; class=&quot;headerlink&quot; title=&quot;一.查找的算法&quot;&gt;&lt;/a&gt;一.查找的算法&lt;/h2&gt;&lt;h3 id=&quot;1-折半查找-二分查找&quot;&gt;&lt;a href=&quot;#1-折半查找-二分查找&quot; class=&quot;he
      
    
    </summary>
    
      <category term="algorithm" scheme="https://brianyi.github.io/categories/algorithm/"/>
    
    
      <category term="查找" scheme="https://brianyi.github.io/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]214.最短回文串</title>
    <link href="https://brianyi.github.io/2019/05/07/leetcode-214-%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>https://brianyi.github.io/2019/05/07/leetcode-214-最短回文串/</id>
    <published>2019-05-07T04:00:26.000Z</published>
    <updated>2019-05-07T09:10:32.826Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/07/leetcode-214-最短回文串/Image21.png"><h3 id="方法一-KMP算法"><a href="#方法一-KMP算法" class="headerlink" title="方法一: KMP算法"></a>方法一: KMP算法</h3><p>时间复杂度: $O(m+n)$</p><blockquote><p>解题思路: 实际就是求原串从左到右的最长回文串(必须包含左边所有字符),此处采用<strong>倒置+KMP算法</strong>来缩短匹配时间</p><ol><li>将字符串倒置,原串作为模式串pat,倒置串作为主串txt</li><li>求出模式串pat的nextval[]值,然后进行字符串匹配,得到的模式串pat最长匹配长度即为模式串pat从第一个字符开始的最大回文串(匹配过程时间复杂度只需要$O(m+n)$)</li></ol></blockquote><p>对于<strong>KMP(Knuth–Morris–Pratt)</strong>算法,可以借鉴关于[查找][1]部分的介绍</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nextval[<span class="number">40005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_nextval</span><span class="params">(<span class="built_in">string</span> pat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">-1</span>,len=pat.size();</span><br><span class="line">    nextval[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;i&lt;len&amp;&amp;j&lt;len;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">-1</span>||pat[i]==pat[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++,j++;</span><br><span class="line">            <span class="keyword">if</span> (pat[i]==pat[j])</span><br><span class="line">                nextval[i]=nextval[j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextval[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j=nextval[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="built_in">string</span> txt)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> pat=txt;</span><br><span class="line">    reverse(txt.begin(),txt.end()); <span class="comment">// 字符串倒置</span></span><br><span class="line">    get_nextval(pat); <span class="comment">// 计算模式串的nextval值</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,lenTxt=txt.size(),lenPat=pat.size();</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;lenTxt&amp;&amp;j&lt;lenPat;)   <span class="comment">// 进行模式串匹配,找出最大匹配长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">-1</span>||txt[i]==pat[j])</span><br><span class="line">            i++,j++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = nextval[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> txt.substr(<span class="number">0</span>,lenTxt-j)+pat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/07/leetcode-214-最短回文串/Image21.png&quot;&gt;
&lt;h3 id=&quot;方法一-KMP算法&quot;&gt;&lt;a href=&quot;#方法一-KMP算法&quot; class=&quot;headerlink&quot; title=&quot;方法一: KMP算法&quot;&gt;&lt;/a&gt;方法一
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="回文串" scheme="https://brianyi.github.io/tags/%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    
      <category term="KMP" scheme="https://brianyi.github.io/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]TOC汇总</title>
    <link href="https://brianyi.github.io/2019/05/07/leetcode-TOC%E6%B1%87%E6%80%BB/"/>
    <id>https://brianyi.github.io/2019/05/07/leetcode-TOC汇总/</id>
    <published>2019-05-07T00:31:49.000Z</published>
    <updated>2019-05-08T09:03:29.701Z</updated>
    
    <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="请输入文章密码" />    <label for="pass">请输入文章密码</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      文章内容已被加密.&lt;/br&gt;
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="TOC" scheme="https://brianyi.github.io/tags/TOC/"/>
    
  </entry>
  
  <entry>
    <title>[algorithm]排序</title>
    <link href="https://brianyi.github.io/2019/05/06/algorithm-%E6%8E%92%E5%BA%8F/"/>
    <id>https://brianyi.github.io/2019/05/06/algorithm-排序/</id>
    <published>2019-05-06T14:58:06.000Z</published>
    <updated>2019-05-06T15:23:31.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-排序算法"><a href="#一-排序算法" class="headerlink" title="一.排序算法"></a>一.排序算法</h2><h3 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h3><h4 id="1-直接插入排序-插入类"><a href="#1-直接插入排序-插入类" class="headerlink" title="1) 直接插入排序:(插入类)"></a>1) 直接插入排序:(插入类)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( R[i].key &lt; R[i - <span class="number">1</span>].key )</span><br><span class="line">        &#123;</span><br><span class="line">            R[<span class="number">0</span>] = R[i];</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; <span class="number">0</span> &amp;&amp; ( R[<span class="number">0</span>].key &lt; R[j].key ); j-- )</span><br><span class="line">                R[j + <span class="number">1</span>] = R[j];</span><br><span class="line">            R[j + <span class="number">1</span>] = R[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况(顺序有序):</p><p>　　1)比较次数: $\sum_{i=2}^{n} 1=n-1$</p><p>　　2)移动次数: 0</p><p>最坏情况(逆序有序):</p><p>　　1)比较次数: $\sum_{i=2}^{n} i=\frac {(n+2)(n-1)}{2}$</p><p>　　2)移动次数: $\sum_{i=2}^{n} (i+1)=\frac {(n+4)(n-1)}{2}$</p><h4 id="2-折半插入排序-插入类"><a href="#2-折半插入排序-插入类" class="headerlink" title="2)折半插入排序:(插入类)"></a>2)折半插入排序:(插入类)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BiInsertSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        R[<span class="number">0</span>] = R[i];</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>, high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( low &lt;= high )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = ( low + high ) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ( R[<span class="number">0</span>].key &lt; R[m].key ) high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; high; j-- )</span><br><span class="line">            R[j + <span class="number">1</span>] = R[j];</span><br><span class="line">        R[j + <span class="number">1</span>] = R[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-希尔排序-又称缩小增量排序-插入类"><a href="#3-希尔排序-又称缩小增量排序-插入类" class="headerlink" title="3)希尔排序(又称缩小增量排序)(插入类)"></a>3)希尔排序(又称缩小增量排序)(插入类)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当dk=1时,即为直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> dk = n / <span class="number">2</span>; dk &gt;= <span class="number">1</span>; dk /= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = dk + <span class="number">1</span>; i &lt;= n; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( R[i].key &lt; R[i - dk].key )</span><br><span class="line">            &#123;</span><br><span class="line">                R[<span class="number">0</span>] = R[i];</span><br><span class="line">            <span class="keyword">for</span> ( j = i - dk; j &gt; <span class="number">0</span> &amp;&amp; ( R[<span class="number">0</span>].key &lt; R[j].key ); j -= dk )</span><br><span class="line">                    R[j + dk] = R[j];</span><br><span class="line">                R[j + dk] = R[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-交换排序"><a href="#2-交换排序" class="headerlink" title="2.交换排序"></a>2.交换排序</h3><h4 id="1-起泡排序-冒泡排序-交换类"><a href="#1-起泡排序-冒泡排序-交换类" class="headerlink" title="1)起泡排序(冒泡排序)(交换类)"></a>1)起泡排序(冒泡排序)(交换类)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = n; j &gt; i; j-- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (R[j].key &lt; R[j<span class="number">-1</span>].key )</span><br><span class="line">            &#123;</span><br><span class="line">                swap( R[j], R[j - <span class="number">1</span>] );</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( !flag ) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-快速排序-交换类"><a href="#2-快速排序-交换类" class="headerlink" title="2)快速排序:(交换类)"></a>2)快速排序:(交换类)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Partition</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快排</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( low &gt;= high ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivotpos = Partition( R, low, high );</span><br><span class="line">    QuickSort( R, low, pivotpos - <span class="number">1</span> );</span><br><span class="line">    QuickSort( R, pivotpos + <span class="number">1</span>, high );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 划分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Partition</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElemType pivot = R[low];</span><br><span class="line">    <span class="keyword">while</span> ( low &lt; high )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high &amp;&amp; R[high].key &gt;= pivot.key ) high--;</span><br><span class="line">        R[low] = R[high];</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high &amp;&amp; R[low].key &lt;= pivot.key ) low++;</span><br><span class="line">        R[high] = R[low];</span><br><span class="line">    &#125;</span><br><span class="line">    R[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3.选择排序"></a>3.选择排序</h3><h4 id="1-简单选择排序-选择类"><a href="#1-简单选择排序-选择类" class="headerlink" title="1)简单选择排序(选择类)"></a>1)简单选择排序(选择类)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( R[j].key &lt; R[min].key ) min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( min != i ) swap( R[i], R[min] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-堆排序-选择类"><a href="#2-堆排序-选择类" class="headerlink" title="2)堆排序(选择类)"></a>2)堆排序(选择类)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">( ElemType R[], <span class="keyword">int</span> s, <span class="keyword">int</span> n )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt; <span class="number">0</span>; i-- )</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">( R, i, n )</span></span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; i-- )</span><br><span class="line">    &#123;</span><br><span class="line">        swap( R[i], R[<span class="number">1</span>] );</span><br><span class="line">        AdjustDown( R, <span class="number">1</span>, i - <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">( ElemType R[], <span class="keyword">int</span> s, <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    R[<span class="number">0</span>] = R[s];</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span> * s; i &lt;= n; i *= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( i &lt; n&amp;&amp;R[i].key &lt; R[i + <span class="number">1</span>].key ) i++;</span><br><span class="line">        <span class="keyword">if</span> (R[<span class="number">0</span>].key  &gt;=R[i].key ) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            R[s] = R[i]; s = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    R[s] = R[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向上调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustUp</span><span class="params">( ElemType R[], <span class="keyword">int</span> s )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    R[<span class="number">0</span>] = R[s];</span><br><span class="line">    <span class="keyword">int</span> p = s / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> ( p &gt;&amp;&amp; R[p].key &lt; R[<span class="number">0</span>].key )</span><br><span class="line">    &#123;</span><br><span class="line">        R[s] = R[p];</span><br><span class="line">        s = p;</span><br><span class="line">        p /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    R[s] = R[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-归并排序-归并类"><a href="#4-归并排序-归并类" class="headerlink" title="4.归并排序(归并类)"></a>4.归并排序(归并类)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( low &gt;= high ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = ( low + high ) / <span class="number">2</span>;</span><br><span class="line">    MergeSort( R, low, mid );</span><br><span class="line">    MergeSort( R, mid + <span class="number">1</span>, high );</span><br><span class="line">    Merge( R, low, mid, high );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElemType B[MAXSIZE];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span> ( i = low; i &lt;= high; i++ )</span><br><span class="line">        B[i] = R[i];</span><br><span class="line">    i = k = low, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ( i &lt;= mid &amp;&amp; j &lt;= high )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( B[i].key &lt;= B[j].key )</span><br><span class="line">            R[k++] = B[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            R[k++] = B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( i &lt;= mid ) R[k++] = B[i++];</span><br><span class="line">    <span class="keyword">while</span> ( j &lt;= high ) R[k++] = B[j++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-综合题-算法"><a href="#二-综合题-算法" class="headerlink" title="二.综合题(算法)"></a>二.综合题(算法)</h2><p>1.设顺序表用数组R[]表示,表中存储在数组下标1~m+n的范围内,前m个元素递增有序,后n个元素递增有序,设计一个算法,使得整个顺序表有序<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">( ElemType R[], <span class="keyword">int</span> m, <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = m + <span class="number">1</span>; i &lt;= m + n; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( R[i].key &lt; R[i - <span class="number">1</span>].key )</span><br><span class="line">        &#123;</span><br><span class="line">            R[<span class="number">0</span>] = R[i];</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; <span class="number">0</span> &amp;&amp; ( R[<span class="number">0</span>].key &lt; R[j].key ); j-- )</span><br><span class="line">                R[j + <span class="number">1</span>] = R[j];</span><br><span class="line">            R[j + <span class="number">1</span>] = R[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.计数排序:对表进行排序并将结果放到另一个新的表中,要求表中所有关键码互不相同<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountSort</span><span class="params">( ElemType A[], ElemType B[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++ )</span><br><span class="line">            <span class="keyword">if</span> ( A[i].key &gt; A[j].key )cnt++;</span><br><span class="line">        B[cnt] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.双向冒泡排序<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思想:第一趟通过交换把最大的放最后,第二趟通过交换把最小的放最前,反复进行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">( ElemType A[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = n - <span class="number">1</span>, i;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> ( low &lt; high &amp;&amp; flag )</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = low; i &lt; high; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i]&gt;A[i+<span class="number">1</span>] )</span><br><span class="line">            &#123;</span><br><span class="line">                swap( A[i], A[i + <span class="number">1</span>] ); flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high--;</span><br><span class="line">        <span class="keyword">for</span> ( i = high; i &gt; low; i-- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( A[i] &lt; A[i - <span class="number">1</span>] )</span><br><span class="line">            &#123;</span><br><span class="line">                swap( A[i], A[i - <span class="number">1</span>] ); flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        low++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.单链表的简单选择排序(假设不带表头结点)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">( LinkList&amp; L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList h, p, s, pre, r;</span><br><span class="line">    h = L;</span><br><span class="line">    <span class="keyword">while</span> ( h )</span><br><span class="line">    &#123;</span><br><span class="line">        p = s = h; pre = r = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 找最大结点s</span></span><br><span class="line">        <span class="keyword">while</span> ( p )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;data&gt;s-&gt;data )</span><br><span class="line">            &#123;</span><br><span class="line">                s = p; r = pre;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 脱链</span></span><br><span class="line">        <span class="keyword">if</span> ( s == h ) h = h-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> r-&gt;next = s-&gt;next;</span><br><span class="line">        <span class="comment">// 头插法</span></span><br><span class="line">        s-&gt;next = L; L = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5.顺序表中有n个不同整数(下标1~n),设计算法把所有奇数移动到偶数前面(时,空都最少)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">( ElemType A[], <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">1</span>, high = n;</span><br><span class="line">    <span class="keyword">while</span> ( low &lt; high )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high&amp;&amp;A[low] % <span class="number">2</span> ) low++;</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high &amp;&amp; A[high] % <span class="number">2</span> == <span class="number">0</span> ) high--;</span><br><span class="line">        <span class="keyword">if</span> ( low &lt; high )</span><br><span class="line">        &#123;</span><br><span class="line">            swap( A[low], A[high] );</span><br><span class="line">            low++; high--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6.在顺序表中找出第k小的元素(时空最少)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思想:划分</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = R[low];</span><br><span class="line">    <span class="keyword">while</span> ( low &lt; high )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high &amp;&amp; R[high].key &gt;= pivot.key ) high--;</span><br><span class="line">        R[low] = R[high];</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high&amp;&amp; R[low].key &lt;= pivot.key ) low++;</span><br><span class="line">            R[high] = R[low];</span><br><span class="line">    &#125;</span><br><span class="line">    R[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">Kth_elem</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> k )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivotpos = Partition( R, low, high );</span><br><span class="line">    <span class="keyword">if</span> ( pivotpos == k ) <span class="keyword">return</span> R[pivotpos];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( pivotpos &gt; k ) <span class="keyword">return</span> Kth_elem( R, low, pivotpos - <span class="number">1</span>, k );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Kth_elem( R, pivotpos + <span class="number">1</span>, high, k );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>7.n个正整数构成的集合A,将其划分为两个不相交的子集$A1,A2$,元素个数分别是n1和n2.A1和A2中元素之和分别为S1和S2.设计一个时空高效算法,使|n1-n2|最小且|s1-s1|最大.(下标从1开始)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">( ElemType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = R[low];</span><br><span class="line">    <span class="keyword">while</span> ( low &lt; high )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high &amp;&amp; R[high].key &gt;= pivot.key ) high--;</span><br><span class="line">        R[low] = R[high];</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high&amp;&amp; R[low].key &lt;= pivot.key ) low++;</span><br><span class="line">        R[high] = R[low];</span><br><span class="line">    &#125;</span><br><span class="line">    R[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetPartition</span><span class="params">( ElemType R[], <span class="keyword">int</span> n, <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = n / <span class="number">2</span>, s1, s2, i;</span><br><span class="line">    <span class="keyword">int</span> pivotpos = Partition( R, low, high );</span><br><span class="line">    <span class="keyword">if</span> ( pivotpos == k )</span><br><span class="line">    &#123;</span><br><span class="line">        s1 = s2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt;= k; i++ ) s1 += R[i];</span><br><span class="line">        <span class="keyword">for</span> ( j = k + <span class="number">1</span>; j &lt;= n; j++ ) s2 += R[j];</span><br><span class="line">        <span class="keyword">return</span> s2 - s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( pivotpos &gt; k )</span><br><span class="line">        <span class="keyword">return</span> SetPartition( R, n, low, pivotpos - <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> SetPartition( R, n, pivotpos + <span class="number">1</span>, high );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-排序算法&quot;&gt;&lt;a href=&quot;#一-排序算法&quot; class=&quot;headerlink&quot; title=&quot;一.排序算法&quot;&gt;&lt;/a&gt;一.排序算法&lt;/h2&gt;&lt;h3 id=&quot;1-插入排序&quot;&gt;&lt;a href=&quot;#1-插入排序&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="algorithm" scheme="https://brianyi.github.io/categories/algorithm/"/>
    
    
      <category term="排序" scheme="https://brianyi.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]133.克隆图</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-133-%E5%85%8B%E9%9A%86%E5%9B%BE/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-133-克隆图/</id>
    <published>2019-05-06T13:21:48.000Z</published>
    <updated>2019-05-06T13:27:25.958Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-133-克隆图/453425-20190430181854853-2091334093.png"><h3 id="方法一-dfs-递归"><a href="#方法一-dfs-递归" class="headerlink" title="方法一:dfs(递归)"></a>方法一:dfs(递归)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;Node*,Node*&gt; dict;</span><br><span class="line"><span class="function">Node* <span class="title">clone</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> node;</span><br><span class="line">    <span class="keyword">if</span> (dict.count(node)) <span class="keyword">return</span> dict[node];</span><br><span class="line">    dict[node]=<span class="keyword">new</span> Node(node-&gt;val,<span class="built_in">vector</span>&lt;Node*&gt;&#123;&#125;);　　<span class="comment">// 这里不能写clone(node),会导致死循环,记住,在new的时候千万不要再递归,递归最低层一定有一个明确结果,所以要把截止条件写清楚</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:node-&gt;neighbors)</span><br><span class="line">        dict[node]-&gt;neighbors.push_back(clone(it));</span><br><span class="line">    <span class="keyword">return</span> dict[node];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> clone(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二-dfs-非递归"><a href="#方法二-dfs-非递归" class="headerlink" title="方法二:dfs(非递归)"></a>方法二:dfs(非递归)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;Node*,Node*&gt; dict;</span><br><span class="line"><span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Node*&gt; S;</span><br><span class="line">    S.push(node);</span><br><span class="line">    <span class="keyword">while</span> (!S.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Node *p = S.top();</span><br><span class="line">        S.pop();</span><br><span class="line">        <span class="keyword">if</span> (!dict.count(p))　　<span class="comment">// 从栈中出来的都是没有进行访问过的点</span></span><br><span class="line">            dict[p]=<span class="keyword">new</span> Node(p-&gt;val,<span class="built_in">vector</span>&lt;Node*&gt;&#123;&#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it:p-&gt;neighbors)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dict.count(it))　　<span class="comment">// 判断是否已经访问过该点</span></span><br><span class="line">            &#123;</span><br><span class="line">                dict[it]=<span class="keyword">new</span> Node(it-&gt;val,<span class="built_in">vector</span>&lt;Node*&gt;&#123;&#125;);</span><br><span class="line">                S.push(it);</span><br><span class="line">            &#125;</span><br><span class="line">            dict[p]-&gt;neighbors.push_back(dict[it]);　　<span class="comment">// 将新点的拷贝放入neighbors中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dict[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-133-克隆图/453425-20190430181854853-2091334093.png&quot;&gt;
&lt;h3 id=&quot;方法一-dfs-递归&quot;&gt;&lt;a href=&quot;#方法一-dfs-递归&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="dfs" scheme="https://brianyi.github.io/tags/dfs/"/>
    
      <category term="图" scheme="https://brianyi.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]138.复制带随机指针的链表</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-138-复制带随机指针的链表/</id>
    <published>2019-05-06T13:20:18.000Z</published>
    <updated>2019-05-06T14:43:56.130Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-138-复制带随机指针的链表/453425-20190430193735900-662137168.png"><h3 id="方法一-递归"><a href="#方法一-递归" class="headerlink" title="方法一:递归"></a>方法一:递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;Node*,Node*&gt; dict;</span><br><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">if</span> (dict.count(head)) <span class="keyword">return</span> dict[head];</span><br><span class="line">    dict[head]=<span class="keyword">new</span> Node(head-&gt;val, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    dict[head]-&gt;next=copyRandomList(head-&gt;next);</span><br><span class="line">    dict[head]-&gt;random=copyRandomList(head-&gt;random);</span><br><span class="line">    <span class="keyword">return</span> dict[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二-非递归"><a href="#方法二-非递归" class="headerlink" title="方法二:非递归"></a>方法二:非递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;Node*,Node*&gt; m;</span><br><span class="line">    Node *p=head;</span><br><span class="line">    <span class="keyword">while</span>(p)    <span class="comment">// make a copy of nodes</span></span><br><span class="line">    &#123;</span><br><span class="line">        m[p]=<span class="keyword">new</span> Node(p-&gt;val,<span class="literal">nullptr</span>,<span class="literal">nullptr</span>);</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p=head;</span><br><span class="line">    <span class="keyword">while</span>(p)    <span class="comment">// link everyone and fill the random field</span></span><br><span class="line">    &#123;</span><br><span class="line">        m[p]-&gt;next=m[p-&gt;next];</span><br><span class="line">        m[p]-&gt;random=m[p-&gt;random];</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-138-复制带随机指针的链表/453425-20190430193735900-662137168.png&quot;&gt;
&lt;h3 id=&quot;方法一-递归&quot;&gt;&lt;a href=&quot;#方法一-递归&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="链表" scheme="https://brianyi.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]144.二叉树的前序遍历</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-144-二叉树的前序遍历/</id>
    <published>2019-05-06T13:17:07.000Z</published>
    <updated>2019-05-06T13:19:44.482Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-144-二叉树的前序遍历/453425-20190501113746021-447522744.png"><p>前往二叉树的:前序,中序,后序 遍历算法</p><h3 id="方法一-递归"><a href="#方法一-递归" class="headerlink" title="方法一:递归"></a>方法一:递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    res.push_back(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) preorderTraversal(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right) preorderTraversal(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二-非递归"><a href="#方法二-非递归" class="headerlink" title="方法二:非递归"></a>方法二:非递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">    TreeNode* p = root;</span><br><span class="line">    <span class="keyword">while</span>(p||!S.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p)  <span class="comment">// 访问左子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(p-&gt;val);</span><br><span class="line">            S.push(p);</span><br><span class="line">            p=p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">// 访问右子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=S.top();</span><br><span class="line">            S.pop();</span><br><span class="line">            p=p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三-非递归-该方法可用于后序遍历-需要修改几处代码"><a href="#方法三-非递归-该方法可用于后序遍历-需要修改几处代码" class="headerlink" title="方法三:非递归(该方法可用于后序遍历,需要修改几处代码)"></a>方法三:非递归(该方法可用于后序遍历,需要修改几处代码)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">    S.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!S.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        root=S.top();</span><br><span class="line">        S.pop();</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) S.push(root-&gt;right);  <span class="comment">// 要实现后序遍历,需要以下两行调换</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) S.push(root-&gt;left);</span><br><span class="line">        res.push_back(root-&gt;val);   <span class="comment">// res.insert(0,root-&gt;val)即为后序遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论:</p><ul><li>方法三这种形式只适合前序和后序遍历,不适合中序遍历,中序遍历较为麻烦</li><li>方法二这种形式只适合前序和中序遍历,不适合后序遍历,后序遍历较为麻烦</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-144-二叉树的前序遍历/453425-20190501113746021-447522744.png&quot;&gt;
&lt;p&gt;前往二叉树的:前序,中序,后序 遍历算法&lt;/p&gt;
&lt;h3 id=&quot;方法一-递归&quot;&gt;&lt;a href=&quot;#方
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="树" scheme="https://brianyi.github.io/tags/%E6%A0%91/"/>
    
      <category term="递归" scheme="https://brianyi.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]94.二叉树的中序遍历</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-94-二叉树的中序遍历/</id>
    <published>2019-05-06T13:14:44.000Z</published>
    <updated>2019-05-06T14:20:07.345Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-94-二叉树的中序遍历/453425-20190501120139941-1568037684.png"><p>前往二叉树的:<a href>前序</a>,<a href>中序</a>,<a href>后序</a> 遍历算法</p><h3 id="方法一-递归"><a href="#方法一-递归" class="headerlink" title="方法一:递归"></a>方法一:递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) inorderTraversal(root-&gt;left);      </span><br><span class="line">    res.push_back(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right) inorderTraversal(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二-非递归"><a href="#方法二-非递归" class="headerlink" title="方法二:非递归"></a>方法二:非递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">    TreeNode* p = root;</span><br><span class="line">    <span class="keyword">while</span>(p||!S.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            S.push(p);</span><br><span class="line">            p=p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=S.top();</span><br><span class="line">            S.pop();</span><br><span class="line">            res.push_back(p-&gt;val);</span><br><span class="line">            p=p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-94-二叉树的中序遍历/453425-20190501120139941-1568037684.png&quot;&gt;
&lt;p&gt;前往二叉树的:&lt;a href&gt;前序&lt;/a&gt;,&lt;a href&gt;中序&lt;/a&gt;,&lt;a href&gt;后序&lt;/a&gt; 
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="树" scheme="https://brianyi.github.io/tags/%E6%A0%91/"/>
    
      <category term="递归" scheme="https://brianyi.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]145.二叉树的后序遍历</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-145-二叉树的后序遍历/</id>
    <published>2019-05-06T13:12:06.000Z</published>
    <updated>2019-05-06T13:14:29.228Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-145-二叉树的后序遍历/453425-20190501122117295-85727166.png"><p>前往二叉树的:前序,中序,后序 遍历算法</p><h3 id="方法一-递归"><a href="#方法一-递归" class="headerlink" title="方法一:递归"></a>方法一:递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) postorderTraversal(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right) postorderTraversal(root-&gt;right);</span><br><span class="line">    res.push_back(root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二-非递归"><a href="#方法二-非递归" class="headerlink" title="方法二:非递归"></a>方法二:非递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">    TreeNode* p=root, *r=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (p||!S.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            S.push(p);</span><br><span class="line">            p=p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=S.top();</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right&amp;&amp;p-&gt;right!=r)</span><br><span class="line">                p=p-&gt;right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                S.pop();</span><br><span class="line">                res.push_back(p-&gt;val);</span><br><span class="line">                r=p;</span><br><span class="line">                p=<span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="方法三-非递归"><a href="#方法三-非递归" class="headerlink" title="方法三:非递归"></a>方法三:非递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">    TreeNode* p=root;</span><br><span class="line">    S.push(p);</span><br><span class="line">    <span class="keyword">while</span> (!S.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        p=S.top();</span><br><span class="line">        S.pop();</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;left) S.push(p-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right) S.push(p-&gt;right);</span><br><span class="line">        res.insert(res.begin(),p-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-145-二叉树的后序遍历/453425-20190501122117295-85727166.png&quot;&gt;
&lt;p&gt;前往二叉树的:前序,中序,后序 遍历算法&lt;/p&gt;
&lt;h3 id=&quot;方法一-递归&quot;&gt;&lt;a href=&quot;#方法
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="树" scheme="https://brianyi.github.io/tags/%E6%A0%91/"/>
    
      <category term="递归" scheme="https://brianyi.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]968.监控二叉树</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-968-监控二叉树/</id>
    <published>2019-05-06T13:08:13.000Z</published>
    <updated>2019-05-06T13:11:46.627Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-968-监控二叉树/453425-20190501230642291-677698823.png"><p>解题思路: 由于叶子节点一定不要安装监视器,这样才能使总监视器数量比较少,因此需要从下往上进行判断当前节点的状态(共:3种状态):</p><ul><li>0: 当前节点安装了监视器</li><li>1: 当前节点可观,但没有安装监视器</li><li>2: 当前节点不可观<br>对于空节点,我们认为是可观,但没有安装监视器,因此,叶子节点就为不可观的了,设想一个节点的左右孩子(为空)都可观且没有安装监视器,那该节点必然是不可观即2</li></ul><p>有了以上对空节点和叶子节点的处理,我们再来正式分析非终端节点:</p><ul><li>若一个节点的左孩子或右孩子不可观,那么该节点必然不可观,需要安装监视器,因此返回0状态</li><li>若一个节点的左孩子或右孩子都可观且至少有一个安装了监视器,那么该节点必然是可观的,返回1状态</li><li>若一个节点的左右孩子都可观且没安装监视器,那么该节点必然是不可观的,返回2状态<br>记住,我们以上的分析都是基于从整个二叉树的叶子节点往根部,即从下往上进行,而且要做的就是将不可观的节点变得可观才行(因此要根据左右孩子的节点的状态来判断当前节点状态并做出调整)</li></ul><p>这里可能会有疑惑,以上的第一条得出当前节点不可观,然后安装了监视器,而第三条也得出当前节点不可观,但却没有安装监视器,而是直接返回的2状态(当前节点不可观).这是为什么?</p><p>因为,对于第一条,因为左右孩子都不可观,为了让左右孩子都可观,则必须给当前节点安装监视器才行,而第三条中,左右孩子都是可观的(没有安装监视器),当前节点的可以直接返回不可观状态,因为后面可以由他的父节点进行摄像头安装,使其变得可观.</p><h3 id="方法一-递归"><a href="#方法一-递归" class="headerlink" title="方法一:递归"></a>方法一:递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0：该节点安装了监视器 1：该节点可观，但没有安装监视器 2：该节点不可观</span></span><br><span class="line"><span class="keyword">int</span> monitor = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">state</span><span class="params">(TreeNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left  = state(node-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> right = state(node-&gt;right);</span><br><span class="line">    <span class="comment">// 该节点为0的情况</span></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">2</span> || right == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        monitor++;  <span class="comment">// 由于左或右节点不可观,则需要给当前节点安装监视器,为0状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="comment">// 为1的情况</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="number">0</span> || right == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">// 当(left!=2&amp;&amp;right!=2)时,才会进行该判断,也就是左右节点一定是可观的,再判断是否有一个安装了监视器,如有安装,则当前节点就不需要安装监视器也可观了,为1状态</span></span><br><span class="line">    <span class="comment">// 为2的情况</span></span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">// 其他:党(left!=2&amp;&amp;right!=2)&amp;&amp;(left!=0&amp;&amp;right!=0),即left==1&amp;&amp;right==1时,左右节点都可观,但没有监视器,当前节点不可观,为2状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (state(root) == <span class="number">2</span>) monitor++;    <span class="comment">// 如果根节点为2的状态,需要加一个监视器</span></span><br><span class="line">    <span class="keyword">return</span> monitor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:这里的if,else if,else的顺序是不能变的,先判断左右都是不可观的,再就是都可观,左或右至少有一个为监视器,最后才是都可观都无监视器.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-968-监控二叉树/453425-20190501230642291-677698823.png&quot;&gt;
&lt;p&gt;解题思路: 由于叶子节点一定不要安装监视器,这样才能使总监视器数量比较少,因此需要从下往上进行判断当前节点的状
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="dp" scheme="https://brianyi.github.io/tags/dp/"/>
    
      <category term="二叉树" scheme="https://brianyi.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]106.从中序与后序遍历序列构造二叉树</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-106-从中序与后序遍历序列构造二叉树/</id>
    <published>2019-05-06T12:16:02.000Z</published>
    <updated>2019-05-06T13:27:31.595Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-106-从中序与后序遍历序列构造二叉树/453425-20190502213938801-1912607084.png"><p>前往 中序,后序遍历构造二叉树, 中序,前序遍历构造二叉树<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> l1, <span class="keyword">int</span> r1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;postorder, <span class="keyword">int</span> l2, <span class="keyword">int</span> r2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1&gt;r1) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> x = postorder[r2], i = <span class="number">0</span>;   <span class="comment">// 确定当前根节点</span></span><br><span class="line">    <span class="keyword">for</span> (i = l1; i &lt;= r1 &amp;&amp; inorder[i] != x; ++i);  <span class="comment">// 在中序遍历序列中找到当前根节点位置(该位置可以划分出左右两个分支)</span></span><br><span class="line">    <span class="keyword">int</span> llen = i - l1;  <span class="comment">// 左子树结点数量</span></span><br><span class="line">    <span class="keyword">int</span> rlen = r1 - i;  <span class="comment">// 右子树结点数量</span></span><br><span class="line">    TreeNode* p = <span class="keyword">new</span> TreeNode(x);  <span class="comment">// 建立根节点</span></span><br><span class="line">    p-&gt;left = build(inorder, l1, l1 + llen - <span class="number">1</span>, postorder, l2, l2 + llen - <span class="number">1</span>);  <span class="comment">// 递归建立左子树,-1,-1是把当前根节点位置去掉</span></span><br><span class="line">    p-&gt;right = build(inorder, r1 - rlen + <span class="number">1</span>, r1, postorder, r2 - rlen, r2 - <span class="number">1</span>); <span class="comment">// 递归建立右子树,+1,-1是把当前根节点位置去掉</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inorder.empty()||postorder.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> build(inorder, <span class="number">0</span>, inorder.size() - <span class="number">1</span>, postorder, <span class="number">0</span>, postorder.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-106-从中序与后序遍历序列构造二叉树/453425-20190502213938801-1912607084.png&quot;&gt;
&lt;p&gt;前往 中序,后序遍历构造二叉树, 中序,前序遍历构造二叉树&lt;br&gt;&lt;figure cla
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="树" scheme="https://brianyi.github.io/tags/%E6%A0%91/"/>
    
      <category term="递归" scheme="https://brianyi.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]105.从前序与中序遍历序列构造二叉树</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-105-从前序与中序遍历序列构造二叉树/</id>
    <published>2019-05-06T12:14:01.000Z</published>
    <updated>2019-05-06T12:15:26.558Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-105-从前序与中序遍历序列构造二叉树/453425-20190502215802448-663626721.png"><p>前往 中序,后序遍历构造二叉树, 中序,前序遍历构造二叉树<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> l1, <span class="keyword">int</span> r1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> l2, <span class="keyword">int</span> r2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1&gt;r1) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> x=preorder[l1], i=<span class="number">0</span>;    <span class="comment">// 确定当前根节点</span></span><br><span class="line">    <span class="keyword">for</span>(i=l2;inorder[i]!=x&amp;&amp;i&lt;r2;++i);  <span class="comment">// 在中序遍历序列中找到当前根节点位置(该位置可以划分出左右两个分支)</span></span><br><span class="line">    <span class="keyword">int</span> llen=i-l2;  <span class="comment">// 左子树结点数量</span></span><br><span class="line">    <span class="keyword">int</span> rlen=r2-i;  <span class="comment">// 右子树结点数量</span></span><br><span class="line">    TreeNode *p = <span class="keyword">new</span> TreeNode(x);  <span class="comment">// 建立根节点</span></span><br><span class="line">    p-&gt;left = build(preorder, l1+<span class="number">1</span>, l1+llen, inorder, l2, l2+llen<span class="number">-1</span>);   <span class="comment">// 递归建立左子树,+1,-1是把当前根节点位置去掉</span></span><br><span class="line">    p-&gt;right= build(preorder, r1-rlen+<span class="number">1</span>, r1, inorder, r2-rlen+<span class="number">1</span>, r2);   <span class="comment">// 递归建立右子树,+1,+1是把当前根节点位置去掉</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.size()<span class="number">-1</span>, inorder, <span class="number">0</span>, inorder.size()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-105-从前序与中序遍历序列构造二叉树/453425-20190502215802448-663626721.png&quot;&gt;
&lt;p&gt;前往 中序,后序遍历构造二叉树, 中序,前序遍历构造二叉树&lt;br&gt;&lt;figure clas
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="树" scheme="https://brianyi.github.io/tags/%E6%A0%91/"/>
    
      <category term="递归" scheme="https://brianyi.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]114.二叉树展开为链表</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-114-二叉树展开为链表/</id>
    <published>2019-05-06T12:12:04.000Z</published>
    <updated>2019-05-06T12:13:26.706Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-114-二叉树展开为链表/453425-20190502231706813-609020347.png"><p>思路:递归,将左子树变成单链表形式,再将右子树变成单链表形式,最后将左子树单链表的末端连接到右子树单链表表头,将根节点的左孩子置空</p><h3 id="方法一-递归"><a href="#方法一-递归" class="headerlink" title="方法一: 递归"></a>方法一: 递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    flatten(root-&gt;left);    <span class="comment">// 将左子树变成单链表形式</span></span><br><span class="line">    flatten(root-&gt;right);   <span class="comment">// 将右子树变成单链表形式</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) <span class="comment">// 将左子树单链表的末端连接到右子树单链表表头</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* p=root-&gt;left;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;right) p=p-&gt;right;</span><br><span class="line">        p-&gt;right=root-&gt;right;</span><br><span class="line">        root-&gt;right=root-&gt;left;</span><br><span class="line">        root-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-114-二叉树展开为链表/453425-20190502231706813-609020347.png&quot;&gt;
&lt;p&gt;思路:递归,将左子树变成单链表形式,再将右子树变成单链表形式,最后将左子树单链表的末端连接到右子树单链表
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="树" scheme="https://brianyi.github.io/tags/%E6%A0%91/"/>
    
      <category term="递归" scheme="https://brianyi.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode]239.滑动窗口最大值</title>
    <link href="https://brianyi.github.io/2019/05/06/leetcode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>https://brianyi.github.io/2019/05/06/leetcode-239-滑动窗口最大值/</id>
    <published>2019-05-06T12:10:15.000Z</published>
    <updated>2019-05-06T12:11:33.534Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/06/leetcode-239-滑动窗口最大值/453425-20190503094513334-1691572073.png"><p>思路:滑动窗口的思想,只要是求连续子序列或者子串问题,都可用滑动窗口的思想</p><h3 id="方法一-滑动窗口"><a href="#方法一-滑动窗口" class="headerlink" title="方法一: 滑动窗口"></a>方法一: 滑动窗口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (nums.size()==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;　　</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;nums.size();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!dq.empty()&amp;&amp;nums[i]&gt;nums[dq.back()]) <span class="comment">//在尾部添加元素，并保证左边元素都比尾部大</span></span><br><span class="line">            dq.pop_back();</span><br><span class="line">        dq.push_back(i);</span><br><span class="line">        <span class="keyword">if</span> (i-k==dq.front())    <span class="comment">//在头部移除元素</span></span><br><span class="line">            dq.pop_front();</span><br><span class="line">        <span class="keyword">if</span> (i&gt;=k<span class="number">-1</span>)</span><br><span class="line">            res.push_back(nums[dq.front()]);    <span class="comment">// 存放每次窗口内的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/06/leetcode-239-滑动窗口最大值/453425-20190503094513334-1691572073.png&quot;&gt;
&lt;p&gt;思路:滑动窗口的思想,只要是求连续子序列或者子串问题,都可用滑动窗口的思想&lt;/p&gt;
&lt;h3 id=&quot;方法
      
    
    </summary>
    
      <category term="OJ" scheme="https://brianyi.github.io/categories/OJ/"/>
    
    
      <category term="leetcode" scheme="https://brianyi.github.io/tags/leetcode/"/>
    
      <category term="滑动窗口" scheme="https://brianyi.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
</feed>
