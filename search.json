[{"title":"[leetcode]34. 在排序数组中查找元素的第一个和最后一个位置","url":"%2Fposts%2Fe8124129%2F","content":"{% asset_img 2019051919134438.png %}\n\n### 解题思路 \n已知题目数组为有序,且要求算法时间复杂度$O(log_2n)$那么明显是二分查找\n首先,进行二分查找,找到元素后进行左遍历找到目标值的开始位置,右遍历找到目标值的结束位置\n### 代码实现 \n```cpp\nvector<int> searchRange(vector<int>& nums, int target) {\n    int len=nums.size();\n    int l=0,r=len-1,idx=-1;\n    while(l<=r)\n    {\n        int m=(l+r)>>1;\n        if (nums[m]==target)\n        {\n            idx=m;\n            break;\n        }\n        else if (nums[m]<target)\n            l=m+1;\n        else\n            r=m-1;\n    }\n    if (idx==-1)\n        return vector<int>{-1,-1};\n    l=r=idx;\n    while(l-1>=0&&nums[l-1]==target) --l;   // 这里比较巧妙,先判断越界,再判断值相等,最后进行移位\n    while(r+1<len&&nums[r+1]==target) ++r;\n    return vector<int>{l,r};\n}\n```\n### 结论\n题目比较简单,记录一下","tags":["二分查找"],"categories":["OJ"]},{"title":"[leetcode]10. 正则表达式匹配","url":"%2Fposts%2F886a4a97%2F","content":"{% asset_img 2019051917403936.png %}\n\n### 解题思路 \n{% asset_img 2019051917424837.png %}\n算法时间复杂度$O(m*n)$\n### 代码实现 \n```cpp\nint dp[500][500];\nbool isMatch(string s, string p) {\n\ts.insert(s.begin(), '#');\n\tp.insert(p.begin(), '#');\n\tif (p.size()==1 && s.size()==1) return true;\n\tint len_s = s.size()-1;\n\tint len_p = p.size()-1;\n\n\t// s为空,p为#*#*#*... ,匹配\n\tdp[0][0] = 1;   // s=空,p=空,必然匹配\n\tfor (int j = 1; j <= len_p; ++j)\n\t\tif (p[j] == '*'&&dp[0][j - 2])\n\t\t\tdp[0][j] = 1;\n\n\n\tfor (int i = 1; i <= len_s; ++i)\n\t{\n\t\tfor (int j = 1; j <= len_p; ++j)\n\t\t{\n\t\t\tif (p[j] == s[i] || p[j] == '.')  // p[j]是字符且能匹配s[i],则结果取决于前面j-1个长度串\n\t\t\t\tdp[i][j] = dp[i - 1][j - 1];\n\t\t\tif (p[j] == '*')\n\t\t\t{\n\t\t\t\tif (p[j - 1] != s[i] && p[j - 1] != '.')\t// 前面为字母且不等于s[i],那么#*就算作空,则匹配长度由dp[i][j-2]决定\n\t\t\t\t\tdp[i][j] = dp[i][j - 2];\n\t\t\t\telse // 前面字符(可以为.)与s[i]相匹配,则*表示至少一次(>=1),这里不明白(硬记吧)\n\t\t\t\t\tdp[i][j] = (dp[i][j - 1] || dp[i][j - 2] || dp[i - 1][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[len_s][len_p];\n}\n```\n### 结论\n这道题有些难,不愧是困难级别的,平时正则也用得多,但没想到实现起来如此难","tags":["dp"],"categories":["OJ"]},{"title":"[english]idiomatic expression","url":"%2Fposts%2F381dde6d%2F","content":"### The birds and the bees\n\"The birds and the bees\" is an English-language idiomatic expression and euphemism that refers to courtship and sexual intercourse. The \"Birds and the Bees talk\" is generally the event in most children's lives in which the parents explain what sexual relationships are.\n### Casabianca\n\"Casabianca\" is a poem by the English poet Felicia Dorothea Hemans, first published in The Monthly Magazine, Vol 2, August 1826.[1]\nThe poem starts:\nThe boy stood on the burning deck\nWhence all but he had fled;\nThe flame that lit the battle's wreck\nShone round him o'er the dead.\nThe poem commemorates an actual incident that occurred in 1798 during the Battle of the Nile aboard the French ship Orient. The young son Giocante (his age is variously given as ten, twelve and thirteen) of commander Louis de Casabianca remained at his post and perished when the flames caused the magazine to explode.","tags":["idiomatic expression"],"categories":["english"]},{"title":"[book]<<机器学习实战>>第3章 决策树","url":"%2Fposts%2F49e197e8%2F","content":"### 决策树的含义\n顾名思义,用于进行决策的一种树状结构\n{% asset_img 2019051819365621.png %}\n\n### 决策树创建的伪代码\n```python\n    def createBranch():\n        检测数据集中的每个子项是否属于同一分类:\n            If so return 类标签\n            Else\n                寻找划分数据集的最好特征\n                划分数据集\n                创建分支节点\n                    for每个划分的子集\n                        调用函数createBranch并增加返回结果到分直节点中\n                return 分支结点\n```\n\n### 信息增益\n- **自信息**: 在信息论中,自信息(英语：self-information),由**克劳德·香农**提出,是与概率空间中的单一事件或离散随机变量的值相关的信息量的量度.自信息的期望值就是信息论中的**熵**,它反映了随机变量采样时的平均不确定程度.\n  在机器学习中,如果待分类的事物可能划分在多个分类之中,则符号$x_i$的自信息定义为\n    $$I(X)=-log_2{p(x_i)}$$\n    $p(x_i)$是选择该分类的概率\n- 熵或香农熵(entropy): 熵定义为自信息的期望值,即度量数据的无序(混乱)程度,**越乱则熵越大,越纯则熵越小**,公式为 \n  $$H(X)=\\sum_{i=1}^n p(x_i)I(x_i)=-\\sum_{i=1}^n p(x_i)log p(x_i)$$\n    {% asset_img Binary_entropy_plot.svg.png %}\n- 条件熵: 定义时间$X$与$Y$分别取$x_i$和$y_j$时的条件熵为\n  $$H(X|Y)=\\sum_jp(y_j)H(X|Y=y_j)=-\\sum_{i,j}p(x_i,y_j)log{\\displaystyle \\frac{p(x_i,y_j)}{p(y_j)}}=-\\sum_{i,j}p(x_i,y_j)log{p(x_i|y_j)}$$\n  其中$p(x_i,y_j)$为$X=x_i$且$Y=y_j$时的概率.这个量应理解为在你知道$Y$值的条件下,随机变量$X$的条件熵值\n  > **引申**: 发现一篇写得非常好的文章,可以借鉴下[详解机器学习中的熵、条件熵、相对熵和交叉熵](http://www.cnblogs.com/kyrieng/p/8694705.html)\n- 计算数据的香农熵\n    ```python\n    def calcShannonEnt(dataSet):\n        '''\n        :param dataSet: 数据集\n        :return shannonEnt: 香农熵值\n        '''\n        numEntries = len(dataSet)   # 获取数据集总数\n        classCounts = {}    # 字典存放每个类别对应数据集的数量\n        for featVec in dataSet:\n            currentClass = featVec[-1]  # 获取类别值\n            if currentClass not in classCounts.keys():\n                classCounts[currentClass] = 0\n            classCounts[currentClass] += 1\n        shannonEnt = 0.0\n        for key in classCounts:\n            prob = float(classCounts[key])/numEntries\n            shannonEnt += -prob * log(prob,2)\n        return shannonEnt\n    ```\n- 实验\n  我们实验一下是否数据集越纯,熵值越小,数据集越乱,熵值越大\n  ```python\n  def createDataSet():\n    dataSet = [[1, 1, 'yes'],\n              [1, 1, 'yes'],\n              [1, 0, 'no'],\n              [0, 1, 'no'],\n              [0, 1, 'no']]\n    labels = ['no surfacing','flippers']\n    return dataSet, labels\n    \n    >>> dataSet,labels = createDataSet()    # 获取数据集和特征标签\n    >>> calcShannonEnt(dataSet) # 计算香农熵\n    0.9709505944546686\n  ```\n  我们试试如果让数据集变纯会怎样?\n  ```python\n    >>> dataSet[0][-1]=dataSet[1][-1]='no';dataSet\n    [[1, 1, 'no'], [1, 1, 'no'], [1, 0, 'no'], [0, 1, 'no'], [0, 1, 'no']]\n    >>> calcShannonEnt(dataSet) # 计算香农熵\n    0.0\n  ```\n  果然变小了,再试试数据集变乱?\n  ```python\n    >>> dataSet[1][-1]='yes';dataSet[2][-1]='possible';dataSet[3][-1]='impossible';dataSet[4][-1]='may';dataSet\n    [[1, 1, 'no'],\n    [1, 1, 'yes'],\n    [1, 0, 'possible'],\n    [0, 1, 'impossible'],\n    [0, 1, 'may']]\n    >>> calcShannonEnt(dataSet) # 计算香农熵\n    2.321928094887362\n  ```\n  变得非常大了\n### 划分数据集\n- 根据给定特征划分数据集\n  当我们按照某个特征划分数据集时,就需要将所有符合要求的元素抽取出来\n  ```python\n    def splitDataSet(dataSet, axis, value):\n        '''\n        :param dataSet: 待划分的数据集\n        :param axis: 划分数据集的特征\n        :param value: 特征值\n        :return retDataSet: 返回划分后的数据集\n        '''\n        retDataSet = []\n        for featVec in dataSet:\n            if featVec[axis] == value:  # 只选择包含选定特征值的数据集\n                reducedFeatVec = featVec[:axis] # 该行及下一行将选定数据集的选定特征值去掉(即用于下轮其他特征值的划分)\n                reducedFeatVec.extend(featVec[axis+1:])\n                retDataSet.append(reducedFeatVec)\n        return retDataSet\n  ```\n  下面用图来说明上面函数**splitDataSet**的用途\n  {% asset_img 2019051911283026.png %}\n  这是一个根据特征(是否浮出水面(No sufacting), 是否有鳍(Filppers))来判断是否是鱼类(Fish)的决策图,已有5个数据集数据,我们来将数据进行划分,看是否符合图示\n  首先构造图中数据集\n  {% asset_img 2019051911325428.png %}\n  根据**No surfacing**特征来划分数据\n  - **No(0)**\n    {% asset_img 2019051911385529.png %}\n    可以发现分类结果都为no,即不是鱼,因此纯度已经很高,无需再划分了\n  - **Yes(1)**\n    {% asset_img 2019051911392930.png %}\n    结果中仍然有不同类别,有yes,有no,因此还可以根据下一个特征继续划分\n    从数据集中排除已经划分过的特征,从剩下的数据集中的特征继续划分\n    {% asset_img 2019051911410131.png %}\n    根据Flippers特征又可以继续划分数据\n    - **No(0)**\n    {% asset_img 2019051911412932.png %}\n    - **Yes(1)**\n    {% asset_img 2019051911415033.png %}\n- 选择最好的数据集划分方式\n  每一次划分都选择当前信息增益最大的特征进行划分\n  ```python\n    def chooseBestFeatureToSplit(dataSet):\n        '''\n        :param dataSet: 数据集\n        :return bestFeature: 返回获取信息增益最大的特征索引\n        '''\n        numFeatures = len(dataSet[0]) - 1 # 获取总特征数量(减1是去掉尾部的分类标签值)\n        baseEntropy = calcShannonEnt(dataSet)   # 计算未划分数据时的香农熵(或熵)\n        bestInfoGain = 0.0\n        bestFeature = -1\n        for i in range(numFeatures):    # 计算按每一个特征进行划分时,所得到的信息增益,并选取能得到最大信息增益的特征\n            featList = [example[i] for example in dataSet]  # 获取第i个特征的所有特征值\n            uniqueVals = set(featList)  # 特征值去重\n            newEntropy = 0.0\n            for value in uniqueVals:    # 计算按该特征划分后的香农熵\n                subDataSet = splitDataSet(dataSet, i, value)\n                prob = len(subDataSet)/float(len(dataSet))\n                newEntropy += prob * calcShannonEnt(subDataSet)\n            infoGain = baseEntropy - newEntropy # 计算信息增益\n            if infoGain > bestInfoGain: # 选取最大的信息增益,和特征\n                bestInfoGain = infoGain\n                bestFeature = i\n        return bestFeature\n  ```\n### 递归构造决策树\n- 介绍\n  从原始数据集中,基于最好的特征(即**信息增益最大,从混乱到越纯的程度越高**)划分数据集,每一个分支都是根据一个特征的数据划分,在该分支下的子分支都将不再包含该特征(因为前门已经根据该特征划分过了),每次划分,子分支也可能有多个($\\ge 2$),划分的数据将传递到子分支上(利用信息增益作为特征划分的依据,越划分则下面分支上的数据越少也就越纯),因此我们可以采用递归的原则处理数据集\n  **递归结束的条件**(满足**任意一个**):\n    - 程序遍历完所有划分数据集的特征(若叶节点不纯则采用多数表决策略)    $\\quad (1)$\n    - 每个分支下的数据都是相同的分类(比如上图示的叶节点)    $\\quad (2)$\n- 多数表决策略\n  有时候,我们在划分数据时,已经遍历完了所有特征,但叶节点上的类标签依然不是唯一的,此时我们可以采取多数表决的策略,也就是少数服从多数,选择类别较多的那个类标签作为该叶节点的分类\n  > 上述情况易发生在特征少,而数据量较多的情况\n  ```python\n    def majorityCnt(classList):\n        '''\n        :param classList: 数据集类别列表\n        :return sortedClassCount[0][0]: 返回出现次数最多的类别\n        '''\n        classCount = {}\n        for vote in classList:  # 字典存储每个类别的数据集数量\n            if vote in classCount.keys():\n                classCount[vote] = 0\n            classCount[vote] += 1\n        sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True) # 根据类别出现次数来排序(逆序),出现次数最多的为第一个\n        return sortedClassCount[0][0]   # 返回出现次数最多的类别\n  ```\n- 递归构造决策树代码\n  ```python\n    def createTree(dataSet, labels):\n        '''\n        :param dataSet: 数据集\n        :param labels: 特征标签\n        '''\n        classList = [example[-1] for example in dataSet]    # 获取数据集对应的类别\n        if classList.count(classList[0]) == len(classList): # 检测到数据集已为同一类别,满足递归结束的条件$(2)$,终止递归\n            return classList[0]\n        if len(dataSet[0]) == 1:    # 遍历完所有特征,满足递归结束的条件$(1)$,终止递归\n            return majorityCnt(classList)\n        bestFeat = chooseBestFeatureTo\n  ```\n### 总结\n- 信息公式$l(x_i)=-log_2p(x_i)$\n- 熵\n  信息熵,香农熵(因为是香农发明的),熵都是一个东西,用于表示数据的混乱程度,**越混乱,熵越大,越纯,熵越小**\n  公式 $H(X)$\n- 信息增益\n  也就是熵的变化\n  信息增益为正表示:数据集从混乱变纯了\n  信息增益为负表示:数据集从纯变混乱了\n  而决策树中一般选择","tags":["机器学习实战"],"categories":["book"]},{"title":"[numpy]notes","url":"%2Fposts%2Ffd60ea9b%2F","content":"\n### Numpy\n#### **np.ndarry**\n- **argmax(axis=None, out=None)**\tReturn indices of the maximum values along the given axis.\n- **argmin(axis=None, out=None)**\tReturn indices of the minimum values along the given axis of a.\n- **min(axis=None, out=None, keepdims=False, initial=<no value>, where=True)** Return the minimum along a given axis.\n  - **Examples**\n    axis=0时,在列中选取最小值,axis=1时,在行中选取最小值\n  {% asset_img 2019051819061419.png %}\n#### **np.random**\n- **rand(d0, d1, …, dn)** Random values in a given shape.\n  ```python\n  >>> np.random.rand(3,2)\n  array([[ 0.14022471,  0.96360618],  #random\n          [ 0.37601032,  0.25528411],  #random\n          [ 0.49313049,  0.94909878]]) #random\n  ```\n- **randn(d0, d1, …, dn)** Return a sample (or samples) from the “standard normal” distribution.\n  For random samples from $N(\\mu, \\sigma^2)$, use:\n  `sigma * np.random.randn(...) + mu`\n  Two-by-four array of samples from N(3, 6.25):    \n  ```python\n  >>> 3 + 2.5 * np.random.randn(2, 4)\n  array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random\n     [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random\n  ```\n- **randint(low[, high, size, dtype])**\tReturn random integers from low (inclusive) to high (exclusive).\n  - **Parameters**:\t\n    - **low :** int\n      Lowest (signed) integer to be drawn from the distribution (unless high=None, in which case this parameter is one above the highest such integer).\n    - **high** : int, optional\n      If provided, one above the largest (signed) integer to be drawn from the distribution (see above for behavior if high=None).\n    - **size** : int or tuple of ints, optional\n      Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.\n    - **dtype** : dtype, optional\n      Desired dtype of the result. All dtypes are determined by their name, i.e., ‘int64’, ‘int’, etc, so byteorder is not available and a specific precision may have different C types depending on the platform. The default value is ‘np.int’.\n      New in version 1.11.0.    \n  - **Returns:**\t\n      **out** : int or ndarray of ints\n      size-shaped array of random integers from the appropriate distribution, or a single such random int if size not provided.\n  - **Examples**\n    ```python\n      >>> np.random.randint(5, size=(2, 4))\n      array([[4, 0, 2, 1], # random\n              [3, 2, 2, 0]])\n    ```\n- **shuffle(x)** Modify a sequence in-place by shuffling its contents.\n  - **Parameters:**\t\n      x : array_like\n      The array or list to be shuffled.\n  - **Returns:**\t\n      None\n  - **Examples**\n      ```python\n      >>> arr = np.arange(10)\n      >>> np.random.shuffle(arr)\n      >>> arr\n      [1 7 5 2 9 4 3 6 0 8] # random\n      ```\n      Multi-dimensional arrays are only shuffled along the first axis:\n      ```python\n      >>> arr = np.arange(9).reshape((3, 3))\n      >>> np.random.shuffle(arr)\n      >>> arr\n      array([[3, 4, 5], # random\n          [6, 7, 8],\n          [0, 1, 2]])\n      ```\n","tags":["notes"],"categories":["numpy"]},{"title":"[book]<<机器学习实战>>第2章 k-近邻算法","url":"%2Fposts%2F75b8f8af%2F","content":"### k-近邻算法概述\nk-近邻算法采用测量不同特征值之间距离进行分类\n- 优点: 精度高,对异常值不敏感,无数据输入假定\n- 缺点: 计算复杂度高,空间复杂度高\n- 使用数据范围: 数值型和标称型\n\n### k-近邻算法的伪代码\n对位未知类别属性的数据集中的每个点依次执行以下操作:\n1. 计算已知类别数据集中的点与当前点之间的距离\n2. 按照距离递增次序排序\n3. 选取与当前点距离最小的k个点\n4. 确定前k个点所在类别的出现频率\n5. 返回前k个点出现频率最高的类别作为当前点的预测分类\n  \n### k-近邻算法核心代码\n```python\ndef classify0(inX, dataSet, labels, k):\n  '''\n  :param inX: 预测数据\n  :param dataSet: 已知数据集\n  :param labels: 已知数据所属标签值\n  :param k: 取前k个点出现频率最高的类别作为当前点的预测分类\n  :return:  \n  '''\n  dataSetSize = dataSet.shape[0]  # 获取一维长度(即样本数量)\n  diffMat = tile(inX, (dataSetSize, 1)) - dataSet # 获取差异矩阵\n  sqDiffMat = diffMat**2  # 取平方\n  sqDistances = sqDiffMat.sum(axis=1) # 二维数据累加,即计算每个点与预测点距离的平方和\n  distances = sqDistances**0.5  # 开根号\n  sortedDistIndicies = distances.argsort()  # 返回排序后的索引值(数据顺序不变)\n  classCount = {}\n  for i in range(k):\n    voteILabel = labels[sortedDistIndicies[i]]\n    classCount[voteILabel] = classCount.get(voteILabel, 0) + 1  #get(key, default): Return the value for key if key is in the dictionary, else default.\n  sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True) # 逆序后选择发生频率最高的标签\n  return sortedClassCount[0][0]\n```\n\n### 特征值归一化\n特征中,有些特征的数字差值对计算结果影响较大,而实际每个特征应当是同等重要的,因此需要进行归一化处理,将数值都转为比重(0.0~1.0)\n公式: $$newValue = \\frac{oldValue-minValue}{maxValue-minValue}$$\n```python\n  def autoNorm(dataSet):\n    minVals = dataSet.min(0)  # 获取各column最小值\n    maxVals = dataSet.max(0)  # 获取各column最大值\n    ranges = maxVals - minVals  # 得到一个范围差矩阵\n    normDataSet = zeros(shape(dataSet)) # 得到一个全零矩阵\n    m = dataSet.shape[0]  # 获取样本数量\n    normDataSet = dataSet - tile(minVals, (m,1)) # 当前值减去最小值\n    normDataSet = normDataSet/tile(ranges, (m,1)) # 计算每个数据所在比重(0.0~1.0)\n    return normDataSet, ranges, minVals\n```\n\n### 小结\nk-近邻算法对于数据量不是很大的情况还是比较适宜的,因为效率不高,不过可以采用建立k-tree的方法来提高搜索效率","tags":["机器学习实战"],"categories":["book"]},{"title":"[book]<<机器学习实战>>第1章 机器学习基础","url":"%2Fposts%2F60021%2F","content":"### 机器学习主要任务\n- 监督学习主要任务: \n  - 分类: 将实例数据划分到合适的类别\n  - 回归: 用于预测数值型数据\n  - 分类和回归属于监督学习,之所以为监督学习,因为算法必须知道预测什么(即已经知道了分类信息)\n- 无监督学习主要任务:\n  - 聚类: 此时数据没有类别信息,也不会给定目标值,将数据集合分成类似的对象组成的多个类的过程称为聚类\n  - 密度估计: 将寻找描述数据统计值的过程称为密度估计\n  \n### 开发机器学习应用程序的步骤\n1. 收集数据: 利用各种方法收集样本数据\n2. 准备输入数据: 得到收集的数据后,必须确保数据格式符合要求\n3. 分析输入数据: 主要是人工分析以前得到的数据. 主要作用是确保数据集中没有垃圾数据(数据为空,或者与其他数据存在明显的差异)\n4. 训练算法: 机器学习算法从这一步才真正开始学习. 如果使用无监督学习算法,由于不存在目标变量值,也就不需要训练算法,则直接到第5步\n5. 测试算法: 对于监督学习,必须已知用于评估算法的目标变量值. 对于无监督学习,必须用其他的评测手段来检验算法的成功率. 不满意算法的输出结果则回到4步改正再测试.\n6. 使用算法: 将机器学习算法转为应用程序.\n\n### 总结\n这一章只是大概讲了一下机器学习的主要任务,即监督学习,无监督学习(应当还有半监督学习),然后就是实施步骤","tags":["机器学习实战"],"categories":["book"]},{"title":"[leetcode]双指针法","url":"%2Fposts%2F54332%2F","content":"### 实战1\n{% asset_img 2019051715574813.png %}\n\n- **解题思路** \n    此题首先想到的当然是暴力破解,需要$O(n^2)$,如果采用双指针法,则需要$O(n)$即可\n    \n- **代码实现** \n    ```cpp\n    int maxArea(vector<int>& height) {\n        int maxarea = 0;\n        int i=0,j=height.size()-1;\n        while(i<j)\n        {\n            maxarea=max(maxarea,min(height[i],height[j])*(j-i));\n            if (height[i]<height[j])    // 高度较小的指针进行移动\n                i++;\n            else\n                j--;\n        }\n        return maxarea;\n    }\n    ```\n    **疑惑**: 高度较小的指针进行移动可以保证答案最大吗,难度不会漏掉其他有可能最大的结果吗?\n    **解答**: 可以用草稿纸画一下,由题意可以知道,面积是由底边宽和最短指针高度决定的,那么如果移动较高指针,情况只可能有两种:\n    - 较高指针的高度变得比较矮指针的高度还小(或等于),那么面积必然比原来小\n    - 较高指针的高度变得比较矮指针的高度大,由于高度还是由较矮指针决定,而底边却比原来短了1,那么面积必然比原来小\n    \n    因此,综上两种情况,只能移动较矮指针才有可能获取到更大的面积\n\n### 实战2\n{% asset_img 2019051716023414.png %}\n\n- **解题思路**\n  先排序$O(nlog_2n)$,然后采用$i\\lt left\\lt right$的方式,固定$i$,然后$left$和$right$进行双指针筛选\n- **代码实现**\n    ```cpp\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());  // 可以用堆排序或其他$(nlog_2n)$的算法\n        int minVal = 0,len=nums.size(),delt=999999;\n        for(int i=0;i<len-2;++i)    // 固定第一个数,后面的数双指针法进行筛选\n        {\n            while(i>0&&i<len-2&&nums[i]==nums[i-1]) ++i;    // i去重\n            int l=i+1,r=len-1;\n            while(l<r)\n            {\n                int sum=nums[i]+nums[l]+nums[r];\n                if (abs(sum-target)<delt)\n                    minVal = sum, delt=abs(sum-target);\n                else\n                {\n                    if (sum-target>0)\n                    {\n                        --r;\n                        while(l<r&&nums[r]==nums[r+1]) --r; // r去重\n                    }\n                    else\n                    {\n                        --l;\n                        while(l<r&&nums[l]==nums[l-1]) ++l; // l去重\n                    }\n                }\n            }\n        }\n        return minVal;\n    }\n    ```\n\n### 实战3\n{% asset_img 2019051719562317.png %}\n\n- **解题思路**\n  先排序$O(nlog_2n)$,然后按照$i\\le j\\le left\\le right$的方法,对$i,j,left,right$进行去重(去重时,应该先加完,判断,再去重),`三数之和,两数之和同理`\n- **代码实现**\n    ```cpp\n        vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        vector<vector<int>> ans;\n        int len=nums.size();\n        sort(nums.begin(),nums.end());\n        for(int i=0;i<len-3;++i)\n        {\n            while(i>0&&i<len-3&&nums[i]==nums[i-1]) i++;    // i去重\n            for (int j=i+1;j<len-2;++j)\n            {\n                while(j>i+1&&j<len-2&&nums[j]==nums[j-1]) j++;  // j去重\n                int l=j+1,r=len-1,sum=target-(nums[i]+nums[j]);\n                while(l<r)\n                {\n                    int diff=nums[l]+nums[r]-sum;\n                    if (diff==0)\n                    {\n                        ans.push_back(vector<int>{nums[i],nums[j],nums[l],nums[r]});\n                        l++,r--;\n                        while(l<r&&nums[l]==nums[l-1]) l++; // l去重\n                        while(l<r&&nums[r]==nums[r+1]) r--; // r去重\n                    }\n                    else if (diff<0)\n                    {\n                        l++;\n                        while(l<r&&nums[l]==nums[l-1]) l++; // l去重\n                    }\n                    else\n                    {\n                        r--;\n                        while(l<r&&nums[r]==nums[r+1]) r--; // r去重\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n    ```","tags":["双指针法"],"categories":["OJ"]},{"title":"[paper 1]Generalized Uncorrelated Regression with Adaptive Graph for Unsupervised Feature Selection","url":"%2Fposts%2F443%2F","content":"\n\n### unknown knowledge\n1. Stiefel manifold\n2. conventional ridge regression model\n3. uncorrelated constraint\n4. closed-form solution\n5. graph regularization term\n6. Generalized uncorrelated constraint\n7. manifold learning\n8. sparsity regularization models\n9. geometrical manifold learning\n10. spectral regression models\n11. Spectral feature selection\n12. l1-regularized regression model\n13. robust nonnegative matrix factorization\n14. local learning\n15. robust feature learning\n16. ridge regression\n17. dimensionality reduction\n18. indicator matrix\n19. subspace learning\n20. embedding-based feature selection method\n21. Graph Regularization\n22. closed-form solution\n23. clustering accuracy\n24. normalized mutual information\n\n### notation\n- **RBF kernel(Radial basis function kernel)**\n  - introduction\n  In machine learning, the radial basis function kernel, or **RBF kernel**, is a popular kernel function used in various kernelized learning algorithms. In particular, it is commonly used in **support vector machine classification**.\n  The **RBF kernel** on two samples x and x', represented as feature vectors in some input space, is defined as $K(\\mathbf x,\\mathbf x')=\\exp(-\\frac{||\\mathbf x-\\mathbf x'||^2}{2\\sigma^2})$\n  $||\\mathbf x-\\mathbf x'||^2$ may be recognized as the squared Euclidean distance between the two feature vectors. $\\sigma$ is a free parameter. An equivalent definition involves a parameter $\\gamma ={\\tfrac {1}{2\\sigma ^{2}}}$: $K(\\mathbf {x} ,\\mathbf {x'} )=\\exp(-\\gamma \\|\\mathbf {x} -\\mathbf {x'} \\|^{2})$\n  Since the value of the **RBF kernel** decreases with distance and ranges between **zero** (in the limit) and **one** (when $\\mathbf {x = x'}$), it has a ready interpretation as a similarity measure.\n  The feature space of the kernel has an infinite number of dimensions; for $\\sigma =1$, its expansion is:\n  {% asset_img c8d959c116119a.svg %}\n\n- **trivial solution**\n  A solution or example that is ridiculously simple and of little interest. Often, solutions or examples involving the number 0 are considered trivial. Nonzero solutions or examples are considered nontrivial.\n  For example, the equation x + 5y = 0 has the trivial solution x = 0, y = 0. Nontrivial solutions include x = 5, y = –1 and x = –2, y = 0.4.\n\n\n> Abstract\n\nby virtue of a generalized uncorrelated constraint, present an improved sparse regression model for seeking the uncorrelated yet discriminative features.\n\n> Introduction\n\nIt is natural that features always have many different clusters and each cluster has a mass of features for high-dimensional data. For example, there are eyes, nose, and mouth features in a face image. Therefore, the selected features with high redundancy lose their diversity and degrade their performance in clustering or classification tasks.\nTo address this problem, we present a generalized uncorre-lated regression model (GURM). Subsequently, an Uncorrelated Regression with Adaptive graph for unsupervised Feature Selection (URAFS) is proposed. The main contributions of this brief are summarized as follows.\n\n\n\n\n> References\n\n## feature selection\n\n### clustering\n[1] F. Nie, X. Wang, and H. Huang, “Clustering and projected clustering\nwith adaptive neighbors,” in Proc. ACM SIGKDD Int. Conf. Knowl.\nDiscovery Data Mining, 2014, pp. 977–986.\n[2] R. Zhang, F. Nie, and X. Li, “Projected clustering via robust orthogonal\nleast square regression with optimal scaling,” in Proc. Int. Joint Conf.\nNeural. Netw., 2017, pp. 2784–2791.\n\n### classification\n[3] J. Gui, T. Liu, D. Tao, Z. Sun, and T. Tan, “Representative vector\nmachines: A unified framework for classical classifiers,” IEEE Trans.\nCybern., vol. 46, no. 8, pp. 1877–1888, Aug. 2016.\n[4] J. Gui, D. Tao, Z. Sun, Y. Luo, X. You, and Y. Y. Tang, “Group\nsparse multiview patch alignment framework with view consistency\nfor image classification,” IEEE Trans. Image Process., vol. 23, no. 7,\npp. 3126–3132, Jul. 2014.\n\n### face recognition\n[5] C. Y. Lu, H. Min, J. Gui, L. Zhu, and Y. K. Lei, “Face recognition\nvia weighted sparse representation,” J. Vis. Commun. Image Represent.,\nvol. 24, no. 2, pp. 111–116, Feb. 2013.\n[6] J.-X. Mi, D. Lei, and J. Gui, “A novel method for recognizing face with\npartial occlusion via sparse representation,” Optik—Int. J. Light Electron\nOpt., vol. 124, no. 24, pp. 6786–6789, 2013.\n\n---\n\n## unsupervised feature selection\n\n### filter-based methods\n[7] X. He, D. Cai, and P. Niyogi, “Laplacian score for feature selection,”\nin Proc. 19th Annu. Conf. Neural Inf. Process. Syst., Vancouver, BC,\nCanada, Dec. 2005, pp. 507–514.\n[8] Z. Zhao and H. Liu, “Spectral feature selection for supervised\nand unsupervised learning,” in Proc. Conf. Mach. Learn., 2007,\npp. 1151–1157.\n[9] M. Qian and C. Zhai, “Robust unsupervised feature selection,” in Proc.\nIJCAI, 2013, pp. 1621–1627.\n\n### wrapper-based methods\n[10] S. Tabakhi, P. Moradi, and F. Akhlaghian, “An unsupervised feature\nselection algorithm based on ant colony optimization,” Eng. Appl. Artif.\nIntell., vol. 32, pp. 112–123, Jun. 2014.\n\n### embedding-based methods(most popular these years) 11-15\n### conventional spectral-based feature selection methods 11-14,17,18,35\n[11] D. Cai, C. Zhang, and X. He, “Unsupervised feature selection for multi￾cluster data,” in Proc. ACM SIGKDD Int. Conf. Knowl. Discovery Data\nMining, 2010, pp. 333–342.\n[12] Z. Zhao, L. Wang, and H. Liu, “Efficient spectral feature selection\nwith minimum redundancy,” in Proc. Nat. Conf. Artif. Intell., 2010,\npp. 673–678.\n[13] C. Hou, F. Nie, X. Li, D. Yi, and Y. Wu, “Joint embedding learning\nand sparse regression: A framework for unsupervised feature selection,”\nIEEE Trans. Cybern., vol. 44, no. 6, pp. 793–804, Jun. 2014.\n[14] Z. Li, Y. Yang, J. Liu, X. Zhou, and H. Lu, “Unsupervised feature\nselection using nonnegative spectral analysis,” in Proc. Nat. Conf. Artif.\nIntell., 2012, pp. 1026–1032.\n[15] S. Wang, J. Tang, and H. Liu, “Embedded unsupervised feature selec￾tion,” in Proc. Nat. Conf. Artif. Intell., 2015, pp. 470–476.\n\n### an overview of recent structured sparsity-inducing feature selection methods(another expression of embedding-based methods)\n[16] J. Gui, Z. Sun, S. Ji, D. Tao, and T. Tan, “Feature selection based on\nstructured sparsity: A comprehensive study,” IEEE Trans. Neural Netw.\nLearn. Syst., vol. 28, no. 7, pp. 1490–1507, Jul. 2017.\n[17] Q. Gu, Z. Li, and J. Han, “Joint feature selection and subspace learning,”\nin Proc. Nat. Conf. Artif. Intell., 2011, pp. 1294–1299.\n[18] H. Liu, M. Shao, and Y. Fu, “Consensus guided unsupervised feature\nselection,” in Proc. Nat. Conf. Artif. Intell., 2012, pp. 1874–1880.\n[19] F. Nie, W. Zhu, and X. Li, “Unsupervised feature selection with\nstructured graph optimization,” in Proc. Nat. Conf. Artif. Intell., 2016,\npp. 1302–1308.\n[20] Y. Yang, H. T. Shen, Z. Ma, Z. Huang, and X. Zhou, “2, 1-norm\nregularized discriminative feature selection for unsupervised learning,”\nin Proc. IJCAI, vol. 22, 2011, p. 1589.\n[21] L. Shi, L. Du, and Y.-D. Shen, “Robust spectral learning for unsuper￾vised feature selection,” in Proc. IEEE Conf. Data Mining, Dec. 2014,\npp. 977–982.\nIEEE TRANSACTIONS ON NEURAL NETWORKS AND LEARNING SYSTEMS 1595\n[22] J. Gui, Z. Sun, W. Jia, R. Hu, Y. Lei, and S. Ji, “Discrimi\u0002nant sparse neighborhood preserving embedding for face recognition,”\nPattern Recognit., vol. 45, no. 8, pp. 2884–2893, 2012.\n[23] W. Karush, “Minima of functions of several variables with inequalities\nas side constraints,” M.S. thesis, Dept. Math., Univ. Chicago, Ghicago,\nIL, USA, 1939.\n[24] J. Huang, F. Nie, H. Huang, and C. Ding, “Robust manifold nonnegative\nmatrix factorization,” ACM Trans. Knowl. Discovery Data, vol. 8, no. 3,\n2014, Art. no. 11.\n[25] F. Nie, R. Zhang, and X. Li, “A generalized power iteration method for\nsolving quadratic problem on the Stiefel manifold,” Sci. China Inf. Sci.,\nvol. 60, no. 11, p. 112101, 2017.\n[26] F. Nie, H. Huang, X. Cai, and C. H. Ding, “Efficient and\nrobust feature selection via joint \u00022, 1-norms minimization,” in Proc.\nAdv. Neural Inf. Process. Syst., Vancouver, BC, Canada, 2010,\npp. 1813–1821.\n[27] J. J. Hull, “A database for handwritten text recognition research,”\nIEEE Trans. Pattern Anal. Mach. Intell., vol. 16, no. 5, pp. 550–554,\nMay 1994.\n[28] C. E. Thomaz and G. A. Giraldi, “A new ranking method for principal\ncomponents analysis and its application to face image analysis,” Image\nVis. Comput., vol. 28, no. 6, pp. 902–913, 2010.\n[29] J. Gui, Z. Sun, G. Hou, and T. Tan, “An optimal set of code words and\ncorrentropy for rotated least squares regression,” in Proc. IEEE Int. Joint\nConf. Biometrics, Sep. 2014, pp. 1–6.\n[30] M. M. Nordstrøm, M. Larsen, J. Sierakowski, and M. B. Stegmann,\n“The IMM face database-an annotated dataset of 240 face images,”\nInform. Math. Modelling, Tech. Univ. Denmark, DTU, Kongens Lyngby,\nKingdom of Denmark, Tech. Rep. DK-2800, May 2004.\n[31] S. A. Nene, S. K. Nayar, and H. Murase, “Columbia object image library\n(COIL-20),” Dept. Comput. Sci., Columbia Univ., New York, NY, USA,\nTech. Rep. CUCS-005-96, Feb. 1996.\n[32] C. H. Papadimitriou and K. Steiglitz, Combinatorial Optimization:\nAlgorithms and Complexity. Upper Saddle River, NJ, USA: Prentice\u0002Hall, 1982.\n[33] A. Strehl and J. Ghosh, “Cluster ensembles—A knowledge reuse frame\u0002work for combining multiple partitions,” J. Mach. Learn. Res., vol. 3,\npp. 583–617, Dec. 2002.\n[34] K. Fan, “On a theorem of weyl concerning eigenvalues of linear trans\u0002formations,” Proc. Nat. Acad. Sci. USA, vol. 35, no. 11, pp. 652–655,\n1949.\n[35] R. Zhang, F. Nie, and X. Li, “Feature selection under regularized orthog\u0002onal least square regression with optimal scaling,” Neurocomputing,\nvol. 273, pp. 547–553, Jan. 2018.","tags":["paper"],"categories":["paper"]},{"title":"[leetcode]动态规划(Dynamic Programming)","url":"%2Fposts%2F26386%2F","content":"\n> 转载自[浅谈什么是动态规划以及相关的「股票」算法题](https://mp.weixin.qq.com/s/p91e-EuSuVK3bfOc7uJplg)\n\n\n### 概念\n- **动态规划**算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。在学习动态规划之前需要明确掌握几个重要概念。\n- **阶段：** 对于一个完整的问题过程，适当的切分为若干个相互联系的子问题，每次在求解一个子问题，则对应一个阶段，整个问题的求解转化为按照阶段次序去求解。\n- **状态：** 状态表示每个阶段开始时所处的客观条件，即在求解子问题时的已知条件。状态描述了研究的问题过程中的状况。\n- **决策：** 决策表示当求解过程处于某一阶段的某一状态时，可以根据当前条件作出不同的选择，从而确定下一个阶段的状态，这种选择称为决策。\n- **策略：** 由所有阶段的决策组成的决策序列称为全过程策略，简称策略。\n- **最优策略：** 在所有的策略中，找到代价最小，性能最优的策略，此策略称为最优策略。\n- **状态转移方程：** 状态转移方程是确定两个相邻阶段状态的演变过程，描述了状态之间是如何演变的。\n\n### 使用场景\n- 能采用动态规划求解的问题一般要具有3个性质:\n  - **最优化：** 如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。子问题的局部最优将导致整个问题的全局最优。换句话说，就是问题的一个最优解中一定包含子问题的一个最优解。\n    > 最优化原理: 一个过程的最优策略具有这样的性质，即无论其初始状态及初始决策如何，其以后诸决策对以第一个决策所形成的状态作为初始状态的过程而言，必须构成最优策略。\n  - **无后效性：** 即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关，与其他阶段的状态无关，特别是与未发生的阶段的状态无关。\n  - **重叠子问题：** 即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）\n\n### 算法流程\n- **划分阶段：** 按照问题的时间或者空间特征将问题划分为若干个阶段。\n- **确定状态以及状态变量：** 将问题的不同阶段时期的不同状态描述出来。\n- **确定决策并写出状态转移方程：** 根据相邻两个阶段的各个状态之间的关系确定决策。\n- **寻找边界条件：** 一般而言，状态转移方程是递推式，必须有一个递推的边界条件。\n- **设计程序：** 解决问题\n\n### 实战练习\n\n#### 实战1\n- 题目描述\n{% asset_img 201905152254244.png %}\n\n- 题目解析\n  - 状态: 有 **买入(buy)** 和 **卖出(sell)** 两种状态\n  - 转移方程: \n    对于买来说，买之后可以卖出（进入卖状态），也可以不再进行股票交易（保持买状态）。\n    对于卖来说，卖出股票后不在进行股票交易（还在卖状态）。\n    **所以我们只要考虑当天买和之前买哪个花费更低，当天卖和之前卖哪个收益更高。**\n    $buy = min(buy,prices[i])$\n    $sell = max(sell,prices[i]-buy)$\n  - 边界\n    buy = INT_MAX, sell = 0，最后返回 sell 即可。\n- 代码实现\n  - 方法一: DP\n    ```cpp\n    int maxProfit(vector<int>& prices) {\n        int len=prices.size();\n        if (len<=1) return 0;\n        int buy=INT_MAX,sell=0;\n        for (int i=0;i<len;++i)\n        {\n            buy=min(buy,prices[i]);         // 当天买与之前买选取花费最少的\n            sell=max(sell,prices[i]-buy);   // 当天卖与之前卖选取收益最多的\n        }\n        return sell;\n    }\n    ```\n  - 方法二: Greedy\n    ```cpp\n    int maxProfit(vector<int>& prices) {\n        int len=prices.size();\n        if (len<=1) return 0;\n        int maxVal=0;\n        for(int i=1;i<len;++i)  // 增量就是纯收益\n            if (prices[i]>prices[i-1])\n                maxVal+=prices[i]-prices[i-1];\n        return maxVal;\n    }\n    ```\n\n#### 实战2\n- 题目描述\n  {% asset_img 201905152324445.png %}\n\n- 题目解析\n  - 状态: 有 **买入(buy)** 和 **卖出(sell)** 两种状态\n  - 转移方程: \n    对比上题，这里**可以有无限次的买入和卖出**，也就是说**买入状态之前可拥有卖出状态**，所以买入的转移方程需要变化。\n    **所以我们只要考虑当天买和之前买哪个花费更低，当天卖和之前卖哪个收益更高。**\n    $buy = min(buy,prices[i]-sell)$\n    $sell = max(sell,prices[i]-buy)$\n  - 边界\n    buy = INT_MAX, sell = 0，最后返回 sell 即可。\n- 代码实现\n    ```cpp\n    int maxProfit(vector<int>& prices) {\n        int len=prices.size();\n        if (len<=1) return 0;\n        int buy=INT_MAX,sell=0;\n        for (int i=0;i<len;++i)\n        {\n            buy=min(buy,prices[i]-sell);    // 当天买与之前买选取花费最少的\n            sell=max(sell,prices[i]-buy);   // 当天卖与之前卖选取收益最多的\n        }\n        return sell;\n    }\n    ```\n#### 实战3\n- 题目描述\n  {% asset_img 201905161307449.png %}\n  \n- 题目解析\n  - 状态: 有 **第一次买入（fstBuy） 、 第一次卖出（fstSell）、第二次买入（secBuy） 和 第二次卖出（secSell）** 这四种状态。\n  - 转移方程:\n    这里可以有两次的买入和卖出，也就是说 **买入** 状态之前可拥有 **卖出** 状态，所以买入和卖出的转移方程需要变化。\n    $fstBuy=min(fstBuy,prices[i])$\n    $fstSell=max(fstSell,prices[i]-fstBuy)$\n    $secBuy=min(secBuy,prices[i]-fstSell)$\n    $secSell=max(secSell,prices[i]-secBuy)$\n  - 边界\n    fstBuy = INT_MAX, fstSell = 0\n    secBuy = INT_MAX, secSell = 0\n    最后返回 sell 即可\n- 代码实现\n    ```cpp\n    int maxProfit(vector<int>& prices) {\n        int len=prices.size();\n        if (len<=1) return 0;\n        int fstBuy=INT_MAX,fstSell=0,secBuy=INT_MAX,secSell=0;\n        for(int i=0;i<len;++i)\n        {\n            fstBuy=min(fstBuy,prices[i]);           // 第一次买花费的最小成本\n            fstSell=max(fstSell,prices[i]-fstBuy);  // 第一次卖出获取的最大收益\n            secBuy=min(secBuy,prices[i]-fstSell);   // 第二次买花费的最小成本\n            secSell=max(secSell,prices[i]-secBuy);  // 第二次卖出获取的最大收益\n        }\n        return secSell;\n    }\n    ```\n\n#### 实战4\n- 题目描述\n  {% asset_img 2019051613454010.png %}\n\n- 题目解析\n  - 状态: 有 **第一次买入,第n次买入,第n次卖出** 这三种状态,用$dp[i][0]$表示**第i次买入**,$dp[i][1]$表示**第i次卖出**,这里根据题意i从0开始\n  - 转移方程:\n    只有**第一次买入**时没有之前状态,以后的**买入状态之前都是卖出状态,卖出状态之前都是买入状态**\n    $dp[0][0]=min(dp[0][0],prices[i])$\n    $dp[0][1]=max(dp[0][1],prices[i]-dp[0][0])$\n    $1\\le j\\lt k$时,\n    $dp[j][0]=min(dp[j][0],prices[i]-dp[j-1][1])$\n    $dp[j][1]=max(dp[j][1],prices[i]-dp[j][0])$\n  - 边界\n    dp[i][0]=INT_MAX, dp[i][1]=0 ($0\\le i\\lt k$)\n    最后返回dp[k-1][1]即可\n- 代码实现\n    ```cpp\n    int dp[1000][2];\n    int greedy(vector<int>& prices) // greedy algorithm\n    {\n        int maxVal=0,len=prices.size();\n        for(int i=1;i<len;++i)\n            if (prices[i]>prices[i-1])\n                maxVal+=prices[i]-prices[i-1];\n        return maxVal;\n    }\n    int maxProfit(int k, vector<int>& prices) {\n        int len=prices.size();\n        if (len<=1||k==0) return 0;\n        if (k>=len/2) return greedy(prices);\n        \n        // dp(dynamic programming)\n        for(int i=0;i<k&&i<len;++i)\n            dp[i][0]=INT_MAX;\n        for(int i=0;i<len;++i)\n        {\n            dp[0][0]=min(dp[0][0],prices[i]);\n            dp[0][1]=max(dp[0][1],prices[i]-dp[0][0]);\n            for(int j=1;j<=i&&j<k;++j)\n            {\n                dp[j][0]=min(dp[j][0],prices[i]-dp[j-1][1]);\n                dp[j][1]=max(dp[j][1],prices[i]-dp[j][0]);\n            }\n        }\n        return dp[k-1][1];\n    }\n    ```","tags":["dp"],"categories":["OJ"]},{"title":"[math]notes","url":"%2Fposts%2F56623%2F","content":"### 0. Notation\n\n> From: [List of mathematical symbols](https://en.wikipedia.org/wiki/List_of_mathematical_symbols)\n> notice:\n> - $\\mathbb B$ is equal to $\\mathbf B$, represented boolean domain\n\n|   Symbol    | Name                                      | Explanation                                                                                                                                                                                                                                                                         | Example                                                                                                                      |\n| :---------: | :---------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------- |\n| $\\mathbf B$ | boolean domain                            | $\\mathbf B$ either {0, 1}, {false, true}, {F, T}, or $\\left\\{\\bot ,\\top \\right\\}$                                                                                                                                                                                                   |                                                                                                                              |\n| $\\mathbf C$ | complex numbers                           | $\\mathbf C$ means ${a+b i : a,b ∈ ℝ}$                                                                                                                                                                                                                                               |                                                                                                                              |\n| $\\mathbf I$ | indicator function                        | The indicator function of a subset A of a set X is a function $\\mathbf {1} _{A}\\colon X\\to \\{0,1\\}$ defined as : $\\mathbf {1} _{A}(x):={\\begin{cases}1&{\\text{if }}x\\in A,\\\\0&{\\text{if }}x\\notin A.\\end{cases}}$ <br>Note that the indicator function is also sometimes denoted 1. |                                                                                                                              |\n| $\\mathbf N$ | natural numbers                           | N means either { 0, 1, 2, 3, ...} or { 1, 2, 3, ...}.                                                                                                                                                                                                                               |                                                                                                                              |\n| $\\mathbf Q$ | rational numbers                          | ℚ means {p/q : p ∈ ℤ, q ∈ ℕ}                                                                                                                                                                                                                                                        |                                                                                                                              |\n| $\\mathbf R$ | real numbers                              | ℝ means the set of real numbers.                                                                                                                                                                                                                                                    |                                                                                                                              |\n| $\\mathbf Z$ | integers                                  | ℤ means {..., −3, −2, −1, 0, 1, 2, 3, ...}.<br>ℤ+ or ℤ> means {1, 2, 3, ...}.<br>ℤ≥ means {0, 1, 2, 3, ...}.<br>ℤ* is used by some authors to mean {0, 1, 2, 3, ...} and others to mean {... -2, -1, 1, 2, 3, ... }.                                                                |                                                                                                                              |\n|  $\\times$   | 1.multiplication                          | 3 × 4 means the multiplication of 3 by 4.                                                                                                                                                                                                                                           |                                                                                                                              |\n|             | 2.Cartesian product                       | X × Y means the set of all ordered pairs with the first element of each pair selected from X and the second element selected from Y.                                                                                                                                                | {1,2} × {3,4} =<br>{(1,3),(1,4),(2,3),(2,4)}                                                                                 |\n|             | 3.cross product                           | $\\bm u\\times \\bm v$ means the cross product of vectors $\\bm u$ and $\\bm v$                                                                                                                                                                                                          | (1,2,5) × (3,4,−1) =<br>(−22, 16, − 2)                                                                                       |\n|  $\\otimes$  | tensor product, tensor product of modules | $V\\otimes U$ means the tensor product of V and U. $V\\otimes _{R}U$ means the tensor product of modules $V$ and $U$ over the ring $R$.                                                                                                                                               | $\\{1, 2, 3, 4\\} ⊗ \\{1, 1, 2\\} =\\\\ \\{\\{1, 1, 2\\}, \\{2, 2, 4\\}, \\{3, 3, 6\\}, \\{4, 4, 8\\}\\}$                                    |\n|   $\\circ$   | Hadamard product                          | For two matrices (or vectors) of the same dimensions $A,B\\in {\\mathbb {R} }^{m\\times n}$ the Hadamard product is a matrix of the same dimensions $A\\circ B\\in {\\mathbb {R} }^{m\\times n}$ with elements given by $(A\\circ B)_{i,j}=(A)_{i,j}\\cdot (B)_{i,j}$.                       | $\\begin{bmatrix}1&2\\\\2&4\\\\\\end{bmatrix} \\circ \\begin{bmatrix}1&2\\\\0&0\\\\\\end{bmatrix}=\\begin{bmatrix}1&4\\\\0&0\\\\\\end{bmatrix}$ |\n|             |                                           |                                                                                                                                                                                                                                                                                     |                                                                                                                              |\n|             |                                           |                                                                                                                                                                                                                                                                                     |                                                                                                                              |\n|             |                                           |                                                                                                                                                                                                                                                                                     |                                                                                                                              |\n|             |                                           |                                                                                                                                                                                                                                                                                     |                                                                                                                              |\n|             |                                           |                                                                                                                                                                                                                                                                                     |                                                                                                                              |\n|             |                                           |                                                                                                                                                                                                                                                                                     |                                                                                                                              |\n|             |                                           |                                                                                                                                                                                                                                                                                     |                                                                                                                              |\n|             |                                           |                                                                                                                                                                                                                                                                                     |                                                                                                                              |\n|             |                                           |                                                                                                                                                                                                                                                                                     |                                                                                                                              |\n### 1. Norm\n- **Definition**\n- **Absolute-value norm**\n  $||x||=|x|\\quad (1)$\n  实数或复数构成的一维向量空间的norm\n  (1)也为**L1 norm**\n- **Euclidean norm(欧几里得范数)**\n  - n维欧几里得空间$R^n$中,$\\bm x=(x_1,x_2,...,x_n)$\n    $||\\bm x||_2(or ||\\bm x||):=\\sqrt{x_1^2+\\dots+x_n^2}\\quad (2)$\n    (2)为**Euclidean norm**,给出了原点到$X$点的一般距离\n    **注:** $||\\cdot||_2,||\\cdot||$都表示$L_2$范数\n  - n维附属空间$C^n$,可表示为\n    $||\\bm z||_2(or ||\\bm z||):=\\sqrt{|z_1|^2+\\dots+|z_n|^2}=\\sqrt{z_1\\bar{z_1}+\\dots+z_n\\bar{z_n}}\\quad (3)$\n  - $\\bm x$表示列向量时,$\\bm x=(x_1,x_2,\\dots,x_n)^T$,$\\bm x^*$表示**共轭转置(conjugate transpose)**,可表示为\n    $||\\bm x||:=\\sqrt{x^*x}\\quad (4)$\n  - **Euclidean norm**也被称为**Euclidean length,$L^2$distance,$L^2$norm**\n- **Manhattan norm(Taxicab norm)**\n  - 名字即为出租车从矩形街道原点到$\\bm x$点的距离\n    $||\\bm x||_1:=\\sum_{i=1}^n|x_i|\\quad (5)$\n    (5)也被称为**L1 norm**\n- **p-norm**\n  - $p\\geq 1$的实数,向量$\\bm x=(x_1,\\dots,x_n)^T$的p-norm表示为\n    $||\\bm x||_p:=(\\sum_{i=1}^n|x_i|^p)^\\frac{1}{p}\\qquad (6)$\n    当$p=1$时,为**Manhattan norm**\n    当$p=2$时,为**Euclidean norm**\n- **Matrix norm**\n  - a matrix norm is a vector norm in a vector space whose elements (vectors) are matrices (of given dimensions).\n  - $A_{m\\times n}$,第$i$行表示为$\\bm a^i=(a_{i1},\\dots,a_{in})$,第$j$列表示为$\\bm a_j=(a_{1j},\\dots,a_{mj})$,第$i$行$j$列表示为$a_{ij}$,\n  - 将$m\\times n$的矩阵看作$m$个行向量,每个行向量有$n$个元素,即$A=(\\bm a^1,\\dots,\\bm a^m)^T, \\bm a^1=(a_{11},...,a_{1n})^T$\n    $||A||_p=||vec(A)||_p=(\\sum_{i=1}^m\\sum_{j=1}^n|a_{ij}|^p)^\\frac{1}{p}$\n  - **$L_{2,1}$ and $L_{p,q}$ norms**\n    - $p,q\\ge 1$,$L_{p,q}$ norm表示为\n    $||A||_{p,q}=(\\sum_{i=1}^{m}||\\bm a^i||_p^q)^\\frac{1}{q}=(\\sum_{i=1}^m(\\sum_{j=1}^n|a_{ij}|^p)^\\frac{q}{p})^\\frac{1}{q}$\n    - $L_{2,1}$ norm表示为\n    $||A||_{2,1}=\\sum_{i=1}^m||\\bm a^i||_2=\\sum_{i=1}^m(\\sum_{j=1}^n|a_{ij}|^2)^\\frac{1}{2}$\n- **Frobenius norm(F-norm)**\n  - $A_{m\\times n}$,当$L_{p,q}$中,$p=q=2$时,$L_{2,2}$被称为**Frobenius norm(or Hilbert-Schmidt norm)**,可以表示为\n    $||A||_F=||A||_{2,2}=\\sum_{i=1}^m||\\bm a^i||_2^2=(\\sum_{i=1}^m(\\sum_{j=1}^n|a_{ij}|^2)^\\frac{2}{2})^\\frac{1}{2}=\\sqrt{\\sum_{i=1}^m\\sum_{j=1}^n|a_{ij}|^2}\\\\=\\sqrt{trace(A^TA)}=\\sqrt{\\sum_{i=1}^{min\\{m,n\\}}\\sigma_i^2(A)}$\n\n### 2. Space\n- **Definition**\n  - 一个空间是一个有附加结构的集合(set)\n- **Euclidean spaces**\n  - Definition\n    encompasses **two-dimensional Euclidean plane**,**three-dimensional space of Euclidean geometry**, and similar spaces of **higher dimension**\n  - Euclidean distance\n    vector $\\bm x=(x_1,\\dots,x_n)$\n    $||\\bm x||=\\sqrt{\\bm x\\cdot\\bm x}=\\sqrt{\\sum_{i=1}^n x_i^2}\\quad (1)$\n    上式(1)为内积,表示向量$\\bm x$的长度,同时也满足norm的标准,被称为$R^n$空间的**Euclidean norm**\n    $d(\\bm x,\\bm y)=||\\bm x-\\bm y||=\\sqrt{\\sum_{i=1}^n(x_i-y_i)^2}\\quad (2)$\n    上式(2)为距离函数,被称为**Euclidean distance(Euclidean metric)**,为**Pythagorean theorem**(勾股定理)的一个特例\n  - Squared Euclidean distance(SED)\n    $d^2(\\bm x, \\bm y)=||\\bm x-\\bm y||^2(or ||\\bm x-\\bm y||_2^2)=\\sum_{i=1}^n(x_i-y_i)^2$\n- **Linear spaces**\n- **Topological spaces**\n- **Hilbert spaces**\n\n### 3. Matrix\n- **Toeplitz matrix**，形如\n   {% asset_img 18f00e8851de7fb2e91e743abfb00b41.png %}\n- **Hankel matix**，形如\n   {% asset_img 7a76bd718b5429e22c1f320ebb6400bf.png %}\n   刚好和就是toeplitz的transpose\n- **Degree matrix**，这个和拓扑学有关了，此矩阵只有main diagonal上有非零值，代表的是对应edge(node)所连接的vetices的数量（如果自循环则算两个）\n   $G=(V,E), |V|=n$\n   {% asset_img 2019050920271027.png %}\n- **Adjacency matrix**，也和拓扑学有关，为仅有1或者0的矩阵。\n   如果两个edge之间有vertex相连，则对应位置填1。因为这个性质，此矩阵为symmetric的，main diagonal上的1表示自循环。\n\n|             Labeled graph             |           Degree matrix            |        Adjacency matrix         |          Laplacian matrix           |\n| :-----------------------------------: | :--------------------------------: | :-----------------------------: | :---------------------------------: |\n| {% asset_img 175px-6n-graf.svg.png %} | {% asset_img 0836612538d722.svg %} | {% asset_img 56ef36960e2.svg %} | {% asset_img e495d70fe91b272.svg %} |\n\n- **Laplacian matix**。由上面两位计算得到:\n   $L=D-A$\n\n- **Circulant matrix**, T的变种，如下\n   {% asset_img cb126605ae067e1f4bae13598a2a39f8.png %}\n\n- **Symplectic matrix**\n   指满足这个条件的$M_{2n\\cdot{2n}}$矩阵：$M^T\\Omega M=\\Omega$.\n   其中,另一个矩阵必须是nonsingular, skew-symmetric matrix.，例如选$\\Omega=\\begin{bmatrix}\n   0 & I_n \\\\ -I_n & 0 \\\\    \n   \\end{bmatrix}$ 是一个block matrix,I是单位矩阵(identity matrix)\n\n- **Vandermonde matrix**,形如\n   {% asset_img 642ce6b42c22729068792a6496d81ee7.png %}\n\n-  **Hessenberg matrix**\n    Hessenberg matrix is a special kind of square matrix, one that is \"almost\" triangular. To be exact, an upper Hessenberg matrix has zero entries below the first subdiagonal, and a lower Hessenberg matrix has zero entries above the first superdiagonal\n    例如：upper Hessenberg matrix\n    {% asset_img dd7c78e1ed6e6c999036fed54fe648d0.png %}\n\n- **Hessian matrix**\n    对于实数函数 $f(x_1, x_2, \\dots, x_n)\\,$求二阶偏导（second-order partial derivatives），如下\n    {% asset_img f7296865484b39fcbac598a99b7f3dbb.png %}\n\n- **Idempotent matrix(幂等阵)**\n    Definition: $M^2=M$\n    性质:\n    - $\\lambda$只能为0或1\n    - $A\\cdot(A-E)=0$,$A-E$的每列都为$Ax=0$的解 \n    - $E+A$可逆(因为$E+A$所有$\\lambda$大于0)\n    - $\\lambda_1=1$是$r(A)$重根,$\\lambda_2=0$是$n-r(A)$重根,且有n个线性无关特征向量,即$\\exist$可逆$P$,使$P^{-1}AP=\\begin{bmatrix}\n        E_r & 0 \\\\\n        0   & 0 \\\\\n    \\end{bmatrix}$\n    - 幂等阵必相似于对角阵,$\\exist$可逆$P$,使$P^{-1}AP=\\Lambda=\\begin{bmatrix}\n        E_r&0\\\\\n        0&0\\\\\n    \\end{bmatrix}$\n      > 证明如下:\n      $A^2=A\\implies(E-A)\\cdot{A}=0$,$A$中有$r(A)$个线性无关列向量(即$(E-A)x=0$的解向量)$\\implies\\lambda_1=1$至少是$r(A)$重特征值$\\qquad (1)$\n      $Ax=0\\implies(0\\cdot{E}-A)x=0,\\lambda_2=0$至少是$n-r(A)$重根$\\qquad (2)$\n      由$(1),(2)\\implies\\lambda_1=1$($r(A)$重根),$\\lambda_2=0$($n-r(A)$重根)\n\n- **Orthogonal matrix(正交阵)**\n  - Definition: $A_{n\\times n},A^TA=E(A^{-1}=A^T)$,则称$A$为正交阵\n  - Properties:\n    - $A^T=A^{-1},A^TA=E$\n    - $A$的列向量都是单位向量,且两两正交\n      - 引申:若已知$A$中某$a_{ij}=1$则该$a_{ij}$所在的行与列的其他元素为0\n    - $A\\bm x=\\bm b$有唯一解$\\bm x=A^{-1}\\bm b$\n- **Centering matrix**\n    Definition: $\\bm 1=(1,\\dots,1)^T, C_n=I_n-\\frac{1}{n}\\bm {11}^T$\n    example: \n    $C_1=\\left[0\\right]$\n    $C_2=\n    \\begin{bmatrix}\n        1&0\\\\\n        0&1\\\\\n    \\end{bmatrix}-\\frac{1}{2}\n    \\begin{bmatrix}\n        1&1\\\\\n        1&1\\\\\n    \\end{bmatrix}=\n    \\begin{bmatrix}\n        \\frac{1}{2}&-\\frac{1}{2}\\\\\n        -\\frac{1}{2}&\\frac{1}{2}\\\\\n    \\end{bmatrix}$\n- **Similarity matrix(distance matrix)**\n- **Euclidean distance matrix**\n  - Definition: $\\bm x_1,\\cdots,\\bm x_n$ are defined on **m-dimensional space**,$\\bm x_1=(x_1,\\dots,x_m)$,the elements of $A$ are given by \n  $A=(a_{ij})$\n  $a_{ij}=d_{ij}^2=||\\bm x_i-\\bm x_j||_2^2$\n  where $||\\cdot||_2$ denotes **2-norm** on $\\bm R^m$\n  {% asset_img 79b8411936e4b4f.svg %}\n- **Scatter matrix**\n  - Definition: $n$ samples of m-dimensional data, represented as $m\\times n$ matrix, $X=(\\bm x_1,\\dots,\\bm x_n)$, sample mean is\n  $\\overline \\bm x = \\frac{1}{n}\\sum_{j=1}^n \\bm x_j$\n  where $\\bm x_j=(x_{1j},\\dots,x_{mj})^T$ is j-th column of $X$\n  The **scatter matrix** is $m\\times m$ positive **semi-definite matrix**\n  $S=\\sum_{j=1}^n(\\bm x_j - \\overline \\bm x)(\\bm x_j - \\overline \\bm x)^T=\\sum_{j=1}^n(\\bm x_j - \\overline \\bm x)\\otimes(\\bm x_j - \\overline \\bm x)=(\\sum{j=1}^n\\bm x_j\\bm x_j^T)-n\\overline\\bm x \\overline\\bm x^T$\n  mutiplication is regarded as outer product,the scatter matrix can be also expressed as\n  $S=XC_n X^T$\n  where $C_n$ is $n\\times n$ centering matrix\n- **Transformation matrix**\n  - Definition: If $T$ is a linear transformation mapping $\\mathbb {R} ^{n}$ to $\\mathbb {R} ^{m}$ and $\\vec {x}$ is a column vector with $n$ entries, then\n    $T( \\vec x ) = \\mathbf{A} \\vec x$\n    for some $m\\times n$ matrix $A$, called the transformation matrix of $T$. Note that $A$ has $m$ rows and $n$ columns, whereas the transformation $T$ is from $\\mathbb {R} ^{n}$ to $\\mathbb {R} ^{m}$. \n  - Non-linear transformations\n    - affine transformations\n    - projective transformations\n- **Affine transformation matrix**\n- **Projective transformation matrix**\n### 4. Definiteness of a matrix\n- **Definitions for real matrices**\n  A $n\\times n$ symmetric real matrix $M$ is said to be **positive definite** if $\\bm x^TM\\bm x>0$ for all non-zero $\\bm x$ in $\\mathbb {R} ^{n}$. Formally,\n  $$\\boxed{M{\\text{ positive definite}}\\quad \\iff \\quad \\bm x^{\\textsf {T}}M\\bm x>0{\\text{ for all }}\\bm x\\in \\mathbb {R} ^{n}\\setminus \\mathbf {0} }$$\n  \n  A $n\\times n$ symmetric real matrix $M$ is said to be **positive semidefinite** or **non-negative definite** if $\\bm x^{\\textsf {T}}M\\bm x\\geq 0$ for all non-zero $\\bm x$ in $\\mathbb {R} ^{n}$. Formally,\n  $$\\boxed{\\displaystyle M{\\text{ positive semi-definite}}\\quad \\iff \\quad \\bm x^{\\textsf {T}}M\\bm x\\geq 0{\\text{ for all }}\\bm x\\in \\mathbb {R} ^{n}\\setminus \\mathbf {0} }$$\n\n  A $n\\times n$ symmetric real matrix $M$ is said to be **negative definite** if $\\bm x^{\\textsf {T}}M\\bm x<0$ for all non-zero $\\bm x$ in $\\mathbb {R} ^{n}$. Formally,\n  $$\\boxed{\\displaystyle M{\\text{ negative definite}}\\quad \\iff \\quad \\bm x^{\\textsf {T}}M\\bm x<0{\\text{ for all }}\\bm x\\in \\mathbb {R} ^{n}\\setminus \\mathbf {0} }$$\n\n  A $n\\times n$ symmetric real matrix $M$ is said to be **negative semidefinite** or **non-positive definite** if $\\bm x^{\\textsf {T}}M\\bm x\\leq 0$ for all non-zero $\\bm x$ in $\\mathbb {R} ^{n}$. Formally,\n  $$\\boxed{\\displaystyle M{\\text{ negative semi-definite}}\\quad \\iff \\quad \\bm x^{\\textsf {T}}M\\bm x\\leq 0{\\text{ for all }}\\bm x\\in \\mathbb {R} ^{n}\\setminus \\mathbf {0} }$$\n\n  A $n\\times n$ symmetric real matrix which is neither **positive semidefinite** nor **negative semidefinite** is called **indefinite**.","tags":["math"],"categories":["math"]},{"title":"[leetcode]5055.困于环中的机器人","url":"%2Fposts%2F272%2F","content":"{% asset_img 2019051215261229.png %}\n\n### 解题思路\n- 检测最终状态,如果改变了方向(无论过程中移动到了何处),经过了≤4轮,最终一定会回到变为初始状态(回到原处且面向北方),那么必然是无法离开\n- 如果指令结束时回到了原点,那么必然是无法离开\n\n### 代码实现\n\n方法一: 4轮指令过程中一定可以验证是否可以离开\n```cpp\nbool isRobotBounded(string ins) \n{\n    set<tuple<int,int,int,int>> dict;\n    int dx[]={-1,0,1,0},dy[]={0,-1,0,1};\n    int x=0,y=0,len=ins.size(),dir=0;\n    for (int i=0;i<=4;++i)\n    {\n        for (int j=0;j<len;++j)\n        {\n            if (ins[j]=='L')\n                dir++;\n            else if (ins[j]=='R')\n                dir+=3;\n            else if (ins[j]=='G')\n            {\n                x+=dx[dir];\n                y+=dy[dir];\n            }\n            dir%=4;\n            if (dict.count(make_tuple(x,y,j,dir)))\n                return true;\n            dict.insert(make_tuple(x,y,j,dir));\n        }\n    }\n    return false;\n}\n```\n\n方法二: $O(n)$\n```cpp\nbool isRobotBounded(string instructions)\n{\n    int dx[]={0,1,0,-1},dy[]={-1,0,1,0}, x=0,y=0,dir=0; // 左下右上\n    for (int i=0;i<ins.size();++i)\n    {\n        if (ins[i]=='L')\n            dir=(dir+1)%4;\n        else if (ins[i]=='R')\n            dir=(dir+3)%4;\n        else\n        {\n            x+=dx[dir];\n            y+=dy[dir];\n        }\n    }\n    return (x==0&&y==0)||(dir>0);\n}\n```\n\n### 结论\n- 只要最终回到原点,那么一定是bounded\n- 只要最终面向的不是北方,那么将会在剩下1到3轮回到最开始的状态(即指令结束时只要改变了方向,那么每轮都会改变方向,最终回到原点)","tags":["迷宫"],"categories":["OJ"]},{"title":"[schedule]TODO","url":"%2Fposts%2F55269%2F","content":"\n### 1.Extensive reading(One book at least twice for learning)\n| Book                        | Date | Progress        |\n| :-------------------------- | :--- | :-------------- |\n| <<Alan Turing: The Enigma>> | 5/9  | 1 chapter 1,2   |\n|                             | 5/10 | 1 chapter 3,4   |\n|                             | 5/14 | 1 chapter 5,6   |\n|                             | 5/15 | 1 chapter 7,8   |\n|                             | 5/16 | 1 chapter 9,10  |\n|                             | 5/17 | 1 chapter 11,12 |\n|                             | 5/18 | 1 chapter 13,14 |\n|                             | 5/19 | 1 chapter 15,16 |\n|                             |      |                 |\n|                             |      |                 |\n|                             |      |                 |\n|                             |      |                 |\n|                             |      |                 |\n|                             |      |                 |\n|                             |      |                 |\n\n\n","tags":["TODO"],"categories":["schedule"]},{"title":"[leetcode]375. Guess Number Higher or Lower II","url":"%2Fposts%2F42608%2F","content":"{% asset_img 2019050820074824.png %}\n\n### 题目含义\n\n给定一个n值为最大值,我从中选出一个数,然后你来猜,猜错了我会告诉你你的数字大了还是小了,并罚你所说数字的钱数,然后再猜,问你最少有多少钱才能保证你一定能猜对?\n\n### 解题思路\n\n没想到是dp的思想,关键在于这个最少是多少钱如何理解.\n假设n=5,你可能会想到,如果你有2+3+4+5=14元,那就一定能猜对,因为我选的数字一定会$\\ge$1,没错,但是这不是最少的钱数,即应该说如果你运气足够差的情况下(即每次都猜错),所花的最少钱数,在leetcode的discuss版块看到的解释:\n\n{% asset_img 2019050820370125.png %}\n\n这道题的意思是,你足够聪明能够选到一种策略,每次都按这个策略来,然后所花费的钱一定会最少,比如:\n\n| n值    | 猜测序列(罚款最多的猜法) | 罚款 |\n| :----- | :----------------------: | :--- |\n| n=1时  |                          | 0    |\n| n=2时  |            1             | 1    |\n| n=3时  |            2             | 2    |\n| n=4时  |           1->3           | 4    |\n| n=5时  |           2->4           | 6    |\n| n=6时  |           3->5           | 8    |\n| n=7时  |           4->6           | 10   |\n| n=8时  |           5->7           | 12   |\n| n=9时  |           6->8           | 14   |\n| n=10时 |           7->9           | 16   |\n\n上述表格的意思,拿n=10来说,我只要有16元,我就一定能够猜对,n=9来说,我只要有14元,我就一定能够猜对,下面来分析,比如n=10时:\n- 如果选的数是8,先猜7,再猜9,最后必然猜对,则花16元,花光了\n- 如果选的数是4,先猜7,而这时你知道是比7小了,那么即n=6了,在按n=6的方法来猜,再猜3,再猜5,最后猜对了, 总共花的钱数为7+3+5=15元,手里还剩1元\n\n如果上面没懂,再来分析下面,即:\n1. 如果n=2\n   - 你猜1(错了),再猜就必然正确,罚1元\n   - 你猜2(错了),再猜就必然正确,罚2元\n   - n=2时,罚款最少只要1元\n2. 如果n=3\n   - 你猜1(错了),再猜2(错了),再猜就必然正确,罚3元\n   - 你猜1(错了),再猜3(错了),再猜就必然正确,罚5元\n   - 你猜2(错了),再猜就必然正确,罚2元\n   - 你猜3(错了),再猜1(错了),再猜就必然正确,罚4元\n   - 你猜3(错了),再猜2(错了),再猜就必然正确,罚5元\n   - n=3时,罚款最少只要2元\n\n通过总结以上规律,假设要猜数的范围在[i,j],每次你猜一个数k,就可以划分出两个区域[i,k-1],[k+1,j],然后就可以确定一个区域必然没有我选的数,因此,需要罚款k元,那么你要付的钱即为:k+max([i,k-1]范围猜对最少要花的钱,[k+1,j]范围猜对最少要花的钱),而k可以取的范围为[i,j],即你可以猜的数为[i,j],那么综合出所有猜的结果,选出最少花费的钱数,核心公式即为:\n\n$$\ndp[i][j]=min(dp[i][j],k+max(dp[i][k-1],dp[k+1][j]))\n$$\n> 提示1: $k+max(dp[i][k-1],dp[k+1][j])$ 即运气足够差的情况下,要花的钱\n> 提示2: $min(dp[i][j],k+max(dp[i][k-1],dp[k+1][j]))$ 即选出所有选择中要花的最少的钱\n\n### 代码实现: DP思想\n时间复杂度$O(n^3)$\n```cpp\nint dp[500][500];\nint getMoneyAmount(int n) {\n    for (int d=0;d<n;++d)\n    {\n        for (int i=1;i+d<=n;++i)\n        {\n            int j=i+d;\n            dp[i][j]=i==j?0:INT_MAX;\n            for (int k=i;k<=j;++k)\n                dp[i][j]=min(dp[i][j],k+max(dp[i][k-1],dp[k+1][j]));\n        }\n    }\n    return dp[1][n];\n}\n```\n\n### 结论\n就像汉诺塔的递归一样,要细抠一层层递归真的很难理解,但是如果记住大体思想就能写出来.这道题也是这样,记住了核心公式的含义就能解出来,即,**假如我当前猜k,没猜对,然后我已经知道了如果要猜的数落在[i,k-1]范围,我要花费多少钱就一定能猜对,如果落在[k+1,j]范围,我要花多少钱就一定能猜对,那么选取这两个中花钱最多的与k相加就是我本轮在先猜k的条件下赢得比赛(最终猜出来)需要要花的最多钱数.**没想到代码这么少,细抠却如此难理解,终于理解为什么这道题有695个鄙视了\n\n---\n\n最后,再给出我是如何得到n=1~10的那张表格的代码部分\n\n```cpp\nint dp[500][500];\nstring dps[500][500];\nint getMoneyAmount(int n) \n{\n    for (int d = 0; d < n; ++d)\n    {\n        for (int i = 1; i + d <= n; ++i)\n        {\n            int j = i + d;\n            dp[i][j] = i==j?0:INT_MAX;\n            for (int k = i; k <= j; ++k)\n            {\n                string str = to_string(k);\n                if (dp[i][k - 1]!=0|| dp[k + 1][j]!=0)\n                {\n                    if (dp[i][k - 1] >= dp[k + 1][j])\n                        str += \"->\" + dps[i][k - 1];\n                    else\n                        str += \"->\" + dps[k + 1][j];\n                }\n                if (dp[i][j] > k + max(dp[i][k - 1], dp[k + 1][j]))\n                    dps[i][j] = str;\n                dp[i][j] = min(dp[i][j], k + max(dp[i][k - 1], dp[k + 1][j]));\n            }\n        }\n    }\n    return dp[1][n];\n}\n\nint main()\n{\n    int n = 10;\n    int a = getMoneyAmount(n);\n    for (int i = 1; i < n; ++i)\n        for (int j = i + 1; j <= n; ++j)\n            printf(\"[%d,%d]: %s\\n\", i, j, dps[i][j].c_str());\n    return 0;\n}\n```\n","tags":["dp"],"categories":["OJ"]},{"title":"[leetcode]312. Burst Balloons","url":"%2Fposts%2F31611%2F","content":"{% asset_img 2019050817052623.png %}\n\n> 题目含义: n个气球,下标从0到n-1,对应于数组nums.每个气球都有一个编号nums[i],每当你扎破一个气球就可以得到$nums[left]\\cdot{nums[i]}\\cdot{nums[right]}$的硬币,这里的left和right是紧挨着气球i的两个气球,当气球i被扎破后,气球left和right就相邻了.请你求出将所有气球扎破后,你能获取的最大的金币数.\n\n注意: 题目要求你假设nums[-1]=nums[n]=1,也就是说当你要扎破第一个气球时,得到的硬币是$nums[-1]\\cdot{nums[0]}\\cdot nums[1]$,扎破最后一个气球时,得到的硬币是$nums[n-2]\\cdot{nums[n-1]}\\cdot{nums[n]}$的,即假设只有一个气球,且编号为3,那么扎破它得到的硬币数为$nums[-1]\\cdot{nums[0]}\\cdot{nums[1]} = 1\\cdot{3}\\cdot{1} = 3$\n\n### 解题思路: DP的思想\n\n该问题与[[leetcode]1039. Minimum Score Triangulation of Polygon](/2019/05/07/leetcode-1039-Minimum-Score-Triangulation-of-Polygon/)相似,DP的思想即将一个大问题,划分为多个小问题来求解,并且大问题和小问题应当存在一种递推(堆叠)的关系.\n在此问题中,我们将$dp[i][j]$用于表示把气球$i$到气球$j$全部扎破后所得到的最大金币数.假设我们最后扎破的气球为$k$,满足$i\\leq{k}\\leq{j}$的关系,那么这里就有一个递推关系,如下图所示\n\n{% asset_img 20190508052601.png %}\n\n> 如何理解上述的递推关系呢?\n\n我们做下处理将原题的下标0~n-1变成1~n(后面会解释原因),假设现在有n个气球,则:\n$1$表示左边界,$n$表示右边界,那么两边确定了,通过枚举最后扎破的气球k来解答.\n假设要扎破气球$1~n$,那么最后扎破的气球可能为$1,...,n-1,n$有如下三种情况\n- $k=1$时,即最后扎破的气球为序号最前的气球,那么最大硬币数为$dp[1][n]=0+dp[k+1][n]+1\\cdot{nums[k]}\\cdot{1}$\n- $k=n$时,即最后扎破的气球为序号最后的气球,那么最大硬币数为$dp[1][n]=dp[1][k-1]+0+1\\cdot{nums[k]}\\cdot{1}$\n- $1\\le{k}\\le{n}$时,即最后扎破的气球为中间的这些气球的一个(不在两端),那么最大硬币数为$dp[1][n]=dp[1][k-1]+dp[k+1][n]+1\\cdot{nums[k]}\\cdot{1}$\n\n需要注意的是,从1到n的总硬币数是要从小到大来计算的,即,上述的d[k+1][n],d[1][k-1],d[k+1][n]都是通过之前的计算算出,那么递推公式如下,假设要扎破气球$i~j(1\\le{i}\\leq{j}\\le{n})$,那么最后扎破的气球可能为$i,...,j$有如下三种情况\n- $k=i$,即最后扎破的气球为序号最前的气球,那么最大硬币数为$dp[i][j]=0+dp[k+1][j]+nums[i-1]\\cdot{nums[k]}\\cdot{nums[k]}$\n- $k=j$,即最后扎破的气球为序号最后的气球,那么最大硬币数为$dp[i][j]=dp[i][k-1]+0+nums[i-1]\\cdot{nums[k]}\\cdot{nums[k]}$\n- $i\\le{k}\\le{j}$,即最后扎破的气球为中间的这些气球的一个(不在两端),那么最大硬币数为$dp[i][j]=dp[i][k-1]+dp[k+1][j]+nums[i-1]\\cdot{nums[k]}\\cdot{nums[k]}$\n\n将以上两种情况都考虑进去(包含两端和不包含两端的),则即为代码部分的特殊处理,代码用A来代表nums了,将A的首部插入一个1,尾部也插入一个1,而气球真正的数量为n个,气球的标号为A[1]~A[n],A[0]和A[1]设置为1,即为题目的条件nums[-1]=nums[n]=1,则计算过程中无论是否是端点的情况,都可以正常计算了,说起来很麻烦,如果文字部分没理解的话可以看看下面的视频讲解\n\n\n下面是一位老哥的视频讲解:\n{% youtube IFNibRVgFBo %}\n\n### 实现代码: DP的思想\n\n```cpp\nint dp[600][600];\nint maxCoins(vector<int>& A) {\n    if (A.empty()) return 0;\n    int len=A.size();\n    A.insert(A.begin(),1);\n    A.push_back(1);\n    for (int d=0;d<len;++d) // d为i与j之间的间隔\n    {\n        for (int i=1;i+d<=len;++i)\n        {\n            int j=i+d;\n            for (int k=i;k<=j;++k)  // 在i与j之间(包含i,j)枚举k\n                // start i, end j, final burst k\n                dp[i][j] = max(dp[i][j], dp[i][k-1]+A[i-1]*A[k]*A[j+1]+dp[k+1][j]);\n        }\n    }\n    return dp[1][len];\n}\n```","tags":["dp"],"categories":["OJ"]},{"title":"[leetcode]1039. Minimum Score Triangulation of Polygon","url":"%2Fposts%2F35653%2F","content":"{% asset_img 20190507422058.png %}\n题目含义: 一个凸多边形由$N$个顶点构成,每个顶点有一个数值,顶点顺时针排列为$A[0],A[1],...,A[N-1]$,假设你将多边形分成$N-2$个三角形,每一个三角形的值为三个顶点值的乘积,多边形的总分数是构成它的$N-2$个三角形的值的总和,求一个$N$多边形的最小总分数.\n\n\n### 解题思路: DP动态规划的思想\n\n首先,$dp[i][j]$表示顺时针从$i$到$j$构成的多边形的最小分数,于是取一点$k$,满足$i<k<j$,再取$d$表示$i$到$j$的距离,进行枚举,在一个大的多边形中,$d=2$先把周边一圈小三角形枚举一边,$d=3$再把周边一圈的四边形枚举一遍(由$d=2$时求出了小三角形的分数计算得出四边形的最小分数),...,$d=N-1$再把$N$边形枚举一边,如下图所示:\n\n{% asset_img 20190508122646.jpg %}\n\n核心公式为: \n\n$$\ndp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j]+A[i]\\cdot{A[k]}\\cdot{A[j]})\n$$\n\n### 代码实现: DP思想\n\n```cpp\nint dp[100][100];\nint minScoreTriangulation(vector<int>& A) \n{\n    int len=A.size();\n    for (int d=2;d<len;++d) // d作为i与j之间的间距\n    {\n        for (int i=0; i+d<len; ++i)\n        {\n            int j=i+d;\n            dp[i][j]=INT_MAX;\n            for (int k=i+1;k<j;++k)\n                dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]+A[i]*A[k]*A[j]);\n        }\n    }\n    return dp[0][len-1];\n}\n```","tags":["dp"],"categories":["OJ"]},{"title":"[algorithm]线性表","url":"%2Fposts%2F24346%2F","content":"## 一. 线性表基础算法\n\n### 1.线性表插入操作\n\n线性表插入操作(在第$i(1≤i≤L.length+1)$个位置上插入新元素$elem$)\n\n```cpp\nbool InsertSeq( SeqList& L, int i, ElemType elem )\n{\n    if ( i < 1 || i>L.length + 1 || L.length >= MAXSIZE )\n        return false;\n    for ( j = L.length - 1; j >= i - 1; j-- )\n        L.elem[j + 1] = L.elem[j];\n    L.elem[j + 1] = elem;\n    L.length++;\n    return true;\n}\n```\n\n说明:\n- 插入操作: 可选位置为$1≤i≤L.length+1$\n- 最好情况: 表尾$(i=n+1)$插入, $O(1)$\n- 最坏情况: 表头$(i=1)$插入, $O(n)$\n- 平均情况: 设 $P_i=\\frac{1}{(n+1)}$ 是在第$i$个位置插入一个结点的概率,则在长度为$n$的线性表中插入一个结点所需的移动结点的平均次数为$\\frac {n}{2}$次,即$O(n)$:\n\n$$\n\\sum_{i=1}^{n+1}{P_i}⋅(n+1−i)=\\frac{1}{n+1}\\cdot\\sum_{i=1}^{n+1}(n−i+1)=\\frac{1}{n+1}\\cdot\\frac{n(n+1)}{2}=\\frac{n}{2}\n$$\n\n### 2.线性表删除操作\n\n```cpp\nbool DeleteSeq( SeqList& L, int i, ElemType& elem )\n{\n    for ( i<1 || i>L.length ) return false;\n    elem = L.elem[i - 1];\n    for ( j = i; j < L.length; j++ )\n        L.elem[j - 1] = L.elem[j];\n    L.length--;\n    return true;\n}\n```\n\n说明:\n- 最好情况: 删除表位$(i=n)$,$O(1)$\n- 最坏情况: 删除表头$(i=1)$,$O(n)$\n- 平均情况: 设$P_i=\\frac{1}{n}$是删除第$i$个位置上结点的概率,则在长度为$n$的线性表中删除一个结点所需移动结点的平均次数为$\\frac{n−1}{2}$次,即$O(n)$:\n\n$$\n\\sum_{i=1}^{n}{Pi}\\cdot{(n−i)}=\\frac{1}{n}\\sum_{i=1}^{n}n(n−i)=\\frac{1}{n}\\cdot\\frac{n(n−1)}{2}=\\frac{n−1}{2}\n$$\n\n### 3.线性表查找操作\n\n```cpp\nint LocateSeq( SeqList& L, ElemType elem )\n{\n    for ( i = 0; i < L.length; i++ )\n        if ( L.elem[i].key == elem.key )\n            return i + 1;\n    return 0;\n}\n```\n\n说明:\n- 最好情况: 查找到表头,$O(1)$\n- 最坏情况: 查找到表尾,$O(n)$\n- 平均情况: 设$P_i=\\frac{1}{n}$是查找元素在第$i(1≤i≤L.length)$个位置上的概率,则在长度为$n$的线性表中查找值为$elem$的元素所需比较的平均次数为$\\frac{n+1}{2}$次,$O(n)$:\n\n$$\n\\sum_{i=1}^{n}P_i\\cdot{i}=\\frac{1}{n}\\cdot\\sum_{i=1}^{n}i=\\frac{1}{n}\\cdot\\frac{n(n+1)}{2}=\\frac{n+1}{2}\n$$\n\n## 二.线性表综合应用\n\n### 1.删除线性表中所有值为$x$的数据元素\n\n```cpp\nbool DeleteX( SeqList& L, ElemType x )\n{\n    int k = 1;\n    for ( i = 1; i <= L.length; i++ )\n        if ( L.elem[i].key != x.key )\n            L.elem[k++] = L.elem[i];\n    L.length = k;\n    return true;\n}\n```\n\n### 2.从有序顺序表中删除值在$[s,t]$的所有元素\n\n```cpp\nbool DeleteS2TOrderedSeq( SeqList& L, int s, int t )\n{\n    for ( i = 1; i <= L.length&&L.elem[i].key < s; i++ );    // 找≥s的第一个元素\n    for ( j = i; j <= L.length&&L.elem[j].key <= t; j++ );    // 找>t的第一个元素\n    while ( j <= L.length )\n        L.elem[i++] = L.elem[j++];\n    L.length = i;\n    return true;\n}\n```\n\n### 3.从顺序表中删除值在$[s,t]$的所有元素\n\n```cpp\nbool DeleteS2TSeq( SeqList& L, int s, int t )\n{\n    int k = 1;\n    for ( i = 1; i <= L.length; i++ )\n        if ( L.elem[i].key<s || L.elem[i].key>t )\n            L.elem[k++] = L.elem[i];\n    L.length = k;\n    return true;\n}\n```\n\n### 4.从有序顺序表中删除所有值重复的元素\n\n```cpp\nbool DeleteSameOrderedSeq( SeqList& L )\n{\n    int k = 1;\n    for ( i = 2; i <= L.length; i++ )\n        if ( L.elem[i].key != L.elem[k].key )\n            L.elem[++k] = L.elem[i];\n    L.length = k;\n    return true;\n}\n```\n\n### 5.将两个有序顺序表合并为一个新的有序顺序表\n\n```cpp\nbool Merge( SeqList A, SeqList B, SeqList& C )\n{\n    int i = 1, j = 1, k = 1;\n    while ( i<=A.length&&j<=B.length )\n    {\n        if ( A.elem[i].key <= B.elem[j].key )\n            C.elem[k++] = A.elem[i++];\n        else\n            C.elem[k++] = B.elem[j++];\n    }\n    while ( i <= A.length ) C.elem[k++] = A.elem[i++];\n    while ( j <= B.length ) C.elem[k++] = B.elem[j++];\n    C.length = k - 1;\n    return true;\n}\n```\n\n### 6.原数组$A[m+n]={a_1,a_2,...,a_m,b_1,b_2,...,b_n}$,现要求转变为$A[m+n]={b_1,b_2,...,b_n,a_1,a_2,...,a_m}$\n\n```cpp\n// 元素倒置\nvoid Reverse( ElemType A[], int s, int e )\n{\n    for ( i = s; i < ( s + e ) / 2; i++ )\n        swap( A[i], A[s + e - i - 1] );\n}\n\nvoid ExChange( ElemType A[], int m, int n )\n{\n    Reverse( A, 0, m );\n    Reverse( A, m, m + n );\n    Reverse( A, 0, m + n );\n} \n```\n\n### 7.线性表$(a_1,a_2,...,a_n)$递增有序,设计算法花最少时间找到数值为$x$的元素:\n\n> 1)找到,则与其后继元素位置互换\n> 2)未找到,将其插入表中并使表中元素仍然递增有序\n\n```cpp\n// 使用折半查找的方法\nvoid SearchExchangeInsert( ElemType A[], int n, ElemType x )\n{\n    int low = 1, high = n;\n    while ( low <= high )\n    {\n        mid = ( low + high ) / 2;\n        if ( x.key == A[mid].key )\n        {\n            if ( mid != n )\n                swap( A[mid], A[mid + 1] );\n            return;\n        }\n        else if ( x.key < A[mid].key ) high = mid - 1;\n        else low = mid + 1;\n    }\n    for ( j = n; j >= high + 1; j-- )\n        A[j + 1] = A[j];\n    A[j + 1] = x;\n}\n```\n\n### 8.设计算法将一维数组$R$中的序列循环左移$p(0<p<n)$个位置(算法思想和6.相同)\n\n```cpp\n// 元素倒置\nvoid Reverse( ElemType A[], int s, int e )\n{\n    for ( i = s; i < ( s + e ) / 2; i++ )\n        swap( A[i], A[s + e - i - 1] );\n}\n\nvoid ShiftLeft( ElemType R[], int n, int p )\n{\n    Reverse( R, 0, p );\n    Reverse( R, p, n );\n    Reverse( R, 0, n );\n}\n```\n\n### 9.长度为$L(L≥1)$的升序序列$S$,处在$⌈L2⌉$个位置的数成为$S$的中位数,设计一个在时空都尽量高效的算法找出两个等长序列$A$和$B$的中位数\n\n```cpp\nint FindMidFromABOrderedSeq( int A[], int B[], int n )\n{\n    int s1, s2, e1, e2, m1, m2;\n    s1 = s2 = 0;\n    e1 = e2 = n - 1;\n    while ( s1 != e1 || s2 != e2 )\n    {\n        m1 = ( s1 + e1 ) / 2;\n        m2 = ( s2 + e2 ) / 2;\n        if ( A[m1] == B[m2] )\n            return A[m1];\n        else if ( A[m1] < B[m2] )\n        {\n            if ( !( ( s1 + e1 ) % 2 ) )\n                s1 = m1, e2 = m2;\n            else\n                s1 = m1 + 1, e2 = m2;\n        }\n        else\n        {\n            if ( !( ( s2 + e2 ) % 2 ) )\n                s2 = m2, e1 = m1;\n            else\n                s2 = m2 + 1, e1 = m1;\n        }\n    }\n    return A[s1] < B[s2] ? A[s1] : B[s2];\n}\n```\n\n## 三.线性表的链式表示\n\n### 1.采用头插法建立单链表\n\n```cpp\nLinkList CreateList( LinkList& L )\n{\n    L = ( LinkList ) malloc( sizeof( LNode ) );\n    L->next = NULL;\n    scanf( \"%d\", &x );\n    while ( x != 9999 )\n    {\n        s = ( LNode* ) malloc( sizeof( LNode ) );\n        s->data = x;\n        s->next = L->next;\n        L->next = s;\n        scanf( \"%d\", &x );\n    }\n    return L;\n}\n```\n\n### 2.采用尾插法建立单链表\n\n```cpp\nLinkList CreateList( LinkList& L )\n{\n    L = ( LinkList ) malloc( sizeof( LNode ) );\n    L->next = NULL;\n    r = L;\n    scanf( \"%d\", &x );\n    while ( x != 9999 )\n    {\n        s = ( LNode* ) malloc( sizeof( LNode ) );\n        s->data = x;\n        r->next=s;\n        r = s;\n        scanf( \"%d\", &x );\n    }\n    r->next = NULL;\n    return L;\n}\n```\n\n## 四.线性表相关综合算法\n\n### 1.递归删除不带头结点的单列表$L$中所有值为$x$的结点\n\n```cpp\nvoid DeleteX( LinkList& L, ElemType x )\n{\n    if ( !L ) return;\n    if ( L->data == x )\n    {\n        q = L;\n        L = L->next;\n        free( q );\n        DeleteX( L, x );\n    }\n    else\n        DeleteX( L->next, x );\n} \n```\n\n### 2.删除带头结点的单链表$L$中所有值为$x$的结点\n\n```cpp\nvoid DeleteX( LinkList& L, ElemType x )\n{\n    pre = L;\n    p = L->next;\n    while ( p )\n    {\n        if ( p->data == x )\n        {\n            q = p;\n            pre->next = p->next;\n            p = p->next;\n            free( q );\n        }\n        else\n        {\n            pre = p; p = p->next;\n        }\n    }\n}\n```\n\n### 3.反向输出带头结点的单链表$L$的每个结点的值\n\n```cpp\nvoid PrintX( LinkList L )\n{\n    if ( !L )return;\n    PrintX( L->next );\n    visit( L );\n}\n```\n\n### 4.删除带头结点单链表$L$中最小值结点\n\n```cpp\nLinkList DeleteMin( LinkList& L )\n{\n    LinkList p, s, pre, q;\n    p = s = L->next;\n    pre = q = L;\n    while ( p )\n    {\n        if(p->data<s->data )\n        {\n            s = p; q = pre;\n        }\n        pre = p;\n        p = p->next;\n    }\n    q->next = s->next;\n    free( s );\n    return L;\n}\n```\n\n### 5.将带头结点的单链表就地逆置,\"就地\"指辅助空间复杂度为$O(1)$\n\n```cpp\nLinkList Reverse( LinkList L )\n{\n    LinkList p, q;\n    p = L->next;\n    L->next = NULL;\n    while ( p )\n    {\n        q = p->next;\n        p->next = L->next;\n        L->next = p;\n        p = q;\n    }\n    return L;\n}\n```\n\n### 6.将带头结点的单链表$L$排序,使其递增有序\n\n```cpp\nvoid InsertSort( LinkList& L )\n{\n    LinkList p, pre, r;\n    p = L->next; r = p->next;\n    p->next = NULL; p = r;\n    while ( p )\n    {\n        r = p->next;\n        pre = L;\n        while ( pre->next&&pre->next->data < p->data )\n            pre = pre->next;\n        p->next = pre->next;\n        pre->next = p;\n        p = r;\n    }\n}\n```\n\n### 7.在带头结点的单链表中,删除值介于$(s,t)$之间的元素\n\n```cpp\nvoid DeleteS2T( LinkList& L, int s, int t )\n{\n    LinkList pre, p;\n    pre = L; p = pre->next;\n    while ( p )\n    {\n        if ( p->data > s && p->data < t )\n        {\n            pre->next = p->next;\n            free( p );\n            p = pre->next;\n        }\n        else\n        {\n            pre = p;\n            p = p->next;\n        }\n    }\n}\n```\n\n### 8.找出两个单链表的公共结点\n\n```cpp\nLinkList SearchCommon( LinkList L1, LinkList L2 )\n{\n    LinkList pA, pB;\n    int lenA, lenB, dist;\n    pA = L1->next, pB = L2->next;\n    lenA = lenB = 0;\n    while ( pA ) { pA = pA->next; lenA++; }\n    while ( pB ) { pB = pB->next; lenB++; }\n    pA = L1->next, pB = L2->next;\n    if ( lenA > lenB )\n    {\n        dist = lenA - lenB;\n        while ( dist-- ) pA = pA->next;\n    }\n    else\n    {\n        dist = lenB - lenA;\n        while ( dist-- ) pB = pB->next;\n    }\n    while ( pA )\n    {\n        if ( pA == pB ) return pA;\n        pA = pA->next, pB = pB->next;\n    }\n    return NULL;\n}\n```\n\n### 9.带表头结点的单链表,按递增次序输出单链表中各结点的数据元素,并释放空间\n\n```cpp\nvoid AscDelete( LinkList& L )\n{\n    LinkList p, s, pre, r;\n    while ( L->next )\n    {\n        s = p = L->next; r = pre = L;\n        while ( p )\n        {\n            if ( p->data < s->data )\n            {\n                s = p; r = pre;\n            }\n            pre = p;\n            p = p->next;\n        }\n        r->next = s->next;\n        visit( s );\n        free( s );\n    }\n    free( L );\n}\n```\n\n### 10.将带头结点的单链表$A$分解成两个带头结点的单链表$A$和$B$,$A$中含有奇数序号元素,$B$中含有偶数序号元素且相对位置不变\n\n```cpp\n// 法一\nLinkList Split( LinkList& A )\n{\n    LinkList p, B, rA, rB;\n    int i = 0;\n    p = A->next;\n    B = ( LinkList ) malloc( sizeof( LNode ) );\n    rA = A; A->next = NULL;\n    rB = B; B->next = NULL;\n    while ( p )\n    {\n        i++;\n        if (i%2)\n        {\n            rA->next = p; rA = p;\n        }\n        else\n        {\n            rB->next = p; rB = p;\n        }\n        p = p->next;\n    }\n    rA->next = NULL;\n    rB->next = NULL;\n    return B;\n}\n```\n\n```cpp\n// 法二\nLinkList Split( LinkList& A )\n{\n    LinkList p, B, rB, pre;\n    int i = 0;\n    B = ( LinkList ) malloc( sizeof( LNode ) );\n    rB = B;\n    pre = A; p = pre->next;\n    while ( p )\n    {\n        i++;\n        if ( i % 2 == 0 )\n        {\n            pre->next = p->next;\n            rB->next = p;\n            rB = p;\n            p = pre->next;\n        }\n        else\n        {\n            pre = p;\n            p = p->next;\n        }\n    }\n    return B;\n}\n```\n\n### 11.$C={a_1,b_1,a_2,b_2,...,a_n,b_n}$为线性表,带有头结点,设计一个就地算法将其拆分为两个线性表,使$A={a_1,a_2,...,a_n}$,$B={b_n,...,b_2,b_1}$\n\n```cpp\nLinkList Split( LinkList& A )\n{\n    LinkList B, pre, p;\n    int i = 0;\n    B = ( LinkList ) malloc( sizeof( LNode ) );\n    pre = A; p = pre->next;\n    while ( p )\n    {\n        i++;\n        if ( i % 2 == 0 )\n        {\n            pre->next = p->next;\n            p->next = B->next;\n            B->next = p;\n            p = pre->next;\n        }\n        else\n        {\n            pre = p;\n            p = p->next;\n        }\n    }\n    return B;\n}\n```\n\n### 12.在递增有序的带头结点的单链表中,数值相同的只保留一个,使表中不再有重复的元素\n\n```cpp\nvoid DeleteSame( LinkList& L )\n{\n    LinkList p, q;\n    p = L->next;\n    while ( p )\n    {\n        q = p->next;\n        if ( q&&q->data == p->data )\n        {\n            p->next = q->next;\n            free( q );\n        }\n        else\n            p = p->next;\n    }\n}\n```\n\n### 13.将两个按元素值递增的单链表合并为一个按元素值递减的单链表\n\n```cpp\nvoid MergeList( LinkList& LA, LinkList& LB )\n{\n    LinkList pA, pB, q;\n    pA = LA->next; pB = LB->next;\n    LA->next = NULL;\n    while ( pA&&pB )\n    {\n        if ( pA->data <= pB->data )\n        {\n            q = pA->next;\n            pA->next = LA->next;\n            LA->next = pA;\n            pA = q;\n        }\n        else\n        {\n            q = pB->next;\n            pB->next = LA->next;\n            LA->next = pB;\n            pB = q;\n        }\n    }\n    if ( pA )\n        pB = pA;\n    while(pB )\n    {\n        q = pB->next;\n        pB->next = LA->next;\n        LA->next = pB;\n        pB = q;\n    }\n    free( LB );\n}\n```\n\n### 14.$A,B$为两个元素递增有序的单链表(带头结点),设计算法从$A,B$中公共元素产生单链表$C$,要求\n\n```cpp\nvoid MergeList( LinkList& LA, LinkList& LB )\n{\n    LinkList pA, pB, q;\n    pA = LA->next; pB = LB->next;\n    LA->next = NULL;\n    while ( pA&&pB )\n    {\n        if ( pA->data <= pB->data )\n        {\n            q = pA->next;\n            pA->next = LA->next;\n            LA->next = pA;\n            pA = q;\n        }\n        else\n        {\n            q = pB->next;\n            pB->next = LA->next;\n            LA->next = pB;\n            pB = q;\n        }\n    }\n    if ( pA )\n        pB = pA;\n    while ( pB )\n    {\n        q = pB->next;\n        pB->next = LA->next;\n        LA->next = pB;\n        pB = q;\n    }\n    free( LB );\n}\n```\n\n### 15.求两个元素递增排列的链表(带头结点)$A$和$B$的交集并存放于$A$链表中,并释放其他结点\n\n```cpp\nvoid Intersect( LinkList& LA, LinkList& LB )\n{\n    LinkList pA, pB, r, q;\n    pA = LA->next; pB = LB->next;\n    r = LA; LA->next = NULL;\n    while ( pA&&pB )\n    {\n        if ( pA->data == pB->data )\n        {\n            r->next = pA;\n            r = pA;\n            pA = pA->next;\n            q = pB;\n            pB = pB->next;\n            free( q );\n        }\n        else if ( pA->data < pB->data )\n        {\n            q = pA;\n            pA = pA->next;\n            free( q );\n        }\n        else\n        {\n            q = pB;\n            pB = pB->next;\n            free( q );\n        }\n    }\n    r->next = NULL;\n    while ( pA )\n    {\n        q = pA;\n        pA = pA->next;\n        free( q );\n    }\n    while ( pB )\n    {\n        q = pB;\n        pB = pB->next;\n        free( q );\n    }\n    free( LB );\n}\n```\n\n### 16.判断单链表序列$B$是否是$A$的连续子序列(不带头结点)\n\n```cpp\nbool IsSubsequence( LinkList A, LinkList B )\n{\n    LinkList pA, pB, h;\n    pA = A; pB = B;\n    h = pA;\n    while ( pA&&pB )\n    {\n        if ( pA->data == pB->data )\n        {\n            pA = pA->next;\n            pB = pB->next;\n        }\n        else\n        {\n            h = h->next;\n            pA = h;\n            pB = B;\n        }\n    }\n    if ( pB ) return false;\n    return true;\n}\n```\n\n### 17.判断带头结点的循环双链表是否对称\n\n```cpp\nbool IsSymmetry( DLinkList L )\n{\n    DLinkList p, q;\n    p = L->next; q = L->prior;\n    while ( p != q && q->next != p )\n    {\n        if ( p->data != q->data )\n            return false;\n        p = p->next;\n        q = q->next;\n    }\n    return true;\n}\n```\n\n### 18.将循环单链表$h2$链接到$h1$之后\n\n```cpp\nLinkList Link( LinkList& h1, LinkList& h2 )\n{\n    LinkList p;\n    p = h1;\n    while ( p->next != h1 )p = p->next;\n    p->next = h2;\n    p = h2;\n    while ( p->next != h2 )p = p->next;\n    p->next = h1;\n    return h1;\n}\n```\n\n### 19.带头结点的循环链表,按递增次序输出循环链表中各结点的数据元素,并释放空间\n\n```cpp\nvoid AscDelete( LinkList& L )\n{\n    LinkList p, s, r, pre;\n    while ( L->next != L )\n    {\n        s = p = L->next; r = pre = L;\n        while ( p != L )\n        {\n            if ( p->data < s->data )\n            {\n                s = p; r = pre;\n            }\n            pre = p;\n            p = p->next;\n        }\n        visit( s );\n        r->next = s->next;\n        free( s );\n    }\n    free( L );\n}\n```\n\n### 20.查找单链表(带头结点)中倒数第$k$个位置的结点,成功:则输出并返回$true$,否则只返回$false$\n\n```cpp\nbool SearchBackwardK( LinkList L, int k )\n{\n    LinkList p, q;\n    int count;\n    p = q = L->next;\n    count = 0;\n    while (p)\n    {\n        if ( count < k ) count++;\n        else q = q->next;\n        p = p->next;\n    }\n    if ( count < k ) return false;\n    visit( q );\n    return true;\n}\n```\n\n### 21.链表中$data$绝对值相等的点,只保留第一次出现的结点$(|data|≤n)$\n\n```cpp\nvoid DeleteSameAbs( LinkList L, int n )\n{\n    LinkList pre, p;\n    int *B, pos;\n    B = ( int * ) malloc( sizeof( int )*( n + 1 ) );\n    for ( int i = 0; i < n + 1; i++ )\n        B[i] = 0;\n    pre = L; p = L->next;\n    while ( p )\n    {\n        pos = p->data > 0 ? p->data : -p->data;\n        if ( B[pos] == 0)\n        {\n            B[pos] = 1; pre = p; p = p->next;\n        }\n        else\n        {\n            pre->next = p->next; free( p ); p = pre->next;\n        }\n    }\n    free( B );\n}\n```\n\n### 22.带头结点的循环双链表递增排序\n\n```cpp\nvoid AscSort( DLinkList L )\n{\n    DLinkList p, q, r;\n    if ( !L ) return;\n    p = L->next; q = p->next; r = q->next;\n    while ( q!=L )\n    {\n        while ( p != L && p->data > q->data )\n            p = p->prior;\n        // 脱链结点p\n        q->prior->next = r;\n        r->prior = q->prior;\n        // 插入节点p\n        q->next = p->next;\n        q->prior = p;\n        p->next->prior = q;\n        p->next = q;\n        // 归位(相对位置)\n        q = r;\n        p = q->prior;\n        r = r->next;\n    }\n}\n```","tags":["顺序表"],"categories":["algorithm"]},{"title":"[algorithm]栈和队列","url":"%2Fposts%2F6027%2F","content":"## 一.栈和队列综合(算法)\n\n### 1.判断单链表(带头结点)的结点值(字符型)是否中心对称\n\n```cpp\nbool IsSymmetry( LinkList& L )\n{\n    char S[MAXSIZE];\n    int top = -1, len = 0, i;\n    LinkList p;\n    p = L->next;\n    while ( p ) { p = p->next; len++; }\n    p = L->next;\n    for (i=0;i<len/2;i++)\n    {\n        S[++top] = p->data;\n        p = p->next;\n    }\n    i--;\n    if ( len % 2 )\n        p = p->next;\n    while ( top != -1 )\n    {\n        if ( p->data != S[top] )\n            return false;\n        top--;\n        p = p->next;\n    }\n    return true;\n}\n```\n\n### 2.共享栈由两个顺序栈S1,S2构成,总大小为100,请设计S1,S2入栈,出栈的算法\n\n```cpp\n#define MAXSIZE 100\nElemType S[MAXSIZE];\nint top[2] = { -1,MAXSIZE };\nbool Push( int i, ElemType x )\n{\n    if ( i < 0 || i>1 || top[1] - top[0] == 1 )\n        return false;\n    if ( i == 0 ) S[++top[0]] = x;\n    else S[--top[1]] = x;\n    return true;\n}\n\nbool Pop( int i, ElemType x )\n{\n    if ( i < 0 || i>1 \n         || ( i == 0 && top[0] == -1 ) \n         || ( i == 1 && top[1] == MAXSIZE ) )\n        return false;\n    if ( i == 0 ) x = S[top[0]--];\n    else x = S[top[1]++];\n    return true;\n}\n```\n\n### 3.如果希望循环队列中的元素都能得到利用,则需设置一个标志域tag,并以tag的值为0或1来区分队头指针front和队尾rear相同时的队列状态是\"空\"还是\"满\",编写与此结构相应的入队和出队算法\n\n```cpp\nElemType Q[MAXSIZE];\nint front = -1, rear = -1;\n// 队空条件:    front==rear&&tag==0\n// 队满条件:    front==rear&&tag==1\n// 进队操作:    rear=(rear+1)%MAXSIZE;\n//            Q[rear]=x;\n//            tag=1;\n// 出队操作:    front=(front+1)%MAXSIZE;\n//            x=Q[front];\n//            tag=0;\n```\n\n#### 1)\"tag\"法循环队列入队算法\n\n```cpp\nbool EnQueue( ElemType x )\n{\n    if ( front == rear && tag == 1 )\n        return false;\n    rear = ( rear + 1 ) % MAXSIZE;\n    Q[rear] = x;\n    tag = 1;\n    return true;\n}\n```\n\n#### 2)\"tag\"法循环队列出队算法\n\n```cpp\nbool DeQueue( ElemType& x )\n{\n    if ( front == rear && tag == 0 )\n        return false;\n    front = ( front + 1 ) % MAXSIZE;\n    x = Q[front];\n    tag = 0;\n    return true;\n}\n```\n\n### 4.Q是一个队列,S是一个空栈,实现将队列中的元素逆置的算法\n\n```cpp\nElemType S[MAXSIZE], Q[MAXSIZE];\nint top = -1, front = -1, rear = -1;\nvoid Inverse(ElemType S[], ElemType Q[])\n{\n    ElemType x;\n    while ( front != rear )\n    {\n        x = Q[++front];\n        S[++top] = x;\n    }\n    while ( top != -1 )\n    {\n        x = S[top--];\n        Q[++rear] = x;\n    }\n}\n```\n\n### 5.利用两个栈S1,S2模拟一个队列\n\n>   已知栈的4个运算如下:\n**    void Push(Stack& S, ElemType x);\n    void Pop(Stack& S, ElemType& x)\n    bool IsEmpty(Stack& S);\n    bool IsOverflow( Stack& S );**\n\n```cpp\nbool EnQueue( Stack& S1, Stack& S2, ElemType x )\n{\n    if ( !IsOverflow( S1 ) )\n    {\n        Push( S1, x );\n        return true;\n    }\n    if ( !IsEmpty( S2 ) )\n        return false;\n    while (!IsEmpty(S1))\n    {\n        Pop( S1, t );\n        Push( S2, t );\n    }\n    Push( S1, x );\n    return true;\n}\n\nbool DeQueue( Stack& S1, Stack& S2, ElemType& x )\n{\n    if (!IsEmpty(S2))\n    {\n        Pop( S2, x ); return true;\n    }\n    if ( IsEmpty( S1 ) )\n        return false;\n    while (!IsEmpty(S1))\n    {\n        Pop( S1, t ); \n        Push( S2, t );\n    }\n    Pop( S2, x );\n    return true;\n}\n\nbool IsEmpty( Stack& S1, Stack& S2 )\n{\n    if ( IsEmpty( S1 ) && IsEmpty( S2 ) )\n        return true;\n    return false;\n}\n```\n\n### 6.括号匹配问题:判别表达式中括号是否匹配(只含有(),[],{})\n\n```cpp\nbool IsBracketMatch( char*str )\n{\n    char S[MAXSIZE];\n    int top = -1;\n    for ( int i = 0; str[i]; i++ )\n    {\n        char c = str[i];\n        switch ( c )\n        {\n        case '(':\n        case '[':\n        case '{':\n            S[++top] = c;\n            break;\n        case ')':\n            c = S[top--];\n            if ( c != '(' )return false;\n            break;\n        case ']':\n            c = S[top--];\n            if ( c != '[' )return false;\n            break;\n        case '}':\n            c = S[top--];\n            if ( c != '{' )return false;\n            break;\n        default:\n            break;\n        }\n    }\n    return top == -1;\n}\n```\n\n### 7.利用栈实现以下递归函数的非递归计算:\n\n$$ \nPn(x)= \n\\begin{cases}\n    1,  & n=0 \\\\\n    2x, & n=1 \\\\\n    2x\\cdot{P_{n-1}}(x)-2(n-1)\\cdot{P_{n-2}}(x) & n>1\n\\end{cases}\n$$\n\n```cpp\ndouble P( int n, double x )\n{\n    struct Stack\n    {\n        int n;        // 层\n        double val;    // 数值结果\n    }S[MAXSIZE];\n    int top = -1, fv1 = 1, fv2 = 2 * x;\n    for ( int i = n; i > 1; i-- )\n        S[++top].n = i;\n    while ( top != -1 )\n    {\n        S[top].val = 2 * x*fv2 - 2 * ( S[top].n - 1 )*fv1;\n        fv1 = fv2;\n        fv2 = S[top--].val;\n    }\n    if ( n == 0 ) return fv1;\n    return fv2;\n}\n```","tags":["队列"],"categories":["algorithm"]},{"title":"[algorithm]树与二叉树","url":"%2Fposts%2F45464%2F","content":"## 一.树与二叉树相关算法\n\n### 1.二叉树按顺序结构存储,求编号为i和j的两个结点的最近公共祖先结点的值\n\n```cpp\nElemType CommonAncestor( SeqTree T, int i, int j )\n{\n    while ( i != j )\n    {\n        if ( i > j ) i /= 2;\n        else j /= 2;\n    }\n    return T[i];\n}\n```\n\n### 2.二叉树前序遍历非递归算法\n\n```cpp\nvoid PreOrder( BiTree T )\n{\n    BiTree S[MAXSIZE], p;\n    int top = -1;\n    p = T;\n    while ( p || top != -1 )\n    {\n        if (p)\n        {\n            visit( p );\n            S[++top] = p; p = p->lchild;\n        }\n        else\n        {\n            p = S[top--]; p = p->rchild;\n        }\n    }\n}\n```\n\n### 3.二叉树中序遍历非递归算法\n\n```cpp\nvoid InOrder( BiTree T )\n{\n    BiTree S[MAXSIZE], p;\n    int top = -1;\n    p = T;\n    while ( p || top != -1 )\n    {\n        if (p )\n        {\n            S[++top] = p; p = p->lchild;\n        }\n        else\n        {\n            p = S[top--]; visit( p ); p = p->rchild;\n        }\n    }\n}\n```\n\n### 4.二叉树后序遍历非递归算法\n\n```cpp\nvoid PostOrder( BiTree T )\n{\n    BiTree Q[MAXSIZE], p, r;\n    int top = -1;\n    p = T; r = NULL;\n    while ( p || top != -1 )\n    {\n        if (p)    // 走到最左边\n        {\n            S[++top] = p; p = p->lchild;\n        }\n        else    // 向右\n        {\n            p = S[top];\n            if (p->rchild&&p->rchild!=r)    // 转向右\n                p = p->rchild;\n            else    // 根\n            {\n                p = S[top--];\n                visit( p );\n                r = p;\n                p = NULL;\n            }\n        }\n    }\n}\n```\n\n### 5.二叉树层次遍历算法\n\n```cpp\nvoid LevelOrder( BiTree T )\n{\n    BiTree Q[MAXSIZE], p;\n    int front = -1, rear = -1;\n    Q[++rear] = T;\n    while ( front != rear )\n    {\n        p = Q[++front];\n        visit( p );\n        if ( p->lchild ) Q[++rear] = p->lchild;\n        if ( p->rchild ) Q[++rear] = p->rchild;\n    }\n}\n```\n\n### 6.二叉树的自下而上,从右到左的层次遍历算法\n\n```cpp\nvoid InvertLevel( BiTree T )\n{\n    BiTree S[MAXSIZE], Q[MAXSIZE], p;\n    int front = -1, rear = -1, top = -1;\n    Q[++rear] = T;\n    while ( front != rear )\n    {\n        p = Q[++front];\n        S[++top] = p;\n        if ( p->lchild ) Q[++rear] = p->lchild;\n        if ( p->rchild ) Q[++rear] = p->rchild;\n    }\n    while ( top!=-1 )\n    {\n        p = S[top--]; visit( p );\n    }\n}\n```\n\n### 7.求二叉树高度(递归)\n\n```cpp\nint BtDepth( BiTree T )\n{\n    if ( T == NULL ) return 0;\n    int ldepth, rdepth;\n    ldepth = BtDepth( T->lchild );\n    rdepth = BtDepth( T->rchild );\n    return ldepth > rdepth ? ldepth + 1 : rdepth + 1;\n}\n```\n\n### 8.求二叉树高度(非递归)\n\n> 法一思路:后序遍历,最大栈长即为树的高度\n\n```cpp\nint BtDepth( BiTree T )\n{\n    BiTree S[MAXSIZE], p, r;\n    int top = -1, depth = 0;\n    while ( p || top != -1 )\n    {\n        if ( p )\n        {\n            S[++top] = p; p = p->lchild;\n        }\n        else\n        {\n            p = S[top];\n            if ( p->rchild&&p->rchild != r )\n                p = p->rchild;\n            else\n            {\n                if (top+1>depth)\n                    depth = top + 1;\n                p = S[top--];\n                r = p;\n                p = NULL;\n            }\n        }\n    }\n    return depth;\n}\n```\n\n> 法二思路:层次遍历,层数即为高度\n\n```cpp\nint BtDepth( BiTree T )\n{\n    BiTree Q[MAXSIZE], p;\n    int front = -1, rear = -1, last = 0, depth = 0;\n    Q[++rear] = T;\n    while ( front != rear )\n    {\n        p = Q[++front];\n        if ( p->lchild )\n            Q[++rear] = p->lchild;\n        if ( p->rchild )\n            Q[++rear] = p->rchild;\n        if ( front == last )\n        {\n            depth++;\n            last = rear;\n        }\n    }\n    return depth;\n}\n```\n\n### 9.先许遍历序列和中序遍历序列分别存放于两个一维数组A[1...n],B[1...n]中,编写算法建立该二叉树的二叉链表\n\n```cpp\nBiTree PreInCreate( ElemType A[], ElemType B[], int l1, int h1, int l2, int h2 )\n{\n    BiTree root = ( BiTree ) malloc( sizeof( BiTNode ) );\n    int i, llen, rlen;\n    root->data = A[l1];\n    for ( i = l2; B[i] != root->data; i++ );\n    llen = i - l2;\n    rlen = h2 - i;\n    if ( llen )\n        root->lchild = PreInCreate( A, B, l1 + 1, l1 + llen, l2, l2 + llen - 1 );\n    else\n        root->rchild = NULL;\n    if ( rlen )\n        root->rchild = PreInCreate( A, B, h1 - rlen + 1, h1, h2 - rlen + 1, h2 );\n    else\n        root->rchild = NULL;\n    return root;\n}\n```\n\n### 10.判断二叉树是否是完全二叉树\n\n```cpp\nbool IsComplete( BiTree T )\n{\n    if ( T == NULL ) return true;\n    BiTree Q[MAXSIZE], p;\n    int front = -1, rear = -1;\n    Q[++rear] = T;\n    while ( front != rear )\n    {\n        p = Q[++front];\n        if (p)\n        {\n            Q[++rear] = p->lchild;\n            Q[++rear] = p->rchild;\n        } \n        else\n        {\n            while ( front != rear )\n            {\n                p = Q[++front];\n                if ( p ) return false;\n            }\n        }\n    }\n    return true;\n}\n```\n\n### 11.计算一棵给定二叉树的所有双分支结点个数\n\n```cpp\nint N2Nodes( BiTree T )\n{\n    if ( T == NULL ) return 0;\n    if ( T->lchild && T->rchild )\n        return N2Nodes( T->lchild ) + N2Nodes( T->rchild ) + 1;\n    return N2Nodes( T->lchild ) + N2Nodes( T->rchild );\n}\n```\n\n### 12.将二叉树中所有结点的左,右子树进行交换\n\n```cpp\nvoid SwapTree( BiTree T )\n{\n    if ( T == NULL ) return;\n    SwapTree( T->lchild );\n    SwapTree( T->rchild );\n    swap( T->lchild, T->rchild );\n}\n```\n\n### 13.求二叉树先序遍历序列中第k(1≤k≤二叉树结点个数)个结点的值\n\n```cpp\nint i = 1;\nElemType PreNodeK( BiTree T, int k )\n{\n    if ( T == NULL ) return '#';\n    if ( i == k ) return T->data;\n    i++;    // 下一个结点\n    ElemType ch = PreNodeK( T->lchild, k );\n    if ( ch != '#' ) return ch;\n    ch = PreNodeK( T->rchild, k );\n    return ch;\n}\n```\n\n### 14.二叉树中,对于每一个元素值为x的结点,删去以它为根的子树,并释放相应的空间\n\n```cpp\nvoid DeleteNode( BiTree T )\n{\n    if ( T == NULL ) return;\n    DeleteNode( T->lchild );\n    DeleteNode( T->rchild );\n    free( T );\n}\n```\n> 法一:递归\n\n```cpp\nvoid DeleteAllXNode( BiTree T, ElemType x )\n{\n    if ( T == NULL ) return;\n    if ( T->data == x )\n    {\n        DeleteNode( T ); return;\n    }\n    DeleteAllXNode( T->lchild, x );\n    DeleteAllXNode( T->rchild, x );\n}\n```\n\n> 法二:非递归\n\n```cpp\nvoid DeleteAllXNode( BiTree T, ElemType x )\n{\n    if ( T == NULL ) return;\n    BiTree Q[MAXSIZE], p;\n    int front = -1, rear = -1;\n    Q[++rear] = T;\n    while ( front != rear )\n    {\n        p = Q[++front];\n        if ( p->data == x ) DeleteNode( p );\n        else\n        {\n            if ( p->lchild ) Q[++rear] = p->lchild;\n            if ( p->rchild ) Q[++rear] = p->rchild;\n        }\n    }\n}\n```\n\n### 15.输出二叉树中值为x的结点(≤1)个的所有祖先\n\n> 法一:递归\n\n```cpp\nbool AllAncestorX( BiTree T, ElemType x )\n{\n    if ( T == NULL ) return false;\n    if ( T->data == x ) return true;\n    bool b1, b2;\n    b1 = AllAncestorX( T->lchild, x );\n    b2 = AllAncestorX( T->rchild, x );\n    if ( b1 || b2 ) visit( T );\n    return b1 || b2;\n}\n```\n\n> 法二:非递归\n> 思路: 后序遍历非递归方式中,保留在栈中所有元素(除栈顶外)必然是栈顶的祖先结点,只要找到x结点,将所有结点出栈即可\n\n```cpp\nvoid AllAncestorX( BiTree T, ElemType x )\n{\n    if ( T == NULL ) return;\n    BiTree S[MAXSIZE], p, r;\n    int top = -1;\n    p = T; r = NULL;\n    while ( p||top!=-1 )\n    {\n        if (p)\n        {\n            S[++top] = p; p = p->lchild;\n        }\n        else\n        {\n            p = S[top];\n            if ( p->rchild&&p->rchild != r )\n                p = p->rchild;\n            else\n            {\n                p = S[top--];\n                if (p->data==x)\n                {\n                    while ( top != -1 )\n                    {\n                        p = S[top--]; visit( p );\n                    }\n                }\n                r = p;\n                p = NULL;\n            }\n        }\n    }\n}\n```\n\n### 16.p,q为二叉树中任意两个结点的指针,编写算法找到p,q的最近公共祖先结点(递归)\n\n```cpp\n// 思路: ①左子树中能找到p(或q),右子树中能找到q(或p),的结点一定为p,q的最近公共结点\n//       ②p,q都在右子树上,则深度低的为公共祖先\n//       ③p,q都在左子树上,则深度低的为公共祖先\n//    三种情况      o  <-root(此时为公共祖先)     o  <-root                             o <-root\n//                / \\                            \\                                   /\n//           p-> o   o  <-q                       o  <-p(此时为公共祖先为right)      o  <-p(此时为公共祖先left)\n//                                                 \\                               /\n//                                                  o  <-q                        o  <-q\nBiTree Ancestor( BiTree root, BiTNode *p, BiTNode *q )\n{\n    if ( !root || !p || !q ) return NULL;\n    if ( p == root || q == root ) return root;\n    BiTree left, right;\n    /* \n     * ①在左子树中,若找到p,q中一个,则返回一个\n     * ②在左子树中,若找到p,q(全),则返回较近的一个(高度较低的)\n     */\n    left = Ancestor( root->lchild, p, q );\n    /*\n     * ①在右子树中,若找到p,q中一个,则返回一个\n     * ②在右子树中,若找到p,q(全),则返回较近的一个(高度较低的)\n     */\n    right = Ancestor( root->rchild, p, q );    \n    if ( left&&right ) return root;\n    return left ? left : right;\n}\n```\n\n### 17.求非空二叉树的宽度\n\n```cpp\nint TreeWidth( BiTree T )\n{\n    BiTree Q[MAXSIZE], p;\n    int front = -1, rear = -1, maxWidth = 0;\n    Q[++rear] = T;\n    while ( front != rear )\n    {\n        int width = rear - front;\n        if ( maxWidth < width )\n            maxWidth = width;\n        while ( width-- )\n        {\n            p = Q[++front];\n            if ( p->lchild ) Q[++rear] = p->lchild;\n            if ( p->rchild ) Q[++rear] = p->rchild;\n        }\n    }\n    return maxWidth;\n}\n```\n\n### 18.一棵满二叉树(所有结点值均不同),已知其先序序列为pre,设计算法求其后序序列post\n\n```cpp\n// 思路: 每次都会确定出后序的一个位置并划分为左右两块,再分别在这左右两块中继续确定其他元素 \n//  先序: x|    |    |\n//  后序:  |    |    |x\nvoid PreToPost( ElemType pre[], int l1, int h1, ElemType post[], int l2, int h2 )\n{\n    if ( h1 < l1 ) return;\n    post[h2] = pre[l1]; // 确定出一个后序位置\n    int half = ( h1 - l1 ) / 2;\n    PreToPost( pre, l1 + 1, l1 + half, post, l2, l2 + half - 1 );\n    PreToPost( pre, h1 - half + 1, h1, post, h2 - half, h2 - 1 );\n}\n```\n\n### 19.将二叉树叶子结点按从左到右连成单链表,表头指针为head,叶结点的右指针域存放单链表指针\n\n```cpp\nBiTree head, pre = NULL;\nBiTree InOrder( BiTree bt )\n{\n    if ( bt == NULL ) return NULL;\n    InOrder( bt->lchild );\n    if ( !bt->lchild && !bt->rchild )\n    {\n        if (!pre)\n        {\n            head = pre = bt;\n        }\n        else\n        {\n            pre->rchild = bt; pre = bt;\n        }\n    }\n    InOrder( bt->rchild );\n    pre->rchild = NULL;\n    return head;\n}\n```\n\n### 20.判断两棵二叉树是否相似.(注:不要求结点值相同,只要树的外形相同即可)\n\n```cpp\nbool Similar( BiTree T1, BiTree T2 )\n{\n    if ( T1 == NULL && T2 == NULL ) \n        return true;\n    else if ( T1 == NULL || T2 == NULL ) \n        return false;\n    else if ( Similar( T1->lchild, T2->lchild ) && Similar( T1->rchild, T2->rchild ) )\n        return true;\n    return false;\n}\n```\n\n### 21.将表达式树转换为等价的中缀表达式(通过括号反映操作符的计算次序)并输出\n\n```cpp\n// 思路: 表达式树的中序序列加上必要的括号即为等价的中缀表达式.除根结点外,遍历到其他结点时在遍历其左子树之前加上左括号,在遍历完右子树后加上右括号\nvoid BiTreeToExp( BiTree T, int deep )\n{\n    if ( T == NULL ) return;\n    else if ( !T->lchild && !T->rchild ) visit( T );\n    else\n    {\n        if ( deep > 1 ) printf( \"(\" );\n        BiTreeToExp( T->lchild, deep + 1 );\n        visit( T );\n        BiTreeToExp( T->rchild, deep + 1 );\n        if ( deep > 1 ) printf( \"(\" );\n    }\n}\n```\n\n### 22.求孩子兄弟表示法存储的森林的叶子节点数\n\n```cpp\ntypedef struct CSNode\n{\n    ElemType data;\n    struct CSNode *firstchild, *nextsibling;\n}CSNode, *CSTree;\n\nint Leaves( CSTree T )\n{\n    if ( T == NULL ) return 0;\n    if ( T->firstchild == NULL )\n        return 1 + Leaves( T->nextsibling );\n    else\n        return Leaves( T->firstchild ) + Leaves( T->nextsibling );\n}\n```\n\n### 23.以孩子兄弟链表为存储结构,求树的高度(深度)(递归)\n\n```cpp\nint Height( CSTree T )\n{\n    if ( T == NULL ) return 0;\n    int hc, hs;\n    hc = Height( T->firstchild ) + 1;\n    hs = Height( T->nextsibling );\n    return hc > hs ? hc : hs;\n}\n```\n\n### 24.二叉排序树的查找(非递归)\n\n```cpp\nBiTree BSTSearch( BiTree T, ElemType key )\n{\n    while ( T && key != T->data )\n    {\n        if ( key < T->data )\n            T = T->lchild;\n        else\n            T = T->rchild;\n    }\n    return T;\n}\n```\n或\n```cpp\nBiTree BSTSearch( BiTree T, ElemType key )\n{\n    while ( T )\n    {\n        if ( T->data == key ) return T;\n        else if ( T->data > key )\n            T = T->lchild;\n        else\n            T = T->rchild;\n    }\n    return T;\n}\n```\n\n### 25.二叉排序树的插入(递归)\n\n```cpp\nbool BSTInsert( BiTree& T, ElemType key )\n{\n    if (!T)\n    {\n        T = ( BiTree ) malloc( sizeof( BiTNode ) );\n        T->data = key;\n        T->lchild = T->rchild = NULL;\n        return true;\n    }\n    else if ( T->data == key ) return false;\n    else if ( T->data > key ) return BSTInsert( T->lchild, key );\n    else return BSTInsert( T->rchild, key );\n}\n```\n\n### 26.计算二叉树的带权路径长度(递归)\n\n```cpp\nint wpl = 0;\nint WPL_PreOrder( BiTree T, int deep )\n{\n    if ( T == NULL ) return 0;\n    if ( !T->lchild && !T->rchild )\n        wpl += deep * T->weight;\n    else\n    {\n        if ( T->lchild ) WPL_PreOrder( T->lchild, deep + 1 );\n        if ( T->rchild ) WPL_PreOrder( T->rchild, deep + 1 );\n    }\n    return wpl;\n}\n```\n\n### 27.计算二叉树的带权路径长度(非递归)\n\n```cpp\n// 思路: 层序遍历的思想\nint wpl = 0;\nint WPL_LevelOrder( BiTree T )\n{\n    if ( T == NULL ) return 0;\n    BiTree Q[MAXSIZE], p;\n    int front = -1, rear = -1, depth = 0, last = 0;\n    Q[++rear] = T;\n    while ( front != rear )\n    {\n        p = Q[++front];\n        if ( !p->lchild && !p->rchild )\n            wpl += depth * p->weight;\n        else\n        {\n            if ( p->lchild ) Q[++rear] = p->lchild;\n            if ( p->rchild ) Q[++rear] = p->rchild;\n        }\n        if ( front == last )\n        {\n            depth++; last = rear;\n        }\n    }\n    return wpl;\n}\n```\n\n### 28.判断二叉树是否为二叉排序树\n\n```cpp\nElemType preVal = MIN;\nbool IsBST( BiTree T )\n{\n    if ( T == NULL ) return true;\n    if ( !IsBST( T->lchild ) ) return false;\n    if ( preVal >= T->data )\n        return false;\n    else\n        preVal = T->data;\n    if ( !IsBST( T->rchild ) ) return false;\n    return true;\n}\n```\n\n### 29.求出指定结点在二叉排序树中的层次\n\n```cpp\nint Level( BiTree T, BiTree p )\n{\n    if ( T == NULL ) return 0;\n    int n = 1;\n    while ( T->data != p->data )\n    {\n        n++;\n        if ( p->data < T->data )\n            T = T->lchild;\n        else\n            T = T->rchild;\n    }\n    return n;\n}\n```\n\n### 30.判断二叉树是否为平衡二叉树\n\n```cpp\nbool IsAVL( BiTree T, int& h )\n{\n    int h1 = 0, h2 = 0;\n    if (T==NULL )\n    {\n        h = 0; return true;\n    }\n    if ( IsAVL( T->lchild, h1 ) && IsAVL( T->rchild, h2 ) )\n    {\n        if ( abs( h1 - h2 ) <= 1 )\n        {\n            h = 1 + ( h1 > h2 ? h1 : h2 );\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n### 31.从大到小输出二叉排序中所有值不小于k的关键字\n\n```cpp\nvoid DesOutput( BiTree T, ElemType k )\n{\n    if ( T == NULL ) return;\n    DesOutput( T->rchild, k );\n    if ( T->data >= k )\n        visit( T );\n    else\n        return;\n    DesOutput( T->lchild, k );\n}\n```\n\n### 32.在二叉排序树上查找第k(1≤k≤n)小的元素,要求平均时间复杂度为O(log2n)二叉排序树上的每个结点中除data,lchild,rchild外,还增加一个count成员,保存以该结点为根的子树上的结点个数\n\n> 法一\n\n```cpp\nBiTree SearchSmallK( BiTree T, int k )\n{\n    if ( k<1 || k>T->count ) return NULL;\n    if ( T->lchild )\n    {\n        if ( k <= T->lchild->count )\n            return SearchSmallK( T->lchild, k );\n        else if ( k == T->lchild->count + 1 )\n            return T;\n        else\n            return SearchSmallK( T->rchild, k - ( T->lchild->count + 1 ) );\n    }\n    else\n    {\n        if ( k == 1 ) return T;\n        else return SearchSmallK( T->rchild, k - 1 );\n    }\n}\n```\n\n> 法二\n\n```cpp\nBiTree SearchSmallK( BiTree T, int k )\n{\n    if ( k<1 || k>T->count ) return NULL;\n    if ( T->lchild )\n    {\n        if ( k <= T->lchild->count )\n            return SearchSmallK( T->lchild, k );\n        else\n            k -= T->lchild->count;\n    }\n    if ( k == 1 ) return T;\n    if ( T->rchild )\n        return SearchSmallK( T->rchild, k - 1 );\n}\n```\n\n### 33.对于含有+,−,∗,/及括号的算术表达式(中缀表达式)写一个算法,将该表达式构造成相应的二叉树表示\n\n```cpp\n// 思想: 最后使用的操作符作为根.即:先+,-后*,/\n// 例如: a+b*(c-d)-e/f构造的表达式树如下:\n//                -\n//               /  \\\n//              +    /\n//             / \\  / \\\n//            a  *  e  f\n//              / \\\n//             b   -\n//                / \\\n//               c   d\n// 通过该表达式树,可以很容易得到:\n// 前缀表达式: -+a*b-cd/ef\n// 中缀表达式: a+b*c-d-e/f\n// 后缀表达式: abcd-*+ef/-\nBiTNode* BuildTree( char* exp, int s, int e )\n{\n    if ( e - s == 1 )\n    {\n        BiTNode* p = ( BiTNode* ) malloc( sizeof( BiTNode ) );\n        p->data = exp[s];\n        p->lchild = p->rchild = NULL;\n        return p;\n    }\n    int c1 = -1, c2 = -1, c = 0, i;\n    for ( i = s; i < e; i++ )\n    {\n        if ( exp[i] == '(' ) c++;\n        else if ( ( exp[i] == '+' || exp[i] == '-' ) && !c )\n            c1 = i;\n        else if ( ( exp[i] == '*' || exp[i] == '/' ) && !c )\n            c2 = i;\n    }\n    if ( c1 < 0 ) c1 = c2;\n    if ( c1 < 0 ) return BuildTree( exp, s + 1, e - 1 );\n    BiTree* p = ( BiTNode* ) malloc( sizeof( BiTNode ) );\n    p->data = exp[c1];\n    p->lchild = BuildTree( exp, s, c1 );\n    p->rchild = BuildTree( exp, c1 + 1, e );\n    return p;\n}\n```","tags":["二叉树"],"categories":["algorithm"]},{"title":"[algorithm]图","url":"%2Fposts%2F3164%2F","content":"## 一.图的算法\n\n### 1. 邻接矩阵和邻接表的表示\n\n#### 1). 邻接矩阵表示的数据结构\n\n```cpp\n#define INFINITY INT_MAX // 无穷大\n#define MAX_VERTEX_NUM 20 // 限制顶点最大数值为20个\n#define MAX_ARC_NUM  MAX_VERTEX_NUM * (MAX_VERTEX_NUM - 1) // 由n个顶点，最多可以确定n(n-2)/2条直线,有向图为2倍\n#define MAX_INFO 20 // 用户输入的弧信息，最多20个字符\n\n/*数组表示法*/\ntypedef int        VRType;\ntypedef char    InfoType;\ntypedef char    VertexType[5];\ntypedef enum    {DG, DN, UDG, UDN} GraphKind; \n\ntypedef struct ArcCell {\n    VRType adj;\n    InfoType *info;\n}ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];\n\ntypedef struct {\n    VertexType    vexs[MAX_VERTEX_NUM];\n    AdjMatrix    arcs;\n    int            vexnum, arcnum;\n}MGraph;\n```\n\n#### 2). 邻接表表示的数据结构\n\n```cpp\n/*邻接表表示法*/\ntypedef struct ArcNode\n{\n    int                adjvex;\n    int                w; // 存储权值，书中的程序没有表示权值的数据成员(书中说用info来存储权值，但是上面的程序又是单独用的adj存权值，为了一致性，info还是用来存储其他信息算了)\n    struct ArcNode    *nextarc;\n    InfoType *info; // 用来存储权值以外的有关弧的信息\n}ArcNode;\n\ntypedef struct VNode\n{\n    VertexType    data;\n    ArcNode        *firstarc;\n}VNode, AdjList[MAX_VERTEX_NUM];\n\ntypedef struct\n{\n    AdjList        vertices;\n    int            vexnum, arcnum;\n    int            kind;\n}ALGraph;\n```\n\n### 2.写出从图的邻接表表示转换成邻接矩阵表示的算法\n\n```cpp\nvoid Convert( ALGraph G, int arcs[][10] )\n{\n    for ( int v = 0; v < G.vexnum; v++ )\n        for ( ArcNode* p = G.vertices[v].firstarc; p; p->nextarc )\n            arcs[v][p->adjvex] = 1;\n}\n```\n\n## 二.图的遍历\n\n>说明: 以下图的算法既可以使用邻接矩阵的方式也可以使用邻接表存储的方式,因此每种算法都可以换成另一种存储形式,只需要把MGraph(邻接矩阵存储)换成ALGraph(邻接表存储)即可\n\n### 1. 寻找邻接点\n\n#### 1). 邻接矩阵下,通用找邻接的函数:\n\n```cpp\n// 第一个邻居\nint FirstNeighbor( MGraph G, int v)\n{ \n    for ( int i = 0; i < G.vexnum; i++ )\n        if ( G.arcs[v][i] == 1 )\n            return i;\n    return -1;\n}\n// 当前的下一个邻居\nint NextNeighbor( MGraph G, int v, int w )\n{\n    for (int i = w+1; i < G.vexnum; i++ )\n        if ( G.arcs[v][i] == 1 )\n            return i;\n    return -1;\n}\n```\n\n#### 2). 邻接表下,通用找邻接的函数:\n\n```cpp\n/*全局变量*/\nbool Visited[MAX_VERTEX_NUM]; // 记录每个顶点是否被访问过\n\n// 找到第一个v相邻的顶点，返回它的下标\nint FirstAdjVex(ALGraph &AL, int v)\n{\n    ArcNode *p = NULL;\n    p = AL.vertices[v].firstarc;\n    if (p == NULL)\n        return -1;\n    else\n        return p->adjvex;\n}\n\n// 找到下一个与v相邻的顶点，返回它的下标\nint NextAdjVex(ALGraph &AL, int v, int w)\n{\n    ArcNode *p = NULL;\n    p = AL.vertices[v].firstarc;\n    while (p->adjvex != w) // 找到下标为w的结点\n        p = p->nextarc;\n    p = p->nextarc; // 指针指向下标为w的结点的后面一个结点\n    if (p == NULL)\n        return -1;\n    else\n        return p->adjvex;\n}\n```\n\n### 2. 遍历方法(BFS+DFS)\n\n#### 1). 广度优先搜索(Breadth-First-Search, BFS)\n\n>法一:采用邻接矩阵\n\n```cpp\nbool visited[MAX_VERTEX_NUM] = { false };\nvoid BFS( MGraph G, int v );\n\nvoid BFSTraverse( MGraph G )\n{\n    int Q[MAXSIZE];\n    int front = -1, rear = -1;\n    for (int v = 0; v < G.vexnum; v++ )\n        if ( !visited[v] )\n            BFS( G, v );\n}\n\nvoid BFS( MGraph G, int v )\n{\n    int Q[MAXSIZE];\n    int front = -1, rear = -1;\n    // BFS顶点三连\n    visit( v );\n    visited[v] = true;\n    Q[++rear] = v;\n    \n    while ( front != rear )\n    {\n        v = Q[++front];\n        for ( int w = FirstNeighbor( G, v ); w >= 0; w = NextNeighbor( G, v, w ) )\n        {\n            if (!visited[w])\n            {\n                // BFS顶点三连\n                visit( w );\n                visited[w] = true;\n                Q[++rear] = w;\n            }\n        }\n    }\n}\n```\n\n>法二:采用邻接表\n\n```cpp\nbool visited[MAX_VERTEX_NUM] = { false };\nvoid BFS( ALGraph G, int v );\n\nvoid BFSTraverse( ALGraph G )\n{\n    int Q[MAXSIZE];\n    int front = -1, rear = -1;\n    for (int v = 0; v < G.vexnum; v++ )\n        if ( !visited[v] )\n            BFS( G, v );\n}\n\nvoid BFS( ALGraph G, int v )\n{\n    int Q[MAXSIZE];\n    int front = -1, rear = -1;\n    // BFS顶点三连\n    visit( v );\n    visited[v] = true;\n    Q[++rear] = v;\n    \n    while ( front != rear )\n    {\n        v = Q[++front];\n        for ( int w = FirstNeighbor( G, v ); w >= 0; w = NextNeighbor( G, v, w ) )\n        {\n            if (!visited[w])\n            {\n                // BFS顶点三连\n                visit( w );\n                visited[w] = true;\n                Q[++rear] = w;\n            }\n        }\n    }\n}\n```\n\n#### 2). 深度优先搜索(Depth-First-Search, DFS)\n\n```cpp\nbool visited[MAX_VERTEX_NUM] = { false };\nvoid DFS( ALGraph &G, int v );\n\nvoid DFSTraverse( ALGraph &G )\n{\n    for ( int v = 0; v < G.vexnum; v++ )\n        if ( !visited[v] )\n            DFS( G, v );\n}\n\nvoid DFS( ALGraph &G, int v )\n{\n    visit( v );\n    visited[v] = true;\n    for ( int w = FirstNeighbor( G, v ); w >= 0; w = NextNeighbor( G, v, w ) )\n        if ( !visited[w] )\n            DFS( G, w );\n}\n```\n\n## 三.综合算法\n\n#### 1. BFS算法求解单源最短路径问题\n\n```cpp\nbool visited[MAXSIZE] = { false };\nunsigned int d[MAXSIZE] = { INFINITE };\nvoid BFS_MIN_Distance( ALGraph G, int u )\n{\n    BiTree Q[MAXSIZE];\n    int front = -1, rear = -1, v, w;\n    // BFS路径三连\n    d[u] = 0;\n    visited[u] = true;\n    Q[++rear] = u;\n    \n    while ( front != rear )\n    {\n        v = Q[++front];\n        for ( w = FirstNeighbor( G, v ); w >= 0; w = NextNeighbor( G, v, w ) )\n        {\n            if (!visited[w])\n            {\n                // BFS路径三连\n                d[w] = d[v] + 1;\n                visited[w] = true;\n                Q[++rear] = w;\n            }\n        }\n    }\n}\n```\n\n#### 2.设计一个算法,判断一个无向图G是否为一棵树\n\n```cpp\nint visited[MAXSIZE] = { 0 };\nvoid DFS( MGraph G, int v, int& Vnum, int& TD );\n\nbool IsTree( MGraph G )\n{\n    int Vnum = 0, TD = 0;    // TD=total degree总度数\n    DFS( G, 0, Vnum, TD );    // 从第一个顶点开始遍历\n    if ( Vnum == G.vexnum&&TD == 2 * ( G.vexnum - 1 ) )\n        return true;\n    return false;\n}\n\nvoid DFS( MGraph G, int v, int& Vnum, int& TD )\n{\n    visited[v] = true; Vnum++;\n    for ( int w = FirstNeighbor( G, v ); w >= 0; w = NextNeighbor( G, v, w ) )\n        if ( !visited[w] )\n            DFS( G, w, Vnum, TD );\n}\n```\n\n#### 3.写出图的深度优先搜索DFS算法的非递归算法\n\n```cpp\nbool visited[MAXSIZE] = { false };\nvoid DFS_NON_RC( MGraph G, int v )\n{\n    int S[MAXSIZE];\n    int top = -1;\n    for ( int i = 0; i < G.vexnum; i++ )\n        visited[i] = false;\n    // 顶点二连\n    visited[v] = true;\n    S[++top] = v;\n\n    while ( top != -1 )\n    {\n        v = S[top--]; \n        visit( v );\n        for ( int w = FirstNeighbor( G, v ); w >= 0; w = NextNeighbor( G, v, w ) )\n            if ( !visited[w] )\n            {\n                // 顶点二连\n                visited[w] = true;\n                S[++top] = w;\n            }\n    }\n}\n```\n\n#### 4.分别采用基于广度优先遍历和深度优先遍历算法判别以邻接表或邻接矩阵存储的有向图中是否存在由顶点v到顶点u的路径(v≠u)\n\n```cpp\n// 采用BFS的方法\nbool visited[MAXSIZE] = { false };\nbool Exist_Path_BFS( MGraph G, int v, int u )\n{\n    int Q[MAXSIZE];\n    int front = -1, rear = -1;\n    visited[v] = true;\n    Q[++rear] = v;\n    while ( front != rear )\n    {\n        v = Q[++front];\n        for ( int w = FirstNeighbor( G, v ); w >= 0; w = NextNeighbor( G, v, w ) )\n        {\n            if (!visited[w])\n            {\n                if ( w == u ) return true;\n                visited[w] = true;\n                Q[++rear] = w;\n            }\n        }\n    }\n    return false;\n}\n```\n\n```cpp\n// 采用DFS的方法\nbool visited[MAXSIZE] = { false };\nbool Exist_Path_DFS( MGraph G, int v, int u )\n{\n    if ( v == u ) return true;\n    visited[v] = true;\n    for ( int w = FirstNeighbor( G, v ); w >= 0; w = NextNeighbor( G, v, w ) )\n    {\n        if ( !visited[w] )\n        {\n            if ( Exist_Path_DFS( G, w, u ) ) return true;\n        }\n    }\n    return false;\n}\n```\n\n#### 5.拓扑排序:判断并输出有向图的拓扑序列\n\n```cpp\nbool Topological( MGraph G, int indegree[] )\n{\n    int S[MAXSIZE];\n    int top = -1, Vnum = 0, v = 0;\n    for ( v = 0; v < G.vexnum; v++ )\n    {\n        if ( indegree[v] == 0 )\n        {\n            visit( v );\n            Vnum++;\n            S[++top] = v;\n        }\n    }\n    while ( top != -1 )\n    {\n        v = S[top--];\n        for ( int w = FirstNeighbor( G, v ); w >= 0; w = NextNeighbor( G, v, w ) )\n        {\n            indegree[w]--;\n            if ( indegree[w] == 0 )\n            {\n                visit( w );\n                Vnum++;\n                S[++top] = w;\n            }\n        }\n    }\n    if ( Vnum == G.vexnum )\n        return true;\n    return false;\n}\n```\n\n#### 6.拓扑排序(DFS):有向无环图的拓扑排序\n\n```cpp\nbool visited[MAXSIZE] = { false };\nint time = 0, finishTime[MAXSIZE] = { 0 };\nvoid DFS( MGraph G, int v );\n\nvoid Topological_DFS( MGraph G )\n{\n    for ( int v = 0; v < G.vexnum; v++ )\n        if ( !visited[v] )\n            DFS( G, v );\n    for ( int t = time - 1; t >= 0; t-- )\n        visit( finishTime[t] );\n}\n\nvoid DFS( MGraph G, int v )\n{\n    visited[v] = true;\n    for ( int w = FirstNeighbor( G, v ); w >= 0; w = NextNeighbor( G, v, w ) )\n        if ( !visited[w] )\n            DFS( G, w );\n    finishTime[time++] = v;\n}\n```","tags":["图"],"categories":["algorithm"]},{"title":"[algorithm]查找","url":"%2Fposts%2F4660%2F","content":"## 一.查找的算法\n\n### 1.折半查找(二分查找)\n\n```cpp\nint binary_search( string s, char ch )\n{\n    int low = 0, high = s.size()-1;\n    while (low <= high)\n    {\n        int mid = ( low + high ) / 2;\n        if ( ch ==  s[mid] )\n            return mid;\n        else if ( ch < s[mid] )\n            high = mid - 1;\n        else\n            low = mid + 1;\n    }\n    return -1;\n}\n```\n时间复杂度: $O(log_2{n})$\n\n### 3.折半查找(二分查找)递归\n```cpp\nint binary_search_rc( string s, char ch, int low, int high )\n{\n    if ( low > high ) \n        return 0;\n    int mid = ( low + high ) / 2;\n    if ( ch == s[mid] ) \n        return mid;\n    else if ( ch < s[mid] )  \n        high = mid - 1;\n    else \n        low = mid + 1;\n    return binary_search_rc( s, ch, low, high );\n}\n```\n时间复杂度: $O(log_2{n})$\n\n---\n## 二.字符串匹配\n\n### 1.简单的模式匹配算法(朴素模式匹配算法)\n\n```cpp\nint naive_search( string S, string T )\n{\n    int i = 0, j = 0, lenS = S.size(), lenT = T.size();\n    while ( i < lenS && j < lenT )\n    {\n        if ( S[i] == T[j] ) { i++; j++; }\n        else { i = i - j + 1; j = 0; }\n    }\n    if ( j >= lenS ) return i - lenT;\n    return 0;\n}\n```\n时间复杂度: $O(m*n)$\n\n### 2.KMP算法\n\n算法需要先求出模式串的next值:\n\n```cpp\nvoid get_next( string T, int next[] )\n{\n    int i = 0, j = -1, lenT = T.size();\n    next[0] = -1;\n    while (i<lenT)\n    {\n        if (j==-1||T[i]==T[j] )\n        {\n            i++; j++; next[i] = j;\n        }\n        else j = next[j];\n    }\n}\n```\n\n也可求出改进后的nextval值:\n\n```cpp\nvoid get_nextval( string T, int nextval[] )\n{\n    int i = 0, j = -1, lenT = T.size();\n    nextval[0] = -1;\n    while ( i < lenT )\n    {\n        if ( j == -1 || T[i] == T[j] )\n        {\n            i++, j++;\n            if ( T[i] == T[j] )\n                nextval[i] = nextval[j];\n            else\n                nextval[i] = j;\n        }\n        else j = nextval[j];\n    }\n}\n```\n\n以下是KMP算法:\n```cpp\nint KMP( string S, string T, int next[], int pos )\n{\n    int i = pos, j = 0, lenS = S.size(), lenT = T.size();\n    while ( i<lenS&&j<lenT )\n    {\n        if ( j == -1 || S[i] == T[j] ) { i++; j++; }\n        else j = next[j];\n    }\n    if ( j >= lenT ) return i - lenT;\n    return 0;\n}\n```\n时间复杂度: $O(m+n)$","tags":["查找"],"categories":["algorithm"]},{"title":"[leetcode]214.最短回文串","url":"%2Fposts%2F44722%2F","content":"{% asset_img Image21.png %}\n### 方法一: KMP算法\n\n时间复杂度: $O(m+n)$\n\n> 解题思路: 实际就是求原串从左到右的最长回文串(必须包含左边所有字符),此处采用**倒置+KMP算法**来缩短匹配时间\n>   1. 将字符串倒置,原串作为模式串pat,倒置串作为主串txt\n>   2. 求出模式串pat的nextval[]值,然后进行字符串匹配,得到的模式串pat最长匹配长度即为模式串pat从第一个字符开始的最大回文串(匹配过程时间复杂度只需要$O(m+n)$)\n\n对于**KMP(Knuth–Morris–Pratt)**算法,可以借鉴关于[查找][1]部分的介绍\n\n```cpp\nint nextval[40005];\nvoid get_nextval(string pat)\n{\n    int i=0,j=-1,len=pat.size();\n    nextval[0]=-1;\n    for (;i<len&&j<len;)\n    {\n        if (j==-1||pat[i]==pat[j])\n        {\n            i++,j++;\n            if (pat[i]==pat[j])\n                nextval[i]=nextval[j];\n            else\n                nextval[i]=j;\n        }\n        else j=nextval[j];\n    }\n}\nstring shortestPalindrome(string txt) {\n    string pat=txt;\n    reverse(txt.begin(),txt.end()); // 字符串倒置\n    get_nextval(pat); // 计算模式串的nextval值\n    int i=0,j=0,lenTxt=txt.size(),lenPat=pat.size();\n    for(;i<lenTxt&&j<lenPat;)   // 进行模式串匹配,找出最大匹配长度\n    {\n        if (j==-1||txt[i]==pat[j])\n            i++,j++;\n        else\n            j = nextval[j];\n    }\n    return txt.substr(0,lenTxt-j)+pat;\n}\n```\n\n","tags":["KMP"],"categories":["OJ"]},{"title":"[leetcode]TOC汇总","url":"%2Fposts%2F6542%2F","content":"| Date | Level | Title                                                    | Methods(t)        | T(n)          |\n| :--- | :---- | :------------------------------------------------------- | :---------------- | :------------ |\n| 4/22 | ★☆☆☆☆ | 5.最长回文子串                                           | 中心扩展法(1)     | $O(n^2)$      |\n|      |       |                                                          | Manacher(1)       | $O(n)$        |\n|      | ★★☆☆☆ | 214.最短回文串                                           | 逆置+KMP(1)       | $O(m+n)$      |\n|      |       | 1.  实现strStr()                                         |                   |               |\n|      |       | (*)\t239. 滑动窗口最大值                                  |                   | $$            |\n| 4/23 |       | 53.最大子序列和                                          |                   | $$            |\n|      |       | 152.乘积最大子序列                                       |                   | $$            |\n|      |       | 分数拆分                                                 |                   | $$            |\n|      |       | 378.有序矩阵中第K小的元素                                |                   | $$            |\n| 4/24 |       | 718. 最长重复子数组                                      |                   | $$            |\n|      |       | 1.   最长上升子序列                                      |                   | $$            |\n|      |       | 2. 无重复字符的最长子串                                  |                   | $$            |\n| 4/25 |       | 340.Longest Substring with At Most K Distinct Characters |                   | $$            |\n|      |       | 992.Subarrays with K Different Integers                  |                   | $$            |\n|      |       | 14.最长公共前缀                                          |                   | $$            |\n|      |       | 7.整数反转                                               |                   | $$            |\n| 4/26 |       | 219. 存在重复元素 II                                     |                   | $$            |\n|      |       | 209. 长度最小的子数组                                    |                   | $$            |\n|      |       | 76. 最小覆盖子串                                         |                   | $$            |\n|      |       | 13. 罗马数字转整数                                       |                   | $$            |\n|      |       | 9. 回文数                                                |                   | $$            |\n|      |       | 12. 整数转罗马数字                                       |                   | $$            |\n|      |       | 15. 三数之和                                             |                   | $$            |\n| 4/27 |       | 43. 字符串相乘                                           |                   | $$            |\n|      |       | 67. 二进制求和                                           |                   | $$            |\n|      |       | 66. 加一                                                 |                   | $$            |\n|      |       | 100. 相同的树                                            |                   | $$            |\n|      |       | 94. 二叉树的中序遍历                                     |                   | $$            |\n| 4/28 |       | 5039. 移动石子直到连续                                   |                   | $$            |\n|      |       | (*)\t5042. 逃离大迷宫                                     |                   | $$            |\n| 4/29 |       | 5000. 从始点到终点的所有路径                             |                   | $$            |\n|      |       | 797. 所有可能的路径                                      |                   | $$            |\n|      |       | (*)\t257. 二叉树的所有路径                                |                   | $$            |\n| 4/30 |       | (*)\t5040. 边框着色                                       |                   | $$            |\n|      |       | (*)\t133. 克隆图                                          |                   | $$            |\n|      |       | (*)\t138. 复制带随机指针的链表                            |                   | $$            |\n| 5/1  |       | 144.二叉树的前序遍历                                     |                   | $$            |\n|      |       | 94.二叉树的中序遍历                                      |                   | $$            |\n|      |       | 145.二叉树的后序遍历                                     |                   | $$            |\n| 5/2  |       | (*)\t968.监控二叉树                                       |                   | $$            |\n|      |       | 590. N叉树的后序遍历                                     |                   | $$            |\n|      |       | 429. N叉树的层序遍历                                     |                   | $$            |\n|      |       | 589. N叉树的前序遍历                                     |                   | $$            |\n|      |       | (*)\t106. 从中序与后序遍历序列构造二叉树                  |                   | $$            |\n|      |       | (*)\t105. 从前序与中序遍历序列构造二叉树                  |                   | $$            |\n|      |       | 559. N叉树的最大深度                                     |                   | $$            |\n|      |       | 104. 二叉树的最大深度                                    |                   | $$            |\n|      |       | 111. 二叉树的最小深度                                    |                   | $$            |\n|      |       | 102. 二叉树的层次遍历                                    |                   | $$            |\n|      |       | 107. 二叉树的层次遍历 II                                 |                   | $$            |\n|      |       | 637. 二叉树的层平均值                                    |                   | $$            |\n|      |       | (*)\t114. 二叉树展开为链表                                |                   | $$            |\n| 5/5  |       | 5051. 有效的回旋镖                                       |                   | $$            |\n|      |       | 5050. 从二叉搜索树到更大和树                             |                   | $$            |\n|      |       | 5.最长回文子串(manacher)                                 |                   | $$            |\n| 5/7  |       | 1039. Minimum Score Triangulation of Polygon             | DP                | $O(n^3)$      |\n| 5/8  |       | 312. Burst Balloons                                      | DP                | $O(n^3)$      |\n|      |       | 375. Guess Number Higher or Lower II                     | DP                | $O(n^3)$      |\n| 5/9  |       | 118.杨辉三角                                             | DP                | $O(n^2)$      |\n|      |       | 119.杨辉三角 II                                          | DP                | $O(n^2)$      |\n|      |       |                                                          | 公式法            | $O(n)$        |\n|      |       | 110. 平衡二叉树                                          | 递归              | $O(n)$        |\n|      |       | 101. 对称二叉树                                          | 递归              | $O(n)$        |\n|      |       | 103. 二叉树的锯齿形层次遍历                              | 层次遍历+奇数逆序 |               |\n| 5/11 |       | 17. 电话号码的字母组合                                   | 递归+回溯(1)      |               |\n| 5/12 |       | 401.二进制手表                                           | 暴力破解          |               |\n|      |       | 22. 括号生成                                             | 递归+回溯(1)      |               |\n|      |       | 5055. 困于环中的机器人                                   |                   | $O(n)$        |\n| 5/13 |       | 39. 组合总和                                             | 递归+回溯(1)      |               |\n| 5/14 |       | 6. Z 字形变换                                            | 找规律            | $O(n)$        |\n|      |       | 8. 字符串转换整数 (atoi)                                 |                   | $O(n)$        |\n|      |       | 190. 颠倒二进制位                                        |                   |               |\n| 5/15 |       | 20. 有效的括号                                           |                   |               |\n|      |       | 121. 买卖股票的最佳时机                                  | DP                | $O(n)$        |\n|      |       | 122. 买卖股票的最佳时机 II                               | DP                | $O(n)$        |\n| 5/16 |       | 123. 买卖股票的最佳时机 III                              | DP                | $O(n)$        |\n|      |       | 188. 买卖股票的最佳时机 IV                               | DP+Greedy         | $O(n*k)$      |\n|      |       | 376. 摆动序列                                            | 找规律            | $O(n)$        |\n| 5/17 |       | 11. Container With Most Water                            | 双指针法          | $O(n)$        |\n|      |       | 19. 删除链表的倒数第N个节点                              | 插入头结点法      | $O(n)$        |\n|      |       | 16. 最接近的三数之和                                     | 双指针法          | $O(n^2)$      |\n|      |       | 18. 四数之和                                             | 双指针法+去重     |               |\n|      |       | 21. 合并两个有序链表                                     | 头结点+余项链接   | $O(max(m,n))$ |\n|      |       | 23. 合并K个排序链表                                      | 头结点+余项链接   |               |\n| 5/18 |       | 24. 两两交换链表中的节点                                 | 递归              |               |\n|      |       | 25. k个一组翻转链表                                      | 递归              |               |\n|      |       | 27. 移除元素                                             | 直接插入法        | $O(n)$        |\n|      |       | 26. 删除排序数组中的重复项                               | 直接插入法        | $O(n)$        |\n|      |       | 80. 删除排序数组中的重复项 II                            | 直接插入法        | $O(n)$        |\n| 5/19 |       | (*) 10. 正则表达式匹配                                   | DP                | $O(m*n)$      |\n|      |       | 35. 搜索插入位置                                         |                   | $O(n)         |\n|      |       | 34. 在排序数组中查找元素的第一个和最后一个位置           | 二分查找          | $O(log_2n)$   |\n|      |       |                                                          |                   |               |\n|      |       |                                                          |                   |               |\n|      |       |                                                          |                   |               |\n|      |       |                                                          |                   |               |\n|      |       |                                                          |                   |               |\n|      |       |                                                          |                   |               |\n|      |       |                                                          |                   |               |\n|      |       |                                                          |                   |               |\n|      |       |                                                          |                   |               |\n|      |       |                                                          |                   |               |\n|      |       |                                                          |                   |               |\n|      |       |                                                          |                   |               |\n|      |       |                                                          |                   |               |\n|      |       |                                                          |                   |               |\n|      |       |                                                          |                   |               |\n|      |       |                                                          |                   |               |\n|      |       |                                                          |                   |               |\n\t\t","tags":["TOC"],"categories":["OJ"]},{"title":"[algorithm]排序","url":"%2Fposts%2F16867%2F","content":"## 一.排序算法\n\n### 1.插入排序\n\n#### 1) 直接插入排序:(插入类)\n```cpp\nvoid InsertSort( ElemType R[], int n )\n{\n    for ( int i = 2; i <= n; i++ )\n    {\n        if ( R[i].key < R[i - 1].key )\n        {\n            R[0] = R[i];\n            for ( int j = i - 1; j > 0 && ( R[0].key < R[j].key ); j-- )\n                R[j + 1] = R[j];\n            R[j + 1] = R[0];\n        }\n    }\n}\n```\n最好情况(顺序有序):\n\n　　1)比较次数: $\\sum_{i=2}^{n} 1=n-1$\n\n　　2)移动次数: 0\n\n最坏情况(逆序有序):\n\n　　1)比较次数: $\\sum_{i=2}^{n} i=\\frac {(n+2)(n-1)}{2}$\n\n　　2)移动次数: $\\sum_{i=2}^{n} (i+1)=\\frac {(n+4)(n-1)}{2}$\n\n#### 2)折半插入排序:(插入类)\n```cpp\nvoid BiInsertSort( ElemType R[], int n )\n{\n    for ( int i = 2; i <= n; i++ )\n    {\n        R[0] = R[i];\n        int low = 1, high = i - 1;\n        while ( low <= high )\n        {\n            int mid = ( low + high ) / 2;\n            if ( R[0].key < R[m].key ) high = mid - 1;\n            else low = mid + 1;\n        }\n        for ( int j = i - 1; j > high; j-- )\n            R[j + 1] = R[j];\n        R[j + 1] = R[0];\n    }\n}\n```\n#### 3)希尔排序(又称缩小增量排序)(插入类)\n```cpp\n// 当dk=1时,即为直接插入排序\nvoid ShellSort( ElemType R[], int n )\n{\n    for ( int dk = n / 2; dk >= 1; dk /= 2 )\n    {\n        for ( int i = dk + 1; i <= n; i++ )\n        {\n            if ( R[i].key < R[i - dk].key )\n            {\n                R[0] = R[i];\n            for ( j = i - dk; j > 0 && ( R[0].key < R[j].key ); j -= dk )\n                    R[j + dk] = R[j];\n                R[j + dk] = R[0];\n            }\n        }\n    }\n}\n```\n### 2.交换排序\n\n#### 1)起泡排序(冒泡排序)(交换类)\n```cpp\nvoid BubbleSort( ElemType R[], int n )\n{\n    for ( int i = 1; i <= n - 1; i++ )\n    {\n        bool flag = false;\n        for ( int j = n; j > i; j-- )\n        {\n            if (R[j].key < R[j-1].key )\n            {\n                swap( R[j], R[j - 1] );\n                flag = true;\n            }\n        }\n        if ( !flag ) return;\n    }\n}\n```\n#### 2)快速排序:(交换类)\n```cpp\nvoid Partition( ElemType R[], int low, int high );\n\n// 快排\nvoid QuickSort( ElemType R[], int low, int high )\n{\n    if ( low >= high ) return;\n    int pivotpos = Partition( R, low, high );\n    QuickSort( R, low, pivotpos - 1 );\n    QuickSort( R, pivotpos + 1, high );\n}\n\n// 划分\nvoid Partition( ElemType R[], int low, int high )\n{\n    ElemType pivot = R[low];\n    while ( low < high )\n    {\n        while ( low < high && R[high].key >= pivot.key ) high--;\n        R[low] = R[high];\n        while ( low < high && R[low].key <= pivot.key ) low++;\n        R[high] = R[low];\n    }\n    R[low] = pivot;\n    return low;\n}\n```\n### 3.选择排序\n\n#### 1)简单选择排序(选择类)\n```cpp\nvoid SelectSort( ElemType R[], int n )\n{\n    for ( int i = 0; i < n - 1; i++ )\n    {\n        int min = i;\n        for ( int j = i + 1; j < n; j++ )\n        {\n            if ( R[j].key < R[min].key ) min = j;\n        }\n        if ( min != i ) swap( R[i], R[min] );\n    }\n}\n```\n#### 2)堆排序(选择类)\n```cpp\nvoid AdjustDown( ElemType R[], int s, int n );\n\nvoid HeapSort( ElemType R[], int n )\n{\n    for ( int i = n / 2; i > 0; i-- )\n        void AdjustDown( R, i, n );\n    for ( int i = n; i > 1; i-- )\n    {\n        swap( R[i], R[1] );\n        AdjustDown( R, 1, i - 1 );\n    }\n}\n\n// 向下调整\nvoid AdjustDown( ElemType R[], int s, int n )\n{\n    R[0] = R[s];\n    for ( int i = 2 * s; i <= n; i *= 2 )\n    {\n        if ( i < n&&R[i].key < R[i + 1].key ) i++;\n        if (R[0].key  >=R[i].key ) break;\n        else\n        {\n            R[s] = R[i]; s = i;\n        }\n    }\n    R[s] = R[0];\n}\n```\n```cpp\n// 向上调整\nvoid AdjustUp( ElemType R[], int s )\n{\n    R[0] = R[s];\n    int p = s / 2;\n    while ( p >&& R[p].key < R[0].key )\n    {\n        R[s] = R[p];\n        s = p;\n        p /= 2;\n    }\n    R[s] = R[0];\n}\n```\n### 4.归并排序(归并类)\n```cpp\nvoid Merge( ElemType R[], int low, int mid, int high );\n\nvoid MergeSort( ElemType R[], int low, int high )\n{\n    if ( low >= high ) return;\n    int mid = ( low + high ) / 2;\n    MergeSort( R, low, mid );\n    MergeSort( R, mid + 1, high );\n    Merge( R, low, mid, high );\n}\n\nElemType B[MAXSIZE];\nvoid Merge( ElemType R[], int low, int mid, int high )\n{\n    int i,j,k;\n    for ( i = low; i <= high; i++ )\n        B[i] = R[i];\n    i = k = low, j = mid + 1;\n    while ( i <= mid && j <= high )\n    {\n        if ( B[i].key <= B[j].key )\n            R[k++] = B[i++];\n        else\n            R[k++] = B[j++];\n    }\n    while ( i <= mid ) R[k++] = B[i++];\n    while ( j <= high ) R[k++] = B[j++];\n}\n```\n## 二.综合题(算法)\n\n1.设顺序表用数组R[]表示,表中存储在数组下标1~m+n的范围内,前m个元素递增有序,后n个元素递增有序,设计一个算法,使得整个顺序表有序\n```cpp\nvoid InsertSort( ElemType R[], int m, int n )\n{\n    for ( int i = m + 1; i <= m + n; i++ )\n    {\n        if ( R[i].key < R[i - 1].key )\n        {\n            R[0] = R[i];\n            for ( int j = i - 1; j > 0 && ( R[0].key < R[j].key ); j-- )\n                R[j + 1] = R[j];\n            R[j + 1] = R[0];\n        }\n    }\n}\n```\n2.计数排序:对表进行排序并将结果放到另一个新的表中,要求表中所有关键码互不相同\n```cpp\nvoid CountSort( ElemType A[], ElemType B[], int n )\n{\n    for ( int i = 0; i < n; i++ )\n    {\n        int cnt = 0;\n        for ( int j = 0; j < n; j++ )\n            if ( A[i].key > A[j].key )cnt++;\n        B[cnt] = A[i];\n    }\n}\n```\n3.双向冒泡排序\n```cpp\n// 思想:第一趟通过交换把最大的放最后,第二趟通过交换把最小的放最前,反复进行\nvoid BubbleSort( ElemType A[], int n )\n{\n    int low = 0, high = n - 1, i;\n    bool flag = true;\n    while ( low < high && flag )\n    {\n        flag = false;\n        for (i = low; i < high; i++ )\n        {\n            if (A[i]>A[i+1] )\n            {\n                swap( A[i], A[i + 1] ); flag = true;\n            }\n        }\n        high--;\n        for ( i = high; i > low; i-- )\n        {\n            if ( A[i] < A[i - 1] )\n            {\n                swap( A[i], A[i - 1] ); flag = true;\n            }\n        }\n        low++;\n    }\n}\n```\n4.单链表的简单选择排序(假设不带表头结点)\n```cpp\nvoid SelectSort( LinkList& L )\n{\n    LinkList h, p, s, pre, r;\n    h = L;\n    while ( h )\n    {\n        p = s = h; pre = r = NULL;\n        // 找最大结点s\n        while ( p )\n        {\n            if (p->data>s->data )\n            {\n                s = p; r = pre;\n            }\n            pre = p;\n            p = p->next;\n        }\n        // 脱链\n        if ( s == h ) h = h->next;\n        else r->next = s->next;\n        // 头插法\n        s->next = L; L = s;\n    }\n}\n```\n5.顺序表中有n个不同整数(下标1~n),设计算法把所有奇数移动到偶数前面(时,空都最少)\n```cpp\nvoid Move( ElemType A[], int n )\n{\n    int low = 1, high = n;\n    while ( low < high )\n    {\n        while ( low < high&&A[low] % 2 ) low++;\n        while ( low < high && A[high] % 2 == 0 ) high--;\n        if ( low < high )\n        {\n            swap( A[low], A[high] );\n            low++; high--;\n        }\n    }\n}\n```\n6.在顺序表中找出第k小的元素(时空最少)\n```cpp\n// 思想:划分\nint Partition( ElemType R[], int low, int high )\n{\n    int pivot = R[low];\n    while ( low < high )\n    {\n        while ( low < high && R[high].key >= pivot.key ) high--;\n        R[low] = R[high];\n        while ( low < high&& R[low].key <= pivot.key ) low++;\n            R[high] = R[low];\n    }\n    R[low] = pivot;\n    return low;\n}\n\nElemType Kth_elem( ElemType R[], int low, int high, int k )\n{\n    int pivotpos = Partition( R, low, high );\n    if ( pivotpos == k ) return R[pivotpos];\n    else if ( pivotpos > k ) return Kth_elem( R, low, pivotpos - 1, k );\n    else return Kth_elem( R, pivotpos + 1, high, k );\n}\n```\n7.n个正整数构成的集合A,将其划分为两个不相交的子集$A1,A2$,元素个数分别是n1和n2.A1和A2中元素之和分别为S1和S2.设计一个时空高效算法,使|n1-n2|最小且|s1-s1|最大.(下标从1开始)\n```cpp\nint Partition( ElemType R[], int low, int high )\n{\n    int pivot = R[low];\n    while ( low < high )\n    {\n        while ( low < high && R[high].key >= pivot.key ) high--;\n        R[low] = R[high];\n        while ( low < high&& R[low].key <= pivot.key ) low++;\n        R[high] = R[low];\n    }\n    R[low] = pivot;\n    return low;\n}\n\nint SetPartition( ElemType R[], int n, int low, int high )\n{\n    int k = n / 2, s1, s2, i;\n    int pivotpos = Partition( R, low, high );\n    if ( pivotpos == k )\n    {\n        s1 = s2 = 0;\n        for ( i = 1; i <= k; i++ ) s1 += R[i];\n        for ( j = k + 1; j <= n; j++ ) s2 += R[j];\n        return s2 - s1;\n    }\n    else if ( pivotpos > k )\n        return SetPartition( R, n, low, pivotpos - 1 );\n    else return SetPartition( R, n, pivotpos + 1, high );\n}\n```","tags":["排序"],"categories":["algorithm"]},{"title":"[leetcode]133.克隆图","url":"%2Fposts%2F12189%2F","content":"{% asset_img 453425-20190430181854853-2091334093.png %}\n### 方法一:dfs(递归)\n\n```cpp\nmap<Node*,Node*> dict;\nNode* clone(Node* node)\n{\n    if (!node) return node;\n    if (dict.count(node)) return dict[node];\n    dict[node]=new Node(node->val,vector<Node*>{});　　// 这里不能写clone(node),会导致死循环,记住,在new的时候千万不要再递归,递归最低层一定有一个明确结果,所以要把截止条件写清楚\n    for(auto it:node->neighbors)\n        dict[node]->neighbors.push_back(clone(it));\n    return dict[node];\n}\nNode* cloneGraph(Node* node) \n{\n    return clone(node);\n}\n```\n### 方法二:dfs(非递归)\n\n```cpp\nmap<Node*,Node*> dict;\nNode* cloneGraph(Node* node) \n{\n    stack<Node*> S;\n    S.push(node);\n    while (!S.empty())\n    {\n        Node *p = S.top();\n        S.pop();\n        if (!dict.count(p))　　// 从栈中出来的都是没有进行访问过的点\n            dict[p]=new Node(p->val,vector<Node*>{});\n        for (auto it:p->neighbors)\n        {\n            if (!dict.count(it))　　// 判断是否已经访问过该点\n            {\n                dict[it]=new Node(it->val,vector<Node*>{});\n                S.push(it);\n            }\n            dict[p]->neighbors.push_back(dict[it]);　　// 将新点的拷贝放入neighbors中\n        }\n    }\n    return dict[node];\n}\n```","tags":["图"],"categories":["OJ"]},{"title":"[leetcode]138.复制带随机指针的链表","url":"%2Fposts%2F48962%2F","content":"{% asset_img 453425-20190430193735900-662137168.png %}\n### 方法一:递归\n```cpp\nunordered_map<Node*,Node*> dict;\nNode* copyRandomList(Node* head) \n{\n    if (!head) return head;\n    if (dict.count(head)) return dict[head];\n    dict[head]=new Node(head->val, nullptr, nullptr);\n    dict[head]->next=copyRandomList(head->next);\n    dict[head]->random=copyRandomList(head->random);\n    return dict[head];\n}\n```\n### 方法二:非递归\n```cpp\nNode* copyRandomList(Node* head) \n{\n    if (!head) return head;\n    unordered_map<Node*,Node*> m;\n    Node *p=head;\n    while(p)    // make a copy of nodes\n    {\n        m[p]=new Node(p->val,nullptr,nullptr);\n        p=p->next;\n    }\n    p=head;\n    while(p)    // link everyone and fill the random field\n    {\n        m[p]->next=m[p->next];\n        m[p]->random=m[p->random];\n        p=p->next;\n    }\n    return m[head];\n}\n```","tags":["链表"],"categories":["OJ"]},{"title":"[leetcode]144.二叉树的前序遍历","url":"%2Fposts%2F11169%2F","content":"{% asset_img 453425-20190501113746021-447522744.png %}\n前往二叉树的:前序,中序,后序 遍历算法\n### 方法一:递归\n```cpp\nvector<int> res;\nvector<int> preorderTraversal(TreeNode* root) \n{\n    if (!root) return res;\n    res.push_back(root->val);\n    if (root->left) preorderTraversal(root->left);\n    if (root->right) preorderTraversal(root->right);\n    return res;\n}\n```\n### 方法二:非递归\n```cpp\nvector<int> preorderTraversal(TreeNode* root) \n{\n    vector<int> res;\n    if (!root) return res;\n    stack<TreeNode*> S;\n    TreeNode* p = root;\n    while(p||!S.empty())\n    {\n        if (p)  // 访问左子树\n        {\n            res.push_back(p->val);\n            S.push(p);\n            p=p->left;\n        }\n        else    // 访问右子树\n        {\n            p=S.top();\n            S.pop();\n            p=p->right;\n        }\n    }\n    return res;\n}\n```\n### 方法三:非递归(该方法可用于后序遍历,需要修改几处代码)\n```cpp\nvector<int> res;\nvector<int> preorderTraversal(TreeNode* root) \n{\n    if (!root) return res;\n    stack<TreeNode*> S;\n    S.push(root);\n    while (!S.empty())\n    {\n        root=S.top();\n        S.pop();\n        if (root->right) S.push(root->right);  // 要实现后序遍历,需要以下两行调换\n        if (root->left) S.push(root->left);\n        res.push_back(root->val);   // res.insert(0,root->val)即为后序遍历\n    }\n    return res;\n}\n```\n结论:\n- 方法三这种形式只适合前序和后序遍历,不适合中序遍历,中序遍历较为麻烦\n- 方法二这种形式只适合前序和中序遍历,不适合后序遍历,后序遍历较为麻烦","tags":["递归"],"categories":["OJ"]},{"title":"[leetcode]94.二叉树的中序遍历","url":"%2Fposts%2F40851%2F","content":"{% asset_img 453425-20190501120139941-1568037684.png %}\n前往二叉树的:[前序](),[中序](),[后序]() 遍历算法\n\n### 方法一:递归\n```cpp\nvector<int> res;\nvector<int> inorderTraversal(TreeNode* root) \n{\n    if (!root) return res;\n    if (root->left) inorderTraversal(root->left);      \n    res.push_back(root->val);\n    if (root->right) inorderTraversal(root->right);\n    return res;\n}\n```\n### 方法二:非递归\n```cpp\nvector<int> inorderTraversal(TreeNode* root) \n{\n    vector<int> res;\n    if (!root) return res;\n    stack<TreeNode*> S;\n    TreeNode* p = root;\n    while(p||!S.empty())\n    {\n        if (p)\n        {\n            S.push(p);\n            p=p->left;\n        }\n        else\n        {\n            p=S.top();\n            S.pop();\n            res.push_back(p->val);\n            p=p->right;\n        }\n    }\n    return res;\n}\n```","tags":["递归"],"categories":["OJ"]},{"title":"[leetcode]145.二叉树的后序遍历","url":"%2Fposts%2F34771%2F","content":"{% asset_img 453425-20190501122117295-85727166.png %}\n前往二叉树的:前序,中序,后序 遍历算法\n### 方法一:递归\n```cpp\nvector<int> res;\nvector<int> postorderTraversal(TreeNode* root) \n{\n    if (!root) return res;\n    if (root->left) postorderTraversal(root->left);\n    if (root->right) postorderTraversal(root->right);\n    res.push_back(root->val);\n    return res;\n}\n```\n### 方法二:非递归\n```cpp\nvector<int> postorderTraversal(TreeNode* root) \n{\n    vector<int> res;\n    if (!root) return res;\n    stack<TreeNode*> S;\n    TreeNode* p=root, *r=nullptr;\n    while (p||!S.empty())\n    {\n        if (p)\n        {\n            S.push(p);\n            p=p->left;\n        }\n        else\n        {\n            p=S.top();\n            if (p->right&&p->right!=r)\n                p=p->right;\n            else\n            {\n                S.pop();\n                res.push_back(p->val);\n                r=p;\n                p=nullptr;\n            }\n        }\n    }\n    return res;\n    }\n```\n### 方法三:非递归\n```cpp\nvector<int> postorderTraversal(TreeNode* root) \n{\n    vector<int> res;\n    if (!root) return res;\n    stack<TreeNode*> S;\n    TreeNode* p=root;\n    S.push(p);\n    while (!S.empty())\n    {\n        p=S.top();\n        S.pop();\n        if (p->left) S.push(p->left);\n        if (p->right) S.push(p->right);\n        res.insert(res.begin(),p->val);\n    }\n    return res;\n}\n```","tags":["递归"],"categories":["OJ"]},{"title":"[leetcode]968.监控二叉树","url":"%2Fposts%2F45343%2F","content":"{% asset_img 453425-20190501230642291-677698823.png %}\n解题思路: 由于叶子节点一定不要安装监视器,这样才能使总监视器数量比较少,因此需要从下往上进行判断当前节点的状态(共:3种状态):\n- 0: 当前节点安装了监视器\n- 1: 当前节点可观,但没有安装监视器\n- 2: 当前节点不可观\n对于空节点,我们认为是可观,但没有安装监视器,因此,叶子节点就为不可观的了,设想一个节点的左右孩子(为空)都可观且没有安装监视器,那该节点必然是不可观即2\n\n有了以上对空节点和叶子节点的处理,我们再来正式分析非终端节点:\n\n- 若一个节点的左孩子或右孩子不可观,那么该节点必然不可观,需要安装监视器,因此返回0状态\n- 若一个节点的左孩子或右孩子都可观且至少有一个安装了监视器,那么该节点必然是可观的,返回1状态\n- 若一个节点的左右孩子都可观且没安装监视器,那么该节点必然是不可观的,返回2状态\n记住,我们以上的分析都是基于从整个二叉树的叶子节点往根部,即从下往上进行,而且要做的就是将不可观的节点变得可观才行(因此要根据左右孩子的节点的状态来判断当前节点状态并做出调整)\n\n这里可能会有疑惑,以上的第一条得出当前节点不可观,然后安装了监视器,而第三条也得出当前节点不可观,但却没有安装监视器,而是直接返回的2状态(当前节点不可观).这是为什么?\n\n因为,对于第一条,因为左右孩子都不可观,为了让左右孩子都可观,则必须给当前节点安装监视器才行,而第三条中,左右孩子都是可观的(没有安装监视器),当前节点的可以直接返回不可观状态,因为后面可以由他的父节点进行摄像头安装,使其变得可观.\n\n### 方法一:递归\n```cpp\n// 0：该节点安装了监视器 1：该节点可观，但没有安装监视器 2：该节点不可观\nint monitor = 0;\nint state(TreeNode* node)\n{\n    if (node == nullptr) return 1;\n    int left  = state(node->left);\n    int right = state(node->right);\n    // 该节点为0的情况\n    if (left == 2 || right == 2)\n    {\n        monitor++;  // 由于左或右节点不可观,则需要给当前节点安装监视器,为0状态\n        return 0;\n    } // 为1的情况\n    else if (left == 0 || right == 0)\n        return 1;   // 当(left!=2&&right!=2)时,才会进行该判断,也就是左右节点一定是可观的,再判断是否有一个安装了监视器,如有安装,则当前节点就不需要安装监视器也可观了,为1状态\n    // 为2的情况\n    else    // 其他:党(left!=2&&right!=2)&&(left!=0&&right!=0),即left==1&&right==1时,左右节点都可观,但没有监视器,当前节点不可观,为2状态\n        return 2;\n}\nint minCameraCover(TreeNode *root)\n{\n    if (root == nullptr) return 0;\n    if (state(root) == 2) monitor++;    // 如果根节点为2的状态,需要加一个监视器\n    return monitor;\n}\n```\n注意:这里的if,else if,else的顺序是不能变的,先判断左右都是不可观的,再就是都可观,左或右至少有一个为监视器,最后才是都可观都无监视器.","tags":["二叉树"],"categories":["OJ"]},{"title":"[leetcode]106.从中序与后序遍历序列构造二叉树","url":"%2Fposts%2F49088%2F","content":"{% asset_img 453425-20190502213938801-1912607084.png %}\n前往 中序,后序遍历构造二叉树, 中序,前序遍历构造二叉树\n```cpp\nTreeNode* build(vector<int>& inorder, int l1, int r1, vector<int>&postorder, int l2, int r2)\n{\n    if (l1>r1) return nullptr;\n    int x = postorder[r2], i = 0;   // 确定当前根节点\n    for (i = l1; i <= r1 && inorder[i] != x; ++i);  // 在中序遍历序列中找到当前根节点位置(该位置可以划分出左右两个分支)\n    int llen = i - l1;  // 左子树结点数量\n    int rlen = r1 - i;  // 右子树结点数量\n    TreeNode* p = new TreeNode(x);  // 建立根节点\n    p->left = build(inorder, l1, l1 + llen - 1, postorder, l2, l2 + llen - 1);  // 递归建立左子树,-1,-1是把当前根节点位置去掉\n    p->right = build(inorder, r1 - rlen + 1, r1, postorder, r2 - rlen, r2 - 1); // 递归建立右子树,+1,-1是把当前根节点位置去掉\n    return p;\n}\nTreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n    if (inorder.empty()||postorder.empty()) return nullptr;\n    return build(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1);\n}```","tags":["递归"],"categories":["OJ"]},{"title":"[leetcode]105.从前序与中序遍历序列构造二叉树","url":"%2Fposts%2F8827%2F","content":"{% asset_img 453425-20190502215802448-663626721.png %}\n前往 中序,后序遍历构造二叉树, 中序,前序遍历构造二叉树\n``` cpp\nTreeNode* build(vector<int>& preorder, int l1, int r1, vector<int>& inorder, int l2, int r2)\n{\n    if (l1>r1) return nullptr;\n    int x=preorder[l1], i=0;    // 确定当前根节点\n    for(i=l2;inorder[i]!=x&&i<r2;++i);  // 在中序遍历序列中找到当前根节点位置(该位置可以划分出左右两个分支)\n    int llen=i-l2;  // 左子树结点数量\n    int rlen=r2-i;  // 右子树结点数量\n    TreeNode *p = new TreeNode(x);  // 建立根节点\n    p->left = build(preorder, l1+1, l1+llen, inorder, l2, l2+llen-1);   // 递归建立左子树,+1,-1是把当前根节点位置去掉\n    p->right= build(preorder, r1-rlen+1, r1, inorder, r2-rlen+1, r2);   // 递归建立右子树,+1,+1是把当前根节点位置去掉\n    return p;\n}\nTreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) \n{\n    return build(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1);\n}\n```","tags":["递归"],"categories":["OJ"]},{"title":"[leetcode]114.二叉树展开为链表","url":"%2Fposts%2F52504%2F","content":"{% asset_img 453425-20190502231706813-609020347.png %}\n思路:递归,将左子树变成单链表形式,再将右子树变成单链表形式,最后将左子树单链表的末端连接到右子树单链表表头,将根节点的左孩子置空\n### 方法一: 递归\n``` cpp\nvoid flatten(TreeNode* root) \n{\n    if (root==nullptr) return;\n    flatten(root->left);    // 将左子树变成单链表形式\n    flatten(root->right);   // 将右子树变成单链表形式\n    if (root->left) // 将左子树单链表的末端连接到右子树单链表表头\n    {\n        TreeNode* p=root->left;\n        while(p->right) p=p->right;\n        p->right=root->right;\n        root->right=root->left;\n        root->left=nullptr;\n    }\n}\n```","tags":["递归"],"categories":["OJ"]},{"title":"[leetcode]239.滑动窗口最大值","url":"%2Fposts%2F45513%2F","content":"{% asset_img 453425-20190503094513334-1691572073.png %}\n思路:滑动窗口的思想,只要是求连续子序列或者子串问题,都可用滑动窗口的思想\n### 方法一: 滑动窗口\n``` cpp\nvector<int> maxSlidingWindow(vector<int>& nums, int k) \n{\n    vector<int> res;\n    if (nums.size()==0) return res;\n    int i=0;\n    deque<int> dq;　　\n    for (i=0;i<nums.size();++i)\n    {\n        while(!dq.empty()&&nums[i]>nums[dq.back()]) //在尾部添加元素，并保证左边元素都比尾部大\n            dq.pop_back();\n        dq.push_back(i);\n        if (i-k==dq.front())    //在头部移除元素\n            dq.pop_front();\n        if (i>=k-1)\n            res.push_back(nums[dq.front()]);    // 存放每次窗口内的最大值\n    }\n    return res;\n}\n```","tags":["滑动窗口"],"categories":["OJ"]},{"title":"[leetcode]76.最小覆盖子串","url":"%2Fposts%2F39410%2F","content":"{% asset_img 453425-20190503105807149-1455260747.png %}\n思路:滑动窗口思想\n### 方法一:滑动窗口\n``` cpp\nstring minWindow(string s, string t) {\n    // 1.tdict记录T中每个字母与字母个数\n    // 2.维护一个滑动窗口字母的计数表sdict,计数当前窗口内T中字母出现的次数\n    // 3.当窗口内T中字母出现的次数大于等于T中每个字母出现的次数一样,这时第一个最短子串出现,再逐步从左边缩短窗口,直到不满足上述条件,然后再从右边扩大窗口,直到满足条件时,再进行最短子串长度对比,一直更新最短长度子串直到结束\n    if (s.size()<t.size()||s.size()==0) return \"\";\n    unordered_map<char,int> tdict,sdict;\n    int l=0,r=0,k=t.size();\n    for(auto it:t)  // 填充T的字母与字母计数表\n    {\n        if (!tdict.count(it)) tdict[it]=1;\n        else tdict[it]++;\n    }\n    string res=\"\";\n    for(r=0;r<s.size();++r)\n    {\n        if (tdict.count(s[r])) // 有字符,则进行记录\n        {\n            if (!sdict.count(s[r]))\n                sdict[s[r]]=0;\n            sdict[s[r]]++;\n            if (sdict[s[r]]<=tdict[s[r]])\n                k--;\n        }\n        while(k==0) // 满足条件,滑动窗口从左边逐步缩短,直到剔除第一个属于T中的字符为止\n        {\n            if (res.empty()||r-l+1<res.size())  // 最短子串更新\n                res=s.substr(l,r-l+1);\n            if(tdict.count(s[l]))\n            {\n                sdict[s[l]]--;\n                if (sdict[s[l]]<tdict[s[l]])\n                    k++;\n            }\n            l++;\n        }\n    }\n    return res;\n}\n```","tags":["滑动窗口"],"categories":["OJ"]},{"title":"[leetcode]3.无重复字符的最长子串","url":"%2Fposts%2F37922%2F","content":"{% asset_img 453425-20190503112154412-1836563639.png %}\n思路:滑动窗口的思想\n### 方法一:滑动窗口\n``` cpp\nint lengthOfLongestSubstring(string s) \n{\n    /*\n        控制一个滑动窗口,窗口内的字符都是不重复的,通过set可以做到判断字符是否重复\n    */\n    unordered_set<char> set;\n    size_t maxL=0;\n    for(int l=0,r=0;r<s.size();++r)\n    {\n        if (!set.count(s[r]))   // 当前判断的元素不存在于滑动窗口[l,r-1]中\n            set.insert(s[r]);   // 将元素放入滑动窗口(即记录不重复字符)\n        else    // 当前判断的元素已经存在于滑动窗口[l,r-1]中\n        {\n            while(set.count(s[r]))  // 从左缩短窗口,直到剔除当前判断的元素为止\n                set.erase(s[l++]);\n            set.insert(s[r]);   // 将当前判断元素放入到滑动窗口中\n        }\n        maxL=max(maxL,set.size());  // 更新无重复字符的最长子串\n    }\n    return maxL;\n}\n```","tags":["滑动窗口"],"categories":["OJ"]},{"title":"[leetcode]1028.从先序遍历还原二叉树","url":"%2Fposts%2F38760%2F","content":"{% asset_img 453425-20190503131537591-466226739.png %}\n思路:用一个栈来管理树的层次关系,索引代表节点的深度\n### 方法一:\n``` cpp\nTreeNode* recoverFromPreorder(string S) \n{\n    /*\n        由题意知,最上层节点深度为0(数字前面0条横线),而第二层节点前有1条横线,表示深度为1\n        树的前序遍历: 根-左-右\n        因此,\n    */\n    if (S.empty()) return nullptr;\n    vector<TreeNode*> stack;  // 结果栈\n    for(int i=0,depth=0,val=0;i<S.size();)\n    {\n        for(depth=0;i<S.size()&&S[i]=='-';++i)  // 计算节点的深度\n            depth++;\n        for(val=0;i<S.size()&&S[i]!='-';++i)    // 计算数值\n            val=val*10+S[i]-'0';\n        while (stack.size()>depth)    // 若当前栈的长度(树的高度)大于节点的深度,则可以把栈中最后几个节点pop掉(这些节点各已经成为完整的子树,可以pop掉了)\n            stack.pop_back();\n        TreeNode* node=new TreeNode(val);   // 新建节点用于存放当前深度的结点\n        if (!stack.empty()) // 节点间关联\n        {\n            if (!stack.back()->left)      stack.back()->left=node;\n            else if(!stack.back()->right) stack.back()->right=node;\n        }\n        stack.push_back(node);\n    }\n    return stack[0];\n}\n```\n","tags":["树"],"categories":["OJ"]},{"title":"[leetcode]5040.边框着色","url":"%2Fposts%2F3454%2F","content":"{% asset_img 453425-20190430173552247-46622747.png %}\n### 方法一：dfs的非递归形式\n``` cpp\nusing ll=long long;\nconst ll MAXN=50LL;\nunordered_set<ll> vis,mark;\nvector<vector<int>> colorBorder(vector<vector<int>>& G, int r0, int c0, int color) {\n    queue<ll> Q;\n    Q.push(r0*MAXN+c0);\n    int c=G[r0][c0];\n    int dx[]={-1,1,0,0},dy[]={0,0,-1,1};\n    while (!Q.empty())\n    {\n        int x=Q.front()/MAXN;\n        int y=Q.front()%MAXN;\n        Q.pop();\n        vis.insert(x*MAXN+y);\n        if (x==0||x==G.size()-1||y==0||y==G[0].size()-1)    // 边界方块可变色\n            mark.insert(x*MAXN+y);\n        else if (G[x-1][y]!=c||G[x+1][y]!=c||G[x][y-1]!=c||G[x][y+1]!=c)    // 四个方向中,任意一个方块颜色不同,则可变色\n            mark.insert(x*MAXN+y);\n        for (int d=0;d<4;d++)   // 放入连通分量的所有方块\n        {\n            int nx=x+dx[d],ny=y+dy[d];\n            if (0<=nx&&nx<G.size()&&0<=ny&&ny<G[0].size()&&!vis.count(nx*MAXN+ny)&&G[nx][ny]==c)\n                Q.push(nx*MAXN+ny);\n        }\n    }\n    for (auto it:mark)\n        G[it/MAXN][it%MAXN]=color;\n    return G;\n}\n```\n思路:用vis记录访问过的方块,mark标记连通分量中需要修改颜色的方块,并非连通分量中所有的方块都要修改颜色,比如:一个方块如果四周(四个方向邻接的)都是相同颜色,那么只需要修改四周方块的颜色,而自己颜色不变(开始的时候没理解题意,以为只要是连通分量内的方块颜色都需要改变)\n\n### 方法二: dfs递归形式,只不过把上面的非递归改为递归了\n``` cpp\nusing ll=long long;\nconst ll MAXN=50LL;\nunordered_set<ll> vis,mark;\nvoid dfs(vector<vector<int>>& G, int x, int y, int c)\n{\n    int dx[]={-1,1,0,0},dy[]={0,0,-1,1};\n    vis.insert(x*MAXN+y);\n    if (x==0||x==G.size()-1||y==0||y==G[0].size()-1)    // 边界方块可变色\n        mark.insert(x*MAXN+y);\n    else if (G[x-1][y]!=c||G[x+1][y]!=c||G[x][y-1]!=c||G[x][y+1]!=c)    // 四个方向中,任意一个方块颜色不同,则可变色\n        mark.insert(x*MAXN+y);\n    for (int d=0;d<4;d++)   // 放入连通分量的所有方块\n    {\n        int nx=x+dx[d],ny=y+dy[d];\n        if (0<=nx&&nx<G.size()&&0<=ny&&ny<G[0].size()&&!vis.count(nx*MAXN+ny)&&G[nx][ny]==c)\n            dfs(G,nx,ny,c);\n    }\n}\nvector<vector<int>> colorBorder(vector<vector<int>>& G, int r0, int c0, int color) {\n    dfs(G,r0,c0,G[r0][c0]);\n    for (auto it:mark)\n        G[it/MAXN][it%MAXN]=color;\n    return G;\n}\n```\n### 方法三:dfs递归,但通过修改G中的数据,来记录是否访问过,和是否需要修改颜色,国外的一个[大佬](https://leetcode.com/problems/coloring-a-border/discuss/282847/C%2B%2B-with-picture-DFS)写的\nFrom an initial point, perform DFS and flip the cell color to negative to track visited cells.\nAfter DFS is complete for the cell, check if this cell is inside. If so, flip its color back to the positive.\nIn the end, cells with the negative color are on the border. Change their color to the target color.\n{% asset_img image_1556425139.png %}\n``` cpp\nvoid dfs(vector<vector<int>>& g, int r, int c, int cl) {\n    if (r < 0 || c < 0 || r >= g.size() || c >= g[r].size() || g[r][c] != cl) return;    // 剪枝(越界,非着色块)\n    g[r][c] = -cl;    // 着色\n    dfs(g, r - 1, c, cl), dfs(g, r + 1, c, cl), dfs(g, r, c - 1, cl), dfs(g, r, c + 1, cl);\n    if (r > 0 && r < g.size() - 1 && c > 0 && c < g[r].size() - 1 && cl == abs(g[r - 1][c]) &&\n        cl == abs(g[r + 1][c]) && cl == abs(g[r][c - 1]) && cl == abs(g[r][c + 1]))    // 将原四周同色的块,颜色还原\n        g[r][c] = cl;\n}\nvector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\n    dfs(grid, r0, c0, grid[r0][c0]);\n    for (auto i = 0; i < grid.size(); ++i)    // 根据dfs标记(负数)过的方块进行着色\n        for (auto j = 0; j < grid[i].size(); ++j) grid[i][j] = grid[i][j] < 0 ? color : grid[i][j];\n    return grid;\n}\n```\n结论: 无论是递归还是非递归,先标记(标记vis),再遍历\n","tags":["图"],"categories":["OJ"]},{"title":"[leetcode]5.最长回文子串","url":"%2Fposts%2F21336%2F","content":"{% asset_img 453425-20190505125039549-1852205917.png %}\n### 方法一:中心扩展算法\n\n解题思路:从左到右每一个字符都作为中心轴,然后逐渐往两边扩展,只要发现有不相等的字符,则确定了以该字符为轴的最长回文串,但需要考虑长度为奇数和偶数的不同情况的处理(长度为偶数时轴心为中间两个数的中心,长度为奇数时轴心为中间那个数)\n\n算法时间复杂度: $O(n^{2})$\n```cpp\nstring longestPalindrome(string s) \n{        \n    int idx = 0, maxL = 0;\n    for (int i = 0; i < s.size(); ++i)　　// i为轴的位置,j为回文串半径\n    {\n        for (int j = 0; i - j >= 0 && i + j < s.size(); ++j)    // 奇数\n        {\n            if (s[i - j] != s[i + j])\n                break;\n            if (2 * j + 1 > maxL)\n            {\n                maxL = 2 * j + 1;\n                idx = i - j;\n            }\n        }\n        for (int j = 0; i - j >= 0 && i + j + 1 < s.size(); ++j)    // 偶数\n        {\n            if (s[i-j]!=s[i+j+1])\n                break;\n            if (2 * j + 2 > maxL)\n            {\n                maxL = 2 * j + 2;\n                idx = i - j;\n            }\n        }\n    }\n    return s.substr(idx, maxL);\n}\n```\n---\n### 方法二: manacher(马拉车法)\n解题思路:详见[P3805【模板】manacher算法][1]\n为了使奇数串和偶数串一致性处理,首先进行字符填充,使其成为奇数串,即在每个字符的前后填充字符,例如:\n原串: ABCCBA\n填充后: ~#A#B#C#C#B#A#\n原始串在数组中的位置:\n\n|   A   | B    |   C   |   C   |   B   |   A   |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n|   0   | 1    |   2   |   3   |   4   |   5   |\n\n填充串在数组中的位置\n\n|   ~   |   #   |   A   |   #   |   B   |   #   |   C   |   #   |   C   |   #   |   B   |   #   |   A   |   #   |\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12   |  13   |\n\n首先说明: \n- 奇数+偶数=奇数, 因此,奇数串填充偶数个#后为奇数串,偶数串填充奇数个#后为奇数串\n- ~字符用来作为边界,用处在于进行两边扩展时做为结束条件\n- 填充串中字符的最大回文半径 - 1 = 原字符串中该字符的回文串长度\n\n关于上述第3条我需要解释一下:\n\n| s_copy |   ~   |   #   |   A   |   #   |   B   |   #   |   C   |   #   |   C   |   #   |   B   |   #   |   A   |   #   |\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| index  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12   |  13   |\n|  pos   |   0   |   0   |   0   |   0   |   1   |   1   |   2   |   2   |   3   |   3   |   4   |   4   |   5   |   5   |\n|   p    |   0   |   1   |   2   |   1   |   2   |   1   |   2   |   7   |   2   |   1   |   2   |   1   |   2   |   1   |\n\n可以看到index=7的位置,#对应的p为7(即最大回文半径),即在C与C之间,表示原字符串中该字符的回文长度为6,那么原字符串ABCCBA的前面3个字符ABC构成的回文串长度为6\n\n>该题思路:\n>1. 字符串填充统一为奇数串\n>2. Manacher法,从左到右遍历每个字符\n>   1. 记录每个字符的最大回文半径\n>   2. 确定已经记录的最大回文串右边界r,和中间轴m\n>   3. 当前字符s[i]是否能关于m找到一个对称点,即要满足:m<=i<=r\n>      1. 能:则得到一个有可能的最大回文半径,并从该半径开始扩展\n>      2. 否:则从新计算最大回文半径\n\n算法时间复杂度为: $O(n)$\n```cpp\nint pos[2005],p[2005];  // pos用于记录填充串与原始字串的位置关系,p用于记录填充串当前字符的最大回文半径\nstring longestPalindrome(string s) \n{        \n    /* 填充字符,统一为奇数串 */\n    string s_new=\"~\";\n    for (int i=0,k=1;i<s.size();++i)\n    {\n        s_new+=\"#\";\n        s_new+=s[i];\n        pos[k++]=i;\n        pos[k++]=i;\n    }\n    s_new+=\"#\";\n    \n    /* manacher */\n    int m=0,r=0,maxL=0,idx=0;\n    for (int i=1;i<s_new.size();++i)\n    {\n        // 获取已知的最大回文半径,p[i]用于记录填充串对应字符的最大回文半径\n        if (i<r)\n            p[i]=min(p[2*m-i],r-i); // 当m<=i<=r时,i关于m中心轴对称的点为2*m-i,而p[2*m-i]是一定已经知道的\n        else\n            p[i]=1; // 如果i超出了已知的最大回文右边界,则比如不能找到关于m对称的点,只能重新计算最大回文半径\n        // 暴力拓展左右两侧,计算当前的最大回文半径\n        while (s_new[i-p[i]]==s_new[i+p[i]])\n            p[i]++;\n        // 新的回文半径比较大,则更新\n        if (r-i<p[i])\n        {\n            m=i;\n            r=i+p[i];\n        }\n        // 更新回文长度(原始字串的回文长度为新字串回文半径-1)\n        if (p[i]-1>=maxL)\n        {\n            maxL=p[i]-1;\n            idx=pos[i]-maxL/2;  // 更新原始回文字串的起始位置\n        }\n    }\n    return s.substr(idx,maxL);\n}\n```\n\n[1]: https://www.luogu.org/problemnew/solution/P3805","tags":["回文串"],"categories":["OJ"]}]