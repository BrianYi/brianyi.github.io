<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[leetcode]1039. Minimum Score Triangulation of Polygon]]></title>
    <url>%2F2019%2F05%2F07%2Fleetcode-1039-Minimum-Score-Triangulation-of-Polygon%2F</url>
    <content type="text"><![CDATA[解题思路: DP动态规划的思想核心公式为: $$dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j]+A[i]\cdot{A[k]}\cdot{A[j]})$$ 首先,dp[i][j]表示顺时针,从i到j的最小12345678910111213141516int dp[100][100];int minScoreTriangulation(vector&lt;int&gt;&amp; A) &#123; int len=A.size(); for (int d=2;d&lt;len;++d) // d作为i与j之间的间距 &#123; for (int i=0; i+d&lt;len; ++i) &#123; int j=i+d; dp[i][j]=INT_MAX; for (int k=i+1;k&lt;j;++k) dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]+A[i]*A[k]*A[j]); &#125; &#125; return dp[0][len-1];&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[algorithm]线性表]]></title>
    <url>%2F2019%2F05%2F07%2Falgorithm-%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[一. 线性表基础算法1.线性表插入操作线性表插入操作(在第$i(1≤i≤L.length+1)$个位置上插入新元素$elem$) 12345678910bool InsertSeq( SeqList&amp; L, int i, ElemType elem )&#123; if ( i &lt; 1 || i&gt;L.length + 1 || L.length &gt;= MAXSIZE ) return false; for ( j = L.length - 1; j &gt;= i - 1; j-- ) L.elem[j + 1] = L.elem[j]; L.elem[j + 1] = elem; L.length++; return true;&#125; 说明: 插入操作: 可选位置为$1≤i≤L.length+1$ 最好情况: 表尾$(i=n+1)$插入, $O(1)$ 最坏情况: 表头$(i=1)$插入, $O(n)$ 平均情况: 设 $P_i=\frac{1}{(n+1)}$ 是在第$i$个位置插入一个结点的概率,则在长度为$n$的线性表中插入一个结点所需的移动结点的平均次数为$\frac {n}{2}$次,即$O(n)$: $$\sum_{i=1}^{n+1}{P_i}⋅(n+1−i)=\frac{1}{n+1}\cdot\sum_{i=1}^{n+1}(n−i+1)=\frac{1}{n+1}\cdot\frac{n(n+1)}{2}=\frac{n}{2}$$ 2.线性表删除操作123456789bool DeleteSeq( SeqList&amp; L, int i, ElemType&amp; elem )&#123; for ( i&lt;1 || i&gt;L.length ) return false; elem = L.elem[i - 1]; for ( j = i; j &lt; L.length; j++ ) L.elem[j - 1] = L.elem[j]; L.length--; return true;&#125; 说明: 最好情况: 删除表位$(i=n)$,$O(1)$ 最坏情况: 删除表头$(i=1)$,$O(n)$ 平均情况: 设$P_i=\frac{1}{n}$是删除第$i$个位置上结点的概率,则在长度为$n$的线性表中删除一个结点所需移动结点的平均次数为$\frac{n−1}{2}$次,即$O(n)$: $$\sum_{i=1}^{n}{Pi}\cdot{(n−i)}=\frac{1}{n}\sum_{i=1}^{n}n(n−i)=\frac{1}{n}\cdot\frac{n(n−1)}{2}=\frac{n−1}{2}$$ 3.线性表查找操作1234567int LocateSeq( SeqList&amp; L, ElemType elem )&#123; for ( i = 0; i &lt; L.length; i++ ) if ( L.elem[i].key == elem.key ) return i + 1; return 0;&#125; 说明: 最好情况: 查找到表头,$O(1)$ 最坏情况: 查找到表尾,$O(n)$ 平均情况: 设$P_i=\frac{1}{n}$是查找元素在第$i(1≤i≤L.length)$个位置上的概率,则在长度为$n$的线性表中查找值为$elem$的元素所需比较的平均次数为$\frac{n+1}{2}$次,$O(n)$: $$\sum_{i=1}^{n}P_i\cdot{i}=\frac{1}{n}\cdot\sum_{i=1}^{n}i=\frac{1}{n}\cdot\frac{n(n+1)}{2}=\frac{n+1}{2}$$ 二.线性表综合应用1.删除线性表中所有值为$x$的数据元素123456789bool DeleteX( SeqList&amp; L, ElemType x )&#123; int k = 1; for ( i = 1; i &lt;= L.length; i++ ) if ( L.elem[i].key != x.key ) L.elem[k++] = L.elem[i]; L.length = k; return true;&#125; 2.从有序顺序表中删除值在$[s,t]$的所有元素123456789bool DeleteS2TOrderedSeq( SeqList&amp; L, int s, int t )&#123; for ( i = 1; i &lt;= L.length&amp;&amp;L.elem[i].key &lt; s; i++ ); // 找≥s的第一个元素 for ( j = i; j &lt;= L.length&amp;&amp;L.elem[j].key &lt;= t; j++ ); // 找&gt;t的第一个元素 while ( j &lt;= L.length ) L.elem[i++] = L.elem[j++]; L.length = i; return true;&#125; 3.从顺序表中删除值在$[s,t]$的所有元素123456789bool DeleteS2TSeq( SeqList&amp; L, int s, int t )&#123; int k = 1; for ( i = 1; i &lt;= L.length; i++ ) if ( L.elem[i].key&lt;s || L.elem[i].key&gt;t ) L.elem[k++] = L.elem[i]; L.length = k; return true;&#125; 4.从有序顺序表中删除所有值重复的元素123456789bool DeleteSameOrderedSeq( SeqList&amp; L )&#123; int k = 1; for ( i = 2; i &lt;= L.length; i++ ) if ( L.elem[i].key != L.elem[k].key ) L.elem[++k] = L.elem[i]; L.length = k; return true;&#125; 5.将两个有序顺序表合并为一个新的有序顺序表123456789101112131415bool Merge( SeqList A, SeqList B, SeqList&amp; C )&#123; int i = 1, j = 1, k = 1; while ( i&lt;=A.length&amp;&amp;j&lt;=B.length ) &#123; if ( A.elem[i].key &lt;= B.elem[j].key ) C.elem[k++] = A.elem[i++]; else C.elem[k++] = B.elem[j++]; &#125; while ( i &lt;= A.length ) C.elem[k++] = A.elem[i++]; while ( j &lt;= B.length ) C.elem[k++] = B.elem[j++]; C.length = k - 1; return true;&#125; 6.原数组$A[m+n]={a_1,a_2,…,a_m,b_1,b_2,…,b_n}$,现要求转变为$A[m+n]={b_1,b_2,…,b_n,a_1,a_2,…,a_m}$12345678910111213// 元素倒置void Reverse( ElemType A[], int s, int e )&#123; for ( i = s; i &lt; ( s + e ) / 2; i++ ) swap( A[i], A[s + e - i - 1] );&#125;void ExChange( ElemType A[], int m, int n )&#123; Reverse( A, 0, m ); Reverse( A, m, m + n ); Reverse( A, 0, m + n );&#125; 7.线性表$(a_1,a_2,…,a_n)$递增有序,设计算法花最少时间找到数值为$x$的元素: 1)找到,则与其后继元素位置互换2)未找到,将其插入表中并使表中元素仍然递增有序 1234567891011121314151617181920// 使用折半查找的方法void SearchExchangeInsert( ElemType A[], int n, ElemType x )&#123; int low = 1, high = n; while ( low &lt;= high ) &#123; mid = ( low + high ) / 2; if ( x.key == A[mid].key ) &#123; if ( mid != n ) swap( A[mid], A[mid + 1] ); return; &#125; else if ( x.key &lt; A[mid].key ) high = mid - 1; else low = mid + 1; &#125; for ( j = n; j &gt;= high + 1; j-- ) A[j + 1] = A[j]; A[j + 1] = x;&#125; 8.设计算法将一维数组$R$中的序列循环左移$p(0&lt;p&lt;n)$个位置(算法思想和6.相同)12345678910111213// 元素倒置void Reverse( ElemType A[], int s, int e )&#123; for ( i = s; i &lt; ( s + e ) / 2; i++ ) swap( A[i], A[s + e - i - 1] );&#125;void ShiftLeft( ElemType R[], int n, int p )&#123; Reverse( R, 0, p ); Reverse( R, p, n ); Reverse( R, 0, n );&#125; 9.长度为$L(L≥1)$的升序序列$S$,处在$⌈L2⌉$个位置的数成为$S$的中位数,设计一个在时空都尽量高效的算法找出两个等长序列$A$和$B$的中位数12345678910111213141516171819202122232425262728int FindMidFromABOrderedSeq( int A[], int B[], int n )&#123; int s1, s2, e1, e2, m1, m2; s1 = s2 = 0; e1 = e2 = n - 1; while ( s1 != e1 || s2 != e2 ) &#123; m1 = ( s1 + e1 ) / 2; m2 = ( s2 + e2 ) / 2; if ( A[m1] == B[m2] ) return A[m1]; else if ( A[m1] &lt; B[m2] ) &#123; if ( !( ( s1 + e1 ) % 2 ) ) s1 = m1, e2 = m2; else s1 = m1 + 1, e2 = m2; &#125; else &#123; if ( !( ( s2 + e2 ) % 2 ) ) s2 = m2, e1 = m1; else s2 = m2 + 1, e1 = m1; &#125; &#125; return A[s1] &lt; B[s2] ? A[s1] : B[s2];&#125; 三.线性表的链式表示1.采用头插法建立单链表123456789101112131415LinkList CreateList( LinkList&amp; L )&#123; L = ( LinkList ) malloc( sizeof( LNode ) ); L-&gt;next = NULL; scanf( "%d", &amp;x ); while ( x != 9999 ) &#123; s = ( LNode* ) malloc( sizeof( LNode ) ); s-&gt;data = x; s-&gt;next = L-&gt;next; L-&gt;next = s; scanf( "%d", &amp;x ); &#125; return L;&#125; 2.采用尾插法建立单链表1234567891011121314151617LinkList CreateList( LinkList&amp; L )&#123; L = ( LinkList ) malloc( sizeof( LNode ) ); L-&gt;next = NULL; r = L; scanf( "%d", &amp;x ); while ( x != 9999 ) &#123; s = ( LNode* ) malloc( sizeof( LNode ) ); s-&gt;data = x; r-&gt;next=s; r = s; scanf( "%d", &amp;x ); &#125; r-&gt;next = NULL; return L;&#125; 四.线性表相关综合算法1.递归删除不带头结点的单列表$L$中所有值为$x$的结点12345678910111213void DeleteX( LinkList&amp; L, ElemType x )&#123; if ( !L ) return; if ( L-&gt;data == x ) &#123; q = L; L = L-&gt;next; free( q ); DeleteX( L, x ); &#125; else DeleteX( L-&gt;next, x );&#125; 2.删除带头结点的单链表$L$中所有值为$x$的结点12345678910111213141516171819void DeleteX( LinkList&amp; L, ElemType x )&#123; pre = L; p = L-&gt;next; while ( p ) &#123; if ( p-&gt;data == x ) &#123; q = p; pre-&gt;next = p-&gt;next; p = p-&gt;next; free( q ); &#125; else &#123; pre = p; p = p-&gt;next; &#125; &#125;&#125; 3.反向输出带头结点的单链表$L$的每个结点的值123456void PrintX( LinkList L )&#123; if ( !L )return; PrintX( L-&gt;next ); visit( L );&#125; 4.删除带头结点单链表$L$中最小值结点123456789101112131415161718LinkList DeleteMin( LinkList&amp; L )&#123; LinkList p, s, pre, q; p = s = L-&gt;next; pre = q = L; while ( p ) &#123; if(p-&gt;data&lt;s-&gt;data ) &#123; s = p; q = pre; &#125; pre = p; p = p-&gt;next; &#125; q-&gt;next = s-&gt;next; free( s ); return L;&#125; 5.将带头结点的单链表就地逆置,”就地”指辅助空间复杂度为$O(1)$1234567891011121314LinkList Reverse( LinkList L )&#123; LinkList p, q; p = L-&gt;next; L-&gt;next = NULL; while ( p ) &#123; q = p-&gt;next; p-&gt;next = L-&gt;next; L-&gt;next = p; p = q; &#125; return L;&#125; 6.将带头结点的单链表$L$排序,使其递增有序12345678910111213141516void InsertSort( LinkList&amp; L )&#123; LinkList p, pre, r; p = L-&gt;next; r = p-&gt;next; p-&gt;next = NULL; p = r; while ( p ) &#123; r = p-&gt;next; pre = L; while ( pre-&gt;next&amp;&amp;pre-&gt;next-&gt;data &lt; p-&gt;data ) pre = pre-&gt;next; p-&gt;next = pre-&gt;next; pre-&gt;next = p; p = r; &#125;&#125; 7.在带头结点的单链表中,删除值介于$(s,t)$之间的元素12345678910111213141516171819void DeleteS2T( LinkList&amp; L, int s, int t )&#123; LinkList pre, p; pre = L; p = pre-&gt;next; while ( p ) &#123; if ( p-&gt;data &gt; s &amp;&amp; p-&gt;data &lt; t ) &#123; pre-&gt;next = p-&gt;next; free( p ); p = pre-&gt;next; &#125; else &#123; pre = p; p = p-&gt;next; &#125; &#125;&#125; 8.找出两个单链表的公共结点1234567891011121314151617181920212223242526LinkList SearchCommon( LinkList L1, LinkList L2 )&#123; LinkList pA, pB; int lenA, lenB, dist; pA = L1-&gt;next, pB = L2-&gt;next; lenA = lenB = 0; while ( pA ) &#123; pA = pA-&gt;next; lenA++; &#125; while ( pB ) &#123; pB = pB-&gt;next; lenB++; &#125; pA = L1-&gt;next, pB = L2-&gt;next; if ( lenA &gt; lenB ) &#123; dist = lenA - lenB; while ( dist-- ) pA = pA-&gt;next; &#125; else &#123; dist = lenB - lenA; while ( dist-- ) pB = pB-&gt;next; &#125; while ( pA ) &#123; if ( pA == pB ) return pA; pA = pA-&gt;next, pB = pB-&gt;next; &#125; return NULL;&#125; 9.带表头结点的单链表,按递增次序输出单链表中各结点的数据元素,并释放空间123456789101112131415161718192021void AscDelete( LinkList&amp; L )&#123; LinkList p, s, pre, r; while ( L-&gt;next ) &#123; s = p = L-&gt;next; r = pre = L; while ( p ) &#123; if ( p-&gt;data &lt; s-&gt;data ) &#123; s = p; r = pre; &#125; pre = p; p = p-&gt;next; &#125; r-&gt;next = s-&gt;next; visit( s ); free( s ); &#125; free( L );&#125; 10.将带头结点的单链表$A$分解成两个带头结点的单链表$A$和$B$,$A$中含有奇数序号元素,$B$中含有偶数序号元素且相对位置不变1234567891011121314151617181920212223242526// 法一LinkList Split( LinkList&amp; A )&#123; LinkList p, B, rA, rB; int i = 0; p = A-&gt;next; B = ( LinkList ) malloc( sizeof( LNode ) ); rA = A; A-&gt;next = NULL; rB = B; B-&gt;next = NULL; while ( p ) &#123; i++; if (i%2) &#123; rA-&gt;next = p; rA = p; &#125; else &#123; rB-&gt;next = p; rB = p; &#125; p = p-&gt;next; &#125; rA-&gt;next = NULL; rB-&gt;next = NULL; return B;&#125; 1234567891011121314151617181920212223242526// 法二LinkList Split( LinkList&amp; A )&#123; LinkList p, B, rB, pre; int i = 0; B = ( LinkList ) malloc( sizeof( LNode ) ); rB = B; pre = A; p = pre-&gt;next; while ( p ) &#123; i++; if ( i % 2 == 0 ) &#123; pre-&gt;next = p-&gt;next; rB-&gt;next = p; rB = p; p = pre-&gt;next; &#125; else &#123; pre = p; p = p-&gt;next; &#125; &#125; return B;&#125; 11.$C={a_1,b_1,a_2,b_2,…,a_n,b_n}$为线性表,带有头结点,设计一个就地算法将其拆分为两个线性表,使$A={a_1,a_2,…,a_n}$,$B={b_n,…,b_2,b_1}$123456789101112131415161718192021222324LinkList Split( LinkList&amp; A )&#123; LinkList B, pre, p; int i = 0; B = ( LinkList ) malloc( sizeof( LNode ) ); pre = A; p = pre-&gt;next; while ( p ) &#123; i++; if ( i % 2 == 0 ) &#123; pre-&gt;next = p-&gt;next; p-&gt;next = B-&gt;next; B-&gt;next = p; p = pre-&gt;next; &#125; else &#123; pre = p; p = p-&gt;next; &#125; &#125; return B;&#125; 12.在递增有序的带头结点的单链表中,数值相同的只保留一个,使表中不再有重复的元素12345678910111213141516void DeleteSame( LinkList&amp; L )&#123; LinkList p, q; p = L-&gt;next; while ( p ) &#123; q = p-&gt;next; if ( q&amp;&amp;q-&gt;data == p-&gt;data ) &#123; p-&gt;next = q-&gt;next; free( q ); &#125; else p = p-&gt;next; &#125;&#125; 13.将两个按元素值递增的单链表合并为一个按元素值递减的单链表123456789101112131415161718192021222324252627282930313233void MergeList( LinkList&amp; LA, LinkList&amp; LB )&#123; LinkList pA, pB, q; pA = LA-&gt;next; pB = LB-&gt;next; LA-&gt;next = NULL; while ( pA&amp;&amp;pB ) &#123; if ( pA-&gt;data &lt;= pB-&gt;data ) &#123; q = pA-&gt;next; pA-&gt;next = LA-&gt;next; LA-&gt;next = pA; pA = q; &#125; else &#123; q = pB-&gt;next; pB-&gt;next = LA-&gt;next; LA-&gt;next = pB; pB = q; &#125; &#125; if ( pA ) pB = pA; while(pB ) &#123; q = pB-&gt;next; pB-&gt;next = LA-&gt;next; LA-&gt;next = pB; pB = q; &#125; free( LB );&#125; 14.$A,B$为两个元素递增有序的单链表(带头结点),设计算法从$A,B$中公共元素产生单链表$C$,要求123456789101112131415161718192021222324252627282930313233void MergeList( LinkList&amp; LA, LinkList&amp; LB )&#123; LinkList pA, pB, q; pA = LA-&gt;next; pB = LB-&gt;next; LA-&gt;next = NULL; while ( pA&amp;&amp;pB ) &#123; if ( pA-&gt;data &lt;= pB-&gt;data ) &#123; q = pA-&gt;next; pA-&gt;next = LA-&gt;next; LA-&gt;next = pA; pA = q; &#125; else &#123; q = pB-&gt;next; pB-&gt;next = LA-&gt;next; LA-&gt;next = pB; pB = q; &#125; &#125; if ( pA ) pB = pA; while ( pB ) &#123; q = pB-&gt;next; pB-&gt;next = LA-&gt;next; LA-&gt;next = pB; pB = q; &#125; free( LB );&#125; 15.求两个元素递增排列的链表(带头结点)$A$和$B$的交集并存放于$A$链表中,并释放其他结点1234567891011121314151617181920212223242526272829303132333435363738394041424344void Intersect( LinkList&amp; LA, LinkList&amp; LB )&#123; LinkList pA, pB, r, q; pA = LA-&gt;next; pB = LB-&gt;next; r = LA; LA-&gt;next = NULL; while ( pA&amp;&amp;pB ) &#123; if ( pA-&gt;data == pB-&gt;data ) &#123; r-&gt;next = pA; r = pA; pA = pA-&gt;next; q = pB; pB = pB-&gt;next; free( q ); &#125; else if ( pA-&gt;data &lt; pB-&gt;data ) &#123; q = pA; pA = pA-&gt;next; free( q ); &#125; else &#123; q = pB; pB = pB-&gt;next; free( q ); &#125; &#125; r-&gt;next = NULL; while ( pA ) &#123; q = pA; pA = pA-&gt;next; free( q ); &#125; while ( pB ) &#123; q = pB; pB = pB-&gt;next; free( q ); &#125; free( LB );&#125; 16.判断单链表序列$B$是否是$A$的连续子序列(不带头结点)12345678910111213141516171819202122bool IsSubsequence( LinkList A, LinkList B )&#123; LinkList pA, pB, h; pA = A; pB = B; h = pA; while ( pA&amp;&amp;pB ) &#123; if ( pA-&gt;data == pB-&gt;data ) &#123; pA = pA-&gt;next; pB = pB-&gt;next; &#125; else &#123; h = h-&gt;next; pA = h; pB = B; &#125; &#125; if ( pB ) return false; return true;&#125; 17.判断带头结点的循环双链表是否对称12345678910111213bool IsSymmetry( DLinkList L )&#123; DLinkList p, q; p = L-&gt;next; q = L-&gt;prior; while ( p != q &amp;&amp; q-&gt;next != p ) &#123; if ( p-&gt;data != q-&gt;data ) return false; p = p-&gt;next; q = q-&gt;next; &#125; return true;&#125; 18.将循环单链表$h2$链接到$h1$之后1234567891011LinkList Link( LinkList&amp; h1, LinkList&amp; h2 )&#123; LinkList p; p = h1; while ( p-&gt;next != h1 )p = p-&gt;next; p-&gt;next = h2; p = h2; while ( p-&gt;next != h2 )p = p-&gt;next; p-&gt;next = h1; return h1;&#125; 19.带头结点的循环链表,按递增次序输出循环链表中各结点的数据元素,并释放空间123456789101112131415161718192021void AscDelete( LinkList&amp; L )&#123; LinkList p, s, r, pre; while ( L-&gt;next != L ) &#123; s = p = L-&gt;next; r = pre = L; while ( p != L ) &#123; if ( p-&gt;data &lt; s-&gt;data ) &#123; s = p; r = pre; &#125; pre = p; p = p-&gt;next; &#125; visit( s ); r-&gt;next = s-&gt;next; free( s ); &#125; free( L );&#125; 20.查找单链表(带头结点)中倒数第$k$个位置的结点,成功:则输出并返回$true$,否则只返回$false$12345678910111213141516bool SearchBackwardK( LinkList L, int k )&#123; LinkList p, q; int count; p = q = L-&gt;next; count = 0; while (p) &#123; if ( count &lt; k ) count++; else q = q-&gt;next; p = p-&gt;next; &#125; if ( count &lt; k ) return false; visit( q ); return true;&#125; 21.链表中$data$绝对值相等的点,只保留第一次出现的结点$(|data|≤n)$12345678910111213141516171819202122void DeleteSameAbs( LinkList L, int n )&#123; LinkList pre, p; int *B, pos; B = ( int * ) malloc( sizeof( int )*( n + 1 ) ); for ( int i = 0; i &lt; n + 1; i++ ) B[i] = 0; pre = L; p = L-&gt;next; while ( p ) &#123; pos = p-&gt;data &gt; 0 ? p-&gt;data : -p-&gt;data; if ( B[pos] == 0) &#123; B[pos] = 1; pre = p; p = p-&gt;next; &#125; else &#123; pre-&gt;next = p-&gt;next; free( p ); p = pre-&gt;next; &#125; &#125; free( B );&#125; 22.带头结点的循环双链表递增排序1234567891011121314151617181920212223void AscSort( DLinkList L )&#123; DLinkList p, q, r; if ( !L ) return; p = L-&gt;next; q = p-&gt;next; r = q-&gt;next; while ( q!=L ) &#123; while ( p != L &amp;&amp; p-&gt;data &gt; q-&gt;data ) p = p-&gt;prior; // 脱链结点p q-&gt;prior-&gt;next = r; r-&gt;prior = q-&gt;prior; // 插入节点p q-&gt;next = p-&gt;next; q-&gt;prior = p; p-&gt;next-&gt;prior = q; p-&gt;next = q; // 归位(相对位置) q = r; p = q-&gt;prior; r = r-&gt;next; &#125;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>顺序表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[algorithm]栈和队列]]></title>
    <url>%2F2019%2F05%2F07%2Falgorithm-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[一.栈和队列综合(算法)1.判断单链表(带头结点)的结点值(字符型)是否中心对称12345678910111213141516171819202122232425bool IsSymmetry( LinkList&amp; L )&#123; char S[MAXSIZE]; int top = -1, len = 0, i; LinkList p; p = L-&gt;next; while ( p ) &#123; p = p-&gt;next; len++; &#125; p = L-&gt;next; for (i=0;i&lt;len/2;i++) &#123; S[++top] = p-&gt;data; p = p-&gt;next; &#125; i--; if ( len % 2 ) p = p-&gt;next; while ( top != -1 ) &#123; if ( p-&gt;data != S[top] ) return false; top--; p = p-&gt;next; &#125; return true;&#125; 2.共享栈由两个顺序栈S1,S2构成,总大小为100,请设计S1,S2入栈,出栈的算法12345678910111213141516171819202122#define MAXSIZE 100ElemType S[MAXSIZE];int top[2] = &#123; -1,MAXSIZE &#125;;bool Push( int i, ElemType x )&#123; if ( i &lt; 0 || i&gt;1 || top[1] - top[0] == 1 ) return false; if ( i == 0 ) S[++top[0]] = x; else S[--top[1]] = x; return true;&#125;bool Pop( int i, ElemType x )&#123; if ( i &lt; 0 || i&gt;1 || ( i == 0 &amp;&amp; top[0] == -1 ) || ( i == 1 &amp;&amp; top[1] == MAXSIZE ) ) return false; if ( i == 0 ) x = S[top[0]--]; else x = S[top[1]++]; return true;&#125; 3.如果希望循环队列中的元素都能得到利用,则需设置一个标志域tag,并以tag的值为0或1来区分队头指针front和队尾rear相同时的队列状态是”空”还是”满”,编写与此结构相应的入队和出队算法12345678910ElemType Q[MAXSIZE];int front = -1, rear = -1;// 队空条件: front==rear&amp;&amp;tag==0// 队满条件: front==rear&amp;&amp;tag==1// 进队操作: rear=(rear+1)%MAXSIZE;// Q[rear]=x;// tag=1;// 出队操作: front=(front+1)%MAXSIZE;// x=Q[front];// tag=0; 1)”tag”法循环队列入队算法123456789bool EnQueue( ElemType x )&#123; if ( front == rear &amp;&amp; tag == 1 ) return false; rear = ( rear + 1 ) % MAXSIZE; Q[rear] = x; tag = 1; return true;&#125; 2)”tag”法循环队列出队算法123456789bool DeQueue( ElemType&amp; x )&#123; if ( front == rear &amp;&amp; tag == 0 ) return false; front = ( front + 1 ) % MAXSIZE; x = Q[front]; tag = 0; return true;&#125; 4.Q是一个队列,S是一个空栈,实现将队列中的元素逆置的算法12345678910111213141516ElemType S[MAXSIZE], Q[MAXSIZE];int top = -1, front = -1, rear = -1;void Inverse(ElemType S[], ElemType Q[])&#123; ElemType x; while ( front != rear ) &#123; x = Q[++front]; S[++top] = x; &#125; while ( top != -1 ) &#123; x = S[top--]; Q[++rear] = x; &#125;&#125; 5.利用两个栈S1,S2模拟一个队列 已知栈的4个运算如下: void Push(Stack&amp; S, ElemType x); void Pop(Stack&amp; S, ElemType&amp; x) bool IsEmpty(Stack&amp; S); bool IsOverflow( Stack&amp; S ); 1234567891011121314151617181920212223242526272829303132333435363738394041bool EnQueue( Stack&amp; S1, Stack&amp; S2, ElemType x )&#123; if ( !IsOverflow( S1 ) ) &#123; Push( S1, x ); return true; &#125; if ( !IsEmpty( S2 ) ) return false; while (!IsEmpty(S1)) &#123; Pop( S1, t ); Push( S2, t ); &#125; Push( S1, x ); return true;&#125;bool DeQueue( Stack&amp; S1, Stack&amp; S2, ElemType&amp; x )&#123; if (!IsEmpty(S2)) &#123; Pop( S2, x ); return true; &#125; if ( IsEmpty( S1 ) ) return false; while (!IsEmpty(S1)) &#123; Pop( S1, t ); Push( S2, t ); &#125; Pop( S2, x ); return true;&#125;bool IsEmpty( Stack&amp; S1, Stack&amp; S2 )&#123; if ( IsEmpty( S1 ) &amp;&amp; IsEmpty( S2 ) ) return true; return false;&#125; 6.括号匹配问题:判别表达式中括号是否匹配(只含有(),[],{})1234567891011121314151617181920212223242526272829303132bool IsBracketMatch( char*str )&#123; char S[MAXSIZE]; int top = -1; for ( int i = 0; str[i]; i++ ) &#123; char c = str[i]; switch ( c ) &#123; case '(': case '[': case '&#123;': S[++top] = c; break; case ')': c = S[top--]; if ( c != '(' )return false; break; case ']': c = S[top--]; if ( c != '[' )return false; break; case '&#125;': c = S[top--]; if ( c != '&#123;' )return false; break; default: break; &#125; &#125; return top == -1;&#125; 7.利用栈实现以下递归函数的非递归计算:$$Pn(x)=\begin{cases} 1, &amp; n=0 \ 2x, &amp; n=1 \ 2x\cdot{P_{n-1}}(x)-2(n-1)\cdot{P_{n-2}}(x) &amp; n&gt;1\end{cases}$$ 12345678910111213141516171819double P( int n, double x )&#123; struct Stack &#123; int n; // 层 double val; // 数值结果 &#125;S[MAXSIZE]; int top = -1, fv1 = 1, fv2 = 2 * x; for ( int i = n; i &gt; 1; i-- ) S[++top].n = i; while ( top != -1 ) &#123; S[top].val = 2 * x*fv2 - 2 * ( S[top].n - 1 )*fv1; fv1 = fv2; fv2 = S[top--].val; &#125; if ( n == 0 ) return fv1; return fv2;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[algorithm]树与二叉树]]></title>
    <url>%2F2019%2F05%2F07%2Falgorithm-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[一.树与二叉树相关算法1.二叉树按顺序结构存储,求编号为i和j的两个结点的最近公共祖先结点的值123456789ElemType CommonAncestor( SeqTree T, int i, int j )&#123; while ( i != j ) &#123; if ( i &gt; j ) i /= 2; else j /= 2; &#125; return T[i];&#125; 2.二叉树前序遍历非递归算法123456789101112131415161718void PreOrder( BiTree T )&#123; BiTree S[MAXSIZE], p; int top = -1; p = T; while ( p || top != -1 ) &#123; if (p) &#123; visit( p ); S[++top] = p; p = p-&gt;lchild; &#125; else &#123; p = S[top--]; p = p-&gt;rchild; &#125; &#125;&#125; 3.二叉树中序遍历非递归算法1234567891011121314151617void InOrder( BiTree T )&#123; BiTree S[MAXSIZE], p; int top = -1; p = T; while ( p || top != -1 ) &#123; if (p ) &#123; S[++top] = p; p = p-&gt;lchild; &#125; else &#123; p = S[top--]; visit( p ); p = p-&gt;rchild; &#125; &#125;&#125; 4.二叉树后序遍历非递归算法1234567891011121314151617181920212223242526void PostOrder( BiTree T )&#123; BiTree Q[MAXSIZE], p, r; int top = -1; p = T; r = NULL; while ( p || top != -1 ) &#123; if (p) // 走到最左边 &#123; S[++top] = p; p = p-&gt;lchild; &#125; else // 向右 &#123; p = S[top]; if (p-&gt;rchild&amp;&amp;p-&gt;rchild!=r) // 转向右 p = p-&gt;rchild; else // 根 &#123; p = S[top--]; visit( p ); r = p; p = NULL; &#125; &#125; &#125;&#125; 5.二叉树层次遍历算法12345678910111213void LevelOrder( BiTree T )&#123; BiTree Q[MAXSIZE], p; int front = -1, rear = -1; Q[++rear] = T; while ( front != rear ) &#123; p = Q[++front]; visit( p ); if ( p-&gt;lchild ) Q[++rear] = p-&gt;lchild; if ( p-&gt;rchild ) Q[++rear] = p-&gt;rchild; &#125;&#125; 6.二叉树的自下而上,从右到左的层次遍历算法1234567891011121314151617void InvertLevel( BiTree T )&#123; BiTree S[MAXSIZE], Q[MAXSIZE], p; int front = -1, rear = -1, top = -1; Q[++rear] = T; while ( front != rear ) &#123; p = Q[++front]; S[++top] = p; if ( p-&gt;lchild ) Q[++rear] = p-&gt;lchild; if ( p-&gt;rchild ) Q[++rear] = p-&gt;rchild; &#125; while ( top!=-1 ) &#123; p = S[top--]; visit( p ); &#125;&#125; 7.求二叉树高度(递归)12345678int BtDepth( BiTree T )&#123; if ( T == NULL ) return 0; int ldepth, rdepth; ldepth = BtDepth( T-&gt;lchild ); rdepth = BtDepth( T-&gt;rchild ); return ldepth &gt; rdepth ? ldepth + 1 : rdepth + 1;&#125; 8.求二叉树高度(非递归) 法一思路:后序遍历,最大栈长即为树的高度 123456789101112131415161718192021222324252627int BtDepth( BiTree T )&#123; BiTree S[MAXSIZE], p, r; int top = -1, depth = 0; while ( p || top != -1 ) &#123; if ( p ) &#123; S[++top] = p; p = p-&gt;lchild; &#125; else &#123; p = S[top]; if ( p-&gt;rchild&amp;&amp;p-&gt;rchild != r ) p = p-&gt;rchild; else &#123; if (top+1&gt;depth) depth = top + 1; p = S[top--]; r = p; p = NULL; &#125; &#125; &#125; return depth;&#125; 法二思路:层次遍历,层数即为高度 1234567891011121314151617181920int BtDepth( BiTree T )&#123; BiTree Q[MAXSIZE], p; int front = -1, rear = -1, last = 0, depth = 0; Q[++rear] = T; while ( front != rear ) &#123; p = Q[++front]; if ( p-&gt;lchild ) Q[++rear] = p-&gt;lchild; if ( p-&gt;rchild ) Q[++rear] = p-&gt;rchild; if ( front == last ) &#123; depth++; last = rear; &#125; &#125; return depth;&#125; 9.先许遍历序列和中序遍历序列分别存放于两个一维数组A[1…n],B[1…n]中,编写算法建立该二叉树的二叉链表123456789101112131415161718BiTree PreInCreate( ElemType A[], ElemType B[], int l1, int h1, int l2, int h2 )&#123; BiTree root = ( BiTree ) malloc( sizeof( BiTNode ) ); int i, llen, rlen; root-&gt;data = A[l1]; for ( i = l2; B[i] != root-&gt;data; i++ ); llen = i - l2; rlen = h2 - i; if ( llen ) root-&gt;lchild = PreInCreate( A, B, l1 + 1, l1 + llen, l2, l2 + llen - 1 ); else root-&gt;rchild = NULL; if ( rlen ) root-&gt;rchild = PreInCreate( A, B, h1 - rlen + 1, h1, h2 - rlen + 1, h2 ); else root-&gt;rchild = NULL; return root;&#125; 10.判断二叉树是否是完全二叉树12345678910111213141516171819202122232425bool IsComplete( BiTree T )&#123; if ( T == NULL ) return true; BiTree Q[MAXSIZE], p; int front = -1, rear = -1; Q[++rear] = T; while ( front != rear ) &#123; p = Q[++front]; if (p) &#123; Q[++rear] = p-&gt;lchild; Q[++rear] = p-&gt;rchild; &#125; else &#123; while ( front != rear ) &#123; p = Q[++front]; if ( p ) return false; &#125; &#125; &#125; return true;&#125; 11.计算一棵给定二叉树的所有双分支结点个数1234567int N2Nodes( BiTree T )&#123; if ( T == NULL ) return 0; if ( T-&gt;lchild &amp;&amp; T-&gt;rchild ) return N2Nodes( T-&gt;lchild ) + N2Nodes( T-&gt;rchild ) + 1; return N2Nodes( T-&gt;lchild ) + N2Nodes( T-&gt;rchild );&#125; 12.将二叉树中所有结点的左,右子树进行交换1234567void SwapTree( BiTree T )&#123; if ( T == NULL ) return; SwapTree( T-&gt;lchild ); SwapTree( T-&gt;rchild ); swap( T-&gt;lchild, T-&gt;rchild );&#125; 13.求二叉树先序遍历序列中第k(1≤k≤二叉树结点个数)个结点的值1234567891011int i = 1;ElemType PreNodeK( BiTree T, int k )&#123; if ( T == NULL ) return '#'; if ( i == k ) return T-&gt;data; i++; // 下一个结点 ElemType ch = PreNodeK( T-&gt;lchild, k ); if ( ch != '#' ) return ch; ch = PreNodeK( T-&gt;rchild, k ); return ch;&#125; 14.二叉树中,对于每一个元素值为x的结点,删去以它为根的子树,并释放相应的空间1234567void DeleteNode( BiTree T )&#123; if ( T == NULL ) return; DeleteNode( T-&gt;lchild ); DeleteNode( T-&gt;rchild ); free( T );&#125; 法一:递归 12345678910void DeleteAllXNode( BiTree T, ElemType x )&#123; if ( T == NULL ) return; if ( T-&gt;data == x ) &#123; DeleteNode( T ); return; &#125; DeleteAllXNode( T-&gt;lchild, x ); DeleteAllXNode( T-&gt;rchild, x );&#125; 法二:非递归 1234567891011121314151617void DeleteAllXNode( BiTree T, ElemType x )&#123; if ( T == NULL ) return; BiTree Q[MAXSIZE], p; int front = -1, rear = -1; Q[++rear] = T; while ( front != rear ) &#123; p = Q[++front]; if ( p-&gt;data == x ) DeleteNode( p ); else &#123; if ( p-&gt;lchild ) Q[++rear] = p-&gt;lchild; if ( p-&gt;rchild ) Q[++rear] = p-&gt;rchild; &#125; &#125;&#125; 15.输出二叉树中值为x的结点(≤1)个的所有祖先 法一:递归 12345678910bool AllAncestorX( BiTree T, ElemType x )&#123; if ( T == NULL ) return false; if ( T-&gt;data == x ) return true; bool b1, b2; b1 = AllAncestorX( T-&gt;lchild, x ); b2 = AllAncestorX( T-&gt;rchild, x ); if ( b1 || b2 ) visit( T ); return b1 || b2;&#125; 法二:非递归思路: 后序遍历非递归方式中,保留在栈中所有元素(除栈顶外)必然是栈顶的祖先结点,只要找到x结点,将所有结点出栈即可 123456789101112131415161718192021222324252627282930313233void AllAncestorX( BiTree T, ElemType x )&#123; if ( T == NULL ) return; BiTree S[MAXSIZE], p, r; int top = -1; p = T; r = NULL; while ( p||top!=-1 ) &#123; if (p) &#123; S[++top] = p; p = p-&gt;lchild; &#125; else &#123; p = S[top]; if ( p-&gt;rchild&amp;&amp;p-&gt;rchild != r ) p = p-&gt;rchild; else &#123; p = S[top--]; if (p-&gt;data==x) &#123; while ( top != -1 ) &#123; p = S[top--]; visit( p ); &#125; &#125; r = p; p = NULL; &#125; &#125; &#125;&#125; 16.p,q为二叉树中任意两个结点的指针,编写算法找到p,q的最近公共祖先结点(递归)1234567891011121314151617181920212223242526// 思路: ①左子树中能找到p(或q),右子树中能找到q(或p),的结点一定为p,q的最近公共结点// ②p,q都在右子树上,则深度低的为公共祖先// ③p,q都在左子树上,则深度低的为公共祖先// 三种情况 o &lt;-root(此时为公共祖先) o &lt;-root o &lt;-root// / \ \ /// p-&gt; o o &lt;-q o &lt;-p(此时为公共祖先为right) o &lt;-p(此时为公共祖先left)// \ /// o &lt;-q o &lt;-qBiTree Ancestor( BiTree root, BiTNode *p, BiTNode *q )&#123; if ( !root || !p || !q ) return NULL; if ( p == root || q == root ) return root; BiTree left, right; /* * ①在左子树中,若找到p,q中一个,则返回一个 * ②在左子树中,若找到p,q(全),则返回较近的一个(高度较低的) */ left = Ancestor( root-&gt;lchild, p, q ); /* * ①在右子树中,若找到p,q中一个,则返回一个 * ②在右子树中,若找到p,q(全),则返回较近的一个(高度较低的) */ right = Ancestor( root-&gt;rchild, p, q ); if ( left&amp;&amp;right ) return root; return left ? left : right;&#125; 17.求非空二叉树的宽度12345678910111213141516171819int TreeWidth( BiTree T )&#123; BiTree Q[MAXSIZE], p; int front = -1, rear = -1, maxWidth = 0; Q[++rear] = T; while ( front != rear ) &#123; int width = rear - front; if ( maxWidth &lt; width ) maxWidth = width; while ( width-- ) &#123; p = Q[++front]; if ( p-&gt;lchild ) Q[++rear] = p-&gt;lchild; if ( p-&gt;rchild ) Q[++rear] = p-&gt;rchild; &#125; &#125; return maxWidth;&#125; 18.一棵满二叉树(所有结点值均不同),已知其先序序列为pre,设计算法求其后序序列post1234567891011// 思路: 每次都会确定出后序的一个位置并划分为左右两块,再分别在这左右两块中继续确定其他元素 // 先序: x| | |// 后序: | | |xvoid PreToPost( ElemType pre[], int l1, int h1, ElemType post[], int l2, int h2 )&#123; if ( h1 &lt; l1 ) return; post[h2] = pre[l1]; // 确定出一个后序位置 int half = ( h1 - l1 ) / 2; PreToPost( pre, l1 + 1, l1 + half, post, l2, l2 + half - 1 ); PreToPost( pre, h1 - half + 1, h1, post, h2 - half, h2 - 1 );&#125; 19.将二叉树叶子结点按从左到右连成单链表,表头指针为head,叶结点的右指针域存放单链表指针1234567891011121314151617181920BiTree head, pre = NULL;BiTree InOrder( BiTree bt )&#123; if ( bt == NULL ) return NULL; InOrder( bt-&gt;lchild ); if ( !bt-&gt;lchild &amp;&amp; !bt-&gt;rchild ) &#123; if (!pre) &#123; head = pre = bt; &#125; else &#123; pre-&gt;rchild = bt; pre = bt; &#125; &#125; InOrder( bt-&gt;rchild ); pre-&gt;rchild = NULL; return head;&#125; 20.判断两棵二叉树是否相似.(注:不要求结点值相同,只要树的外形相同即可)12345678910bool Similar( BiTree T1, BiTree T2 )&#123; if ( T1 == NULL &amp;&amp; T2 == NULL ) return true; else if ( T1 == NULL || T2 == NULL ) return false; else if ( Similar( T1-&gt;lchild, T2-&gt;lchild ) &amp;&amp; Similar( T1-&gt;rchild, T2-&gt;rchild ) ) return true; return false;&#125; 21.将表达式树转换为等价的中缀表达式(通过括号反映操作符的计算次序)并输出1234567891011121314// 思路: 表达式树的中序序列加上必要的括号即为等价的中缀表达式.除根结点外,遍历到其他结点时在遍历其左子树之前加上左括号,在遍历完右子树后加上右括号void BiTreeToExp( BiTree T, int deep )&#123; if ( T == NULL ) return; else if ( !T-&gt;lchild &amp;&amp; !T-&gt;rchild ) visit( T ); else &#123; if ( deep &gt; 1 ) printf( "(" ); BiTreeToExp( T-&gt;lchild, deep + 1 ); visit( T ); BiTreeToExp( T-&gt;rchild, deep + 1 ); if ( deep &gt; 1 ) printf( "(" ); &#125;&#125; 22.求孩子兄弟表示法存储的森林的叶子节点数1234567891011121314typedef struct CSNode&#123; ElemType data; struct CSNode *firstchild, *nextsibling;&#125;CSNode, *CSTree;int Leaves( CSTree T )&#123; if ( T == NULL ) return 0; if ( T-&gt;firstchild == NULL ) return 1 + Leaves( T-&gt;nextsibling ); else return Leaves( T-&gt;firstchild ) + Leaves( T-&gt;nextsibling );&#125; 23.以孩子兄弟链表为存储结构,求树的高度(深度)(递归)12345678int Height( CSTree T )&#123; if ( T == NULL ) return 0; int hc, hs; hc = Height( T-&gt;firstchild ) + 1; hs = Height( T-&gt;nextsibling ); return hc &gt; hs ? hc : hs;&#125; 24.二叉排序树的查找(非递归)1234567891011BiTree BSTSearch( BiTree T, ElemType key )&#123; while ( T &amp;&amp; key != T-&gt;data ) &#123; if ( key &lt; T-&gt;data ) T = T-&gt;lchild; else T = T-&gt;rchild; &#125; return T;&#125; 或123456789101112BiTree BSTSearch( BiTree T, ElemType key )&#123; while ( T ) &#123; if ( T-&gt;data == key ) return T; else if ( T-&gt;data &gt; key ) T = T-&gt;lchild; else T = T-&gt;rchild; &#125; return T;&#125; 25.二叉排序树的插入(递归)12345678910111213bool BSTInsert( BiTree&amp; T, ElemType key )&#123; if (!T) &#123; T = ( BiTree ) malloc( sizeof( BiTNode ) ); T-&gt;data = key; T-&gt;lchild = T-&gt;rchild = NULL; return true; &#125; else if ( T-&gt;data == key ) return false; else if ( T-&gt;data &gt; key ) return BSTInsert( T-&gt;lchild, key ); else return BSTInsert( T-&gt;rchild, key );&#125; 26.计算二叉树的带权路径长度(递归)12345678910111213int wpl = 0;int WPL_PreOrder( BiTree T, int deep )&#123; if ( T == NULL ) return 0; if ( !T-&gt;lchild &amp;&amp; !T-&gt;rchild ) wpl += deep * T-&gt;weight; else &#123; if ( T-&gt;lchild ) WPL_PreOrder( T-&gt;lchild, deep + 1 ); if ( T-&gt;rchild ) WPL_PreOrder( T-&gt;rchild, deep + 1 ); &#125; return wpl;&#125; 27.计算二叉树的带权路径长度(非递归)12345678910111213141516171819202122232425// 思路: 层序遍历的思想int wpl = 0;int WPL_LevelOrder( BiTree T )&#123; if ( T == NULL ) return 0; BiTree Q[MAXSIZE], p; int front = -1, rear = -1, depth = 0, last = 0; Q[++rear] = T; while ( front != rear ) &#123; p = Q[++front]; if ( !p-&gt;lchild &amp;&amp; !p-&gt;rchild ) wpl += depth * p-&gt;weight; else &#123; if ( p-&gt;lchild ) Q[++rear] = p-&gt;lchild; if ( p-&gt;rchild ) Q[++rear] = p-&gt;rchild; &#125; if ( front == last ) &#123; depth++; last = rear; &#125; &#125; return wpl;&#125; 28.判断二叉树是否为二叉排序树123456789101112ElemType preVal = MIN;bool IsBST( BiTree T )&#123; if ( T == NULL ) return true; if ( !IsBST( T-&gt;lchild ) ) return false; if ( preVal &gt;= T-&gt;data ) return false; else preVal = T-&gt;data; if ( !IsBST( T-&gt;rchild ) ) return false; return true;&#125; 29.求出指定结点在二叉排序树中的层次1234567891011121314int Level( BiTree T, BiTree p )&#123; if ( T == NULL ) return 0; int n = 1; while ( T-&gt;data != p-&gt;data ) &#123; n++; if ( p-&gt;data &lt; T-&gt;data ) T = T-&gt;lchild; else T = T-&gt;rchild; &#125; return n;&#125; 30.判断二叉树是否为平衡二叉树1234567891011121314151617bool IsAVL( BiTree T, int&amp; h )&#123; int h1 = 0, h2 = 0; if (T==NULL ) &#123; h = 0; return true; &#125; if ( IsAVL( T-&gt;lchild, h1 ) &amp;&amp; IsAVL( T-&gt;rchild, h2 ) ) &#123; if ( abs( h1 - h2 ) &lt;= 1 ) &#123; h = 1 + ( h1 &gt; h2 ? h1 : h2 ); return true; &#125; &#125; return false;&#125; 31.从大到小输出二叉排序中所有值不小于k的关键字12345678910void DesOutput( BiTree T, ElemType k )&#123; if ( T == NULL ) return; DesOutput( T-&gt;rchild, k ); if ( T-&gt;data &gt;= k ) visit( T ); else return; DesOutput( T-&gt;lchild, k );&#125; 32.在二叉排序树上查找第k(1≤k≤n)小的元素,要求平均时间复杂度为O(log2n)二叉排序树上的每个结点中除data,lchild,rchild外,还增加一个count成员,保存以该结点为根的子树上的结点个数 法一 123456789101112131415161718BiTree SearchSmallK( BiTree T, int k )&#123; if ( k&lt;1 || k&gt;T-&gt;count ) return NULL; if ( T-&gt;lchild ) &#123; if ( k &lt;= T-&gt;lchild-&gt;count ) return SearchSmallK( T-&gt;lchild, k ); else if ( k == T-&gt;lchild-&gt;count + 1 ) return T; else return SearchSmallK( T-&gt;rchild, k - ( T-&gt;lchild-&gt;count + 1 ) ); &#125; else &#123; if ( k == 1 ) return T; else return SearchSmallK( T-&gt;rchild, k - 1 ); &#125;&#125; 法二 1234567891011121314BiTree SearchSmallK( BiTree T, int k )&#123; if ( k&lt;1 || k&gt;T-&gt;count ) return NULL; if ( T-&gt;lchild ) &#123; if ( k &lt;= T-&gt;lchild-&gt;count ) return SearchSmallK( T-&gt;lchild, k ); else k -= T-&gt;lchild-&gt;count; &#125; if ( k == 1 ) return T; if ( T-&gt;rchild ) return SearchSmallK( T-&gt;rchild, k - 1 );&#125; 33.对于含有+,−,∗,/及括号的算术表达式(中缀表达式)写一个算法,将该表达式构造成相应的二叉树表示1234567891011121314151617181920212223242526272829303132333435363738394041// 思想: 最后使用的操作符作为根.即:先+,-后*,/// 例如: a+b*(c-d)-e/f构造的表达式树如下:// -// / \// + /// / \ / \// a * e f// / \// b -// / \// c d// 通过该表达式树,可以很容易得到:// 前缀表达式: -+a*b-cd/ef// 中缀表达式: a+b*c-d-e/f// 后缀表达式: abcd-*+ef/-BiTNode* BuildTree( char* exp, int s, int e )&#123; if ( e - s == 1 ) &#123; BiTNode* p = ( BiTNode* ) malloc( sizeof( BiTNode ) ); p-&gt;data = exp[s]; p-&gt;lchild = p-&gt;rchild = NULL; return p; &#125; int c1 = -1, c2 = -1, c = 0, i; for ( i = s; i &lt; e; i++ ) &#123; if ( exp[i] == '(' ) c++; else if ( ( exp[i] == '+' || exp[i] == '-' ) &amp;&amp; !c ) c1 = i; else if ( ( exp[i] == '*' || exp[i] == '/' ) &amp;&amp; !c ) c2 = i; &#125; if ( c1 &lt; 0 ) c1 = c2; if ( c1 &lt; 0 ) return BuildTree( exp, s + 1, e - 1 ); BiTree* p = ( BiTNode* ) malloc( sizeof( BiTNode ) ); p-&gt;data = exp[c1]; p-&gt;lchild = BuildTree( exp, s, c1 ); p-&gt;rchild = BuildTree( exp, c1 + 1, e ); return p;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[algorithm]图]]></title>
    <url>%2F2019%2F05%2F07%2Falgorithm-%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[一.图的算法1. 邻接矩阵和邻接表的表示1). 邻接矩阵表示的数据结构123456789101112131415161718192021#define INFINITY INT_MAX // 无穷大#define MAX_VERTEX_NUM 20 // 限制顶点最大数值为20个#define MAX_ARC_NUM MAX_VERTEX_NUM * (MAX_VERTEX_NUM - 1) // 由n个顶点，最多可以确定n(n-2)/2条直线,有向图为2倍#define MAX_INFO 20 // 用户输入的弧信息，最多20个字符/*数组表示法*/typedef int VRType;typedef char InfoType;typedef char VertexType[5];typedef enum &#123;DG, DN, UDG, UDN&#125; GraphKind; typedef struct ArcCell &#123; VRType adj; InfoType *info;&#125;ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];typedef struct &#123; VertexType vexs[MAX_VERTEX_NUM]; AdjMatrix arcs; int vexnum, arcnum;&#125;MGraph; 2). 邻接表表示的数据结构123456789101112131415161718192021/*邻接表表示法*/typedef struct ArcNode&#123; int adjvex; int w; // 存储权值，书中的程序没有表示权值的数据成员(书中说用info来存储权值，但是上面的程序又是单独用的adj存权值，为了一致性，info还是用来存储其他信息算了) struct ArcNode *nextarc; InfoType *info; // 用来存储权值以外的有关弧的信息&#125;ArcNode;typedef struct VNode&#123; VertexType data; ArcNode *firstarc;&#125;VNode, AdjList[MAX_VERTEX_NUM];typedef struct&#123; AdjList vertices; int vexnum, arcnum; int kind;&#125;ALGraph; 2.写出从图的邻接表表示转换成邻接矩阵表示的算法123456void Convert( ALGraph G, int arcs[][10] )&#123; for ( int v = 0; v &lt; G.vexnum; v++ ) for ( ArcNode* p = G.vertices[v].firstarc; p; p-&gt;nextarc ) arcs[v][p-&gt;adjvex] = 1;&#125; 二.图的遍历 说明: 以下图的算法既可以使用邻接矩阵的方式也可以使用邻接表存储的方式,因此每种算法都可以换成另一种存储形式,只需要把MGraph(邻接矩阵存储)换成ALGraph(邻接表存储)即可 1. 寻找邻接点1). 邻接矩阵下,通用找邻接的函数:12345678910111213141516// 第一个邻居int FirstNeighbor( MGraph G, int v)&#123; for ( int i = 0; i &lt; G.vexnum; i++ ) if ( G.arcs[v][i] == 1 ) return i; return -1;&#125;// 当前的下一个邻居int NextNeighbor( MGraph G, int v, int w )&#123; for (int i = w+1; i &lt; G.vexnum; i++ ) if ( G.arcs[v][i] == 1 ) return i; return -1;&#125; 2). 邻接表下,通用找邻接的函数:123456789101112131415161718192021222324252627/*全局变量*/bool Visited[MAX_VERTEX_NUM]; // 记录每个顶点是否被访问过// 找到第一个v相邻的顶点，返回它的下标int FirstAdjVex(ALGraph &amp;AL, int v)&#123; ArcNode *p = NULL; p = AL.vertices[v].firstarc; if (p == NULL) return -1; else return p-&gt;adjvex;&#125;// 找到下一个与v相邻的顶点，返回它的下标int NextAdjVex(ALGraph &amp;AL, int v, int w)&#123; ArcNode *p = NULL; p = AL.vertices[v].firstarc; while (p-&gt;adjvex != w) // 找到下标为w的结点 p = p-&gt;nextarc; p = p-&gt;nextarc; // 指针指向下标为w的结点的后面一个结点 if (p == NULL) return -1; else return p-&gt;adjvex;&#125; 2. 遍历方法(BFS+DFS)1). 广度优先搜索(Breadth-First-Search, BFS) 法一:采用邻接矩阵 123456789101112131415161718192021222324252627282930313233343536bool visited[MAX_VERTEX_NUM] = &#123; false &#125;;void BFS( MGraph G, int v );void BFSTraverse( MGraph G )&#123; int Q[MAXSIZE]; int front = -1, rear = -1; for (int v = 0; v &lt; G.vexnum; v++ ) if ( !visited[v] ) BFS( G, v );&#125;void BFS( MGraph G, int v )&#123; int Q[MAXSIZE]; int front = -1, rear = -1; // BFS顶点三连 visit( v ); visited[v] = true; Q[++rear] = v; while ( front != rear ) &#123; v = Q[++front]; for ( int w = FirstNeighbor( G, v ); w &gt;= 0; w = NextNeighbor( G, v, w ) ) &#123; if (!visited[w]) &#123; // BFS顶点三连 visit( w ); visited[w] = true; Q[++rear] = w; &#125; &#125; &#125;&#125; 法二:采用邻接表 123456789101112131415161718192021222324252627282930313233343536bool visited[MAX_VERTEX_NUM] = &#123; false &#125;;void BFS( ALGraph G, int v );void BFSTraverse( ALGraph G )&#123; int Q[MAXSIZE]; int front = -1, rear = -1; for (int v = 0; v &lt; G.vexnum; v++ ) if ( !visited[v] ) BFS( G, v );&#125;void BFS( ALGraph G, int v )&#123; int Q[MAXSIZE]; int front = -1, rear = -1; // BFS顶点三连 visit( v ); visited[v] = true; Q[++rear] = v; while ( front != rear ) &#123; v = Q[++front]; for ( int w = FirstNeighbor( G, v ); w &gt;= 0; w = NextNeighbor( G, v, w ) ) &#123; if (!visited[w]) &#123; // BFS顶点三连 visit( w ); visited[w] = true; Q[++rear] = w; &#125; &#125; &#125;&#125; 2). 深度优先搜索(Depth-First-Search, DFS)123456789101112131415161718bool visited[MAX_VERTEX_NUM] = &#123; false &#125;;void DFS( ALGraph &amp;G, int v );void DFSTraverse( ALGraph &amp;G )&#123; for ( int v = 0; v &lt; G.vexnum; v++ ) if ( !visited[v] ) DFS( G, v );&#125;void DFS( ALGraph &amp;G, int v )&#123; visit( v ); visited[v] = true; for ( int w = FirstNeighbor( G, v ); w &gt;= 0; w = NextNeighbor( G, v, w ) ) if ( !visited[w] ) DFS( G, w );&#125; 三.综合算法1. BFS算法求解单源最短路径问题1234567891011121314151617181920212223242526bool visited[MAXSIZE] = &#123; false &#125;;unsigned int d[MAXSIZE] = &#123; INFINITE &#125;;void BFS_MIN_Distance( ALGraph G, int u )&#123; BiTree Q[MAXSIZE]; int front = -1, rear = -1, v, w; // BFS路径三连 d[u] = 0; visited[u] = true; Q[++rear] = u; while ( front != rear ) &#123; v = Q[++front]; for ( w = FirstNeighbor( G, v ); w &gt;= 0; w = NextNeighbor( G, v, w ) ) &#123; if (!visited[w]) &#123; // BFS路径三连 d[w] = d[v] + 1; visited[w] = true; Q[++rear] = w; &#125; &#125; &#125;&#125; 2.设计一个算法,判断一个无向图G是否为一棵树12345678910111213141516171819int visited[MAXSIZE] = &#123; 0 &#125;;void DFS( MGraph G, int v, int&amp; Vnum, int&amp; TD );bool IsTree( MGraph G )&#123; int Vnum = 0, TD = 0; // TD=total degree总度数 DFS( G, 0, Vnum, TD ); // 从第一个顶点开始遍历 if ( Vnum == G.vexnum&amp;&amp;TD == 2 * ( G.vexnum - 1 ) ) return true; return false;&#125;void DFS( MGraph G, int v, int&amp; Vnum, int&amp; TD )&#123; visited[v] = true; Vnum++; for ( int w = FirstNeighbor( G, v ); w &gt;= 0; w = NextNeighbor( G, v, w ) ) if ( !visited[w] ) DFS( G, w, Vnum, TD );&#125; 3.写出图的深度优先搜索DFS算法的非递归算法123456789101112131415161718192021222324bool visited[MAXSIZE] = &#123; false &#125;;void DFS_NON_RC( MGraph G, int v )&#123; int S[MAXSIZE]; int top = -1; for ( int i = 0; i &lt; G.vexnum; i++ ) visited[i] = false; // 顶点二连 visited[v] = true; S[++top] = v; while ( top != -1 ) &#123; v = S[top--]; visit( v ); for ( int w = FirstNeighbor( G, v ); w &gt;= 0; w = NextNeighbor( G, v, w ) ) if ( !visited[w] ) &#123; // 顶点二连 visited[w] = true; S[++top] = w; &#125; &#125;&#125; 4.分别采用基于广度优先遍历和深度优先遍历算法判别以邻接表或邻接矩阵存储的有向图中是否存在由顶点v到顶点u的路径(v≠u)1234567891011121314151617181920212223// 采用BFS的方法bool visited[MAXSIZE] = &#123; false &#125;;bool Exist_Path_BFS( MGraph G, int v, int u )&#123; int Q[MAXSIZE]; int front = -1, rear = -1; visited[v] = true; Q[++rear] = v; while ( front != rear ) &#123; v = Q[++front]; for ( int w = FirstNeighbor( G, v ); w &gt;= 0; w = NextNeighbor( G, v, w ) ) &#123; if (!visited[w]) &#123; if ( w == u ) return true; visited[w] = true; Q[++rear] = w; &#125; &#125; &#125; return false;&#125; 123456789101112131415// 采用DFS的方法bool visited[MAXSIZE] = &#123; false &#125;;bool Exist_Path_DFS( MGraph G, int v, int u )&#123; if ( v == u ) return true; visited[v] = true; for ( int w = FirstNeighbor( G, v ); w &gt;= 0; w = NextNeighbor( G, v, w ) ) &#123; if ( !visited[w] ) &#123; if ( Exist_Path_DFS( G, w, u ) ) return true; &#125; &#125; return false;&#125; 5.拓扑排序:判断并输出有向图的拓扑序列12345678910111213141516171819202122232425262728293031bool Topological( MGraph G, int indegree[] )&#123; int S[MAXSIZE]; int top = -1, Vnum = 0, v = 0; for ( v = 0; v &lt; G.vexnum; v++ ) &#123; if ( indegree[v] == 0 ) &#123; visit( v ); Vnum++; S[++top] = v; &#125; &#125; while ( top != -1 ) &#123; v = S[top--]; for ( int w = FirstNeighbor( G, v ); w &gt;= 0; w = NextNeighbor( G, v, w ) ) &#123; indegree[w]--; if ( indegree[w] == 0 ) &#123; visit( w ); Vnum++; S[++top] = w; &#125; &#125; &#125; if ( Vnum == G.vexnum ) return true; return false;&#125; 6.拓扑排序(DFS):有向无环图的拓扑排序123456789101112131415161718192021bool visited[MAXSIZE] = &#123; false &#125;;int time = 0, finishTime[MAXSIZE] = &#123; 0 &#125;;void DFS( MGraph G, int v );void Topological_DFS( MGraph G )&#123; for ( int v = 0; v &lt; G.vexnum; v++ ) if ( !visited[v] ) DFS( G, v ); for ( int t = time - 1; t &gt;= 0; t-- ) visit( finishTime[t] );&#125;void DFS( MGraph G, int v )&#123; visited[v] = true; for ( int w = FirstNeighbor( G, v ); w &gt;= 0; w = NextNeighbor( G, v, w ) ) if ( !visited[w] ) DFS( G, w ); finishTime[time++] = v;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[algorithm]查找]]></title>
    <url>%2F2019%2F05%2F07%2Falgorithm-%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[一.查找的算法1.折半查找(二分查找)123456789101112131415int binary_search( string s, char ch )&#123; int low = 0, high = s.size()-1; while (low &lt;= high) &#123; int mid = ( low + high ) / 2; if ( ch == s[mid] ) return mid; else if ( ch &lt; s[mid] ) high = mid - 1; else low = mid + 1; &#125; return -1;&#125; 时间复杂度: $O(log_2{n})$ 3.折半查找(二分查找)递归12345678910111213int binary_search_rc( string s, char ch, int low, int high )&#123; if ( low &gt; high ) return 0; int mid = ( low + high ) / 2; if ( ch == s[mid] ) return mid; else if ( ch &lt; s[mid] ) high = mid - 1; else low = mid + 1; return binary_search_rc( s, ch, low, high );&#125; 时间复杂度: $O(log_2{n})$ 二.字符串匹配1.简单的模式匹配算法(朴素模式匹配算法)1234567891011int naive_search( string S, string T )&#123; int i = 0, j = 0, lenS = S.size(), lenT = T.size(); while ( i &lt; lenS &amp;&amp; j &lt; lenT ) &#123; if ( S[i] == T[j] ) &#123; i++; j++; &#125; else &#123; i = i - j + 1; j = 0; &#125; &#125; if ( j &gt;= lenS ) return i - lenT; return 0;&#125; 时间复杂度: $O(m*n)$ 2.KMP算法算法需要先求出模式串的next值: 12345678910111213void get_next( string T, int next[] )&#123; int i = 0, j = -1, lenT = T.size(); next[0] = -1; while (i&lt;lenT) &#123; if (j==-1||T[i]==T[j] ) &#123; i++; j++; next[i] = j; &#125; else j = next[j]; &#125;&#125; 也可求出改进后的nextval值: 1234567891011121314151617void get_nextval( string T, int nextval[] )&#123; int i = 0, j = -1, lenT = T.size(); nextval[0] = -1; while ( i &lt; lenT ) &#123; if ( j == -1 || T[i] == T[j] ) &#123; i++, j++; if ( T[i] == T[j] ) nextval[i] = nextval[j]; else nextval[i] = j; &#125; else j = nextval[j]; &#125;&#125; 以下是KMP算法:1234567891011int KMP( string S, string T, int next[], int pos )&#123; int i = pos, j = 0, lenS = S.size(), lenT = T.size(); while ( i&lt;lenS&amp;&amp;j&lt;lenT ) &#123; if ( j == -1 || S[i] == T[j] ) &#123; i++; j++; &#125; else j = next[j]; &#125; if ( j &gt;= lenT ) return i - lenT; return 0;&#125; 时间复杂度: $O(m+n)$]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]214.最短回文串]]></title>
    <url>%2F2019%2F05%2F07%2Fleetcode-214-%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[方法一: KMP算法时间复杂度: $O(m+n)$ 解题思路: 实际就是求原串从左到右的最长回文串(必须包含左边所有字符),此处采用倒置+KMP算法来缩短匹配时间 将字符串倒置,原串作为模式串pat,倒置串作为主串txt 求出模式串pat的nextval[]值,然后进行字符串匹配,得到的模式串pat最长匹配长度即为模式串pat从第一个字符开始的最大回文串(匹配过程时间复杂度只需要$O(m+n)$) 对于KMP(Knuth–Morris–Pratt)算法,可以借鉴关于[查找][1]部分的介绍 1234567891011121314151617181920212223242526272829303132int nextval[40005];void get_nextval(string pat)&#123; int i=0,j=-1,len=pat.size(); nextval[0]=-1; for (;i&lt;len&amp;&amp;j&lt;len;) &#123; if (j==-1||pat[i]==pat[j]) &#123; i++,j++; if (pat[i]==pat[j]) nextval[i]=nextval[j]; else nextval[i]=j; &#125; else j=nextval[j]; &#125;&#125;string shortestPalindrome(string txt) &#123; string pat=txt; reverse(txt.begin(),txt.end()); // 字符串倒置 get_nextval(pat); // 计算模式串的nextval值 int i=0,j=0,lenTxt=txt.size(),lenPat=pat.size(); for(;i&lt;lenTxt&amp;&amp;j&lt;lenPat;) // 进行模式串匹配,找出最大匹配长度 &#123; if (j==-1||txt[i]==pat[j]) i++,j++; else j = nextval[j]; &#125; return txt.substr(0,lenTxt-j)+pat;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回文串</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]TOC汇总]]></title>
    <url>%2F2019%2F05%2F07%2Fleetcode-TOC%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[请输入文章密码 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>TOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[algorithm]排序]]></title>
    <url>%2F2019%2F05%2F06%2Falgorithm-%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[一.排序算法1.插入排序1) 直接插入排序:(插入类)12345678910111213void InsertSort( ElemType R[], int n )&#123; for ( int i = 2; i &lt;= n; i++ ) &#123; if ( R[i].key &lt; R[i - 1].key ) &#123; R[0] = R[i]; for ( int j = i - 1; j &gt; 0 &amp;&amp; ( R[0].key &lt; R[j].key ); j-- ) R[j + 1] = R[j]; R[j + 1] = R[0]; &#125; &#125;&#125; 最好情况(顺序有序): 1)比较次数: $\sum_{i=2}^{n} 1=n-1$ 2)移动次数: 0 最坏情况(逆序有序): 1)比较次数: $\sum_{i=2}^{n} i=\frac {(n+2)(n-1)}{2}$ 2)移动次数: $\sum_{i=2}^{n} (i+1)=\frac {(n+4)(n-1)}{2}$ 2)折半插入排序:(插入类)1234567891011121314151617void BiInsertSort( ElemType R[], int n )&#123; for ( int i = 2; i &lt;= n; i++ ) &#123; R[0] = R[i]; int low = 1, high = i - 1; while ( low &lt;= high ) &#123; int mid = ( low + high ) / 2; if ( R[0].key &lt; R[m].key ) high = mid - 1; else low = mid + 1; &#125; for ( int j = i - 1; j &gt; high; j-- ) R[j + 1] = R[j]; R[j + 1] = R[0]; &#125;&#125; 3)希尔排序(又称缩小增量排序)(插入类)1234567891011121314151617// 当dk=1时,即为直接插入排序void ShellSort( ElemType R[], int n )&#123; for ( int dk = n / 2; dk &gt;= 1; dk /= 2 ) &#123; for ( int i = dk + 1; i &lt;= n; i++ ) &#123; if ( R[i].key &lt; R[i - dk].key ) &#123; R[0] = R[i]; for ( j = i - dk; j &gt; 0 &amp;&amp; ( R[0].key &lt; R[j].key ); j -= dk ) R[j + dk] = R[j]; R[j + dk] = R[0]; &#125; &#125; &#125;&#125; 2.交换排序1)起泡排序(冒泡排序)(交换类)12345678910111213141516void BubbleSort( ElemType R[], int n )&#123; for ( int i = 1; i &lt;= n - 1; i++ ) &#123; bool flag = false; for ( int j = n; j &gt; i; j-- ) &#123; if (R[j].key &lt; R[j-1].key ) &#123; swap( R[j], R[j - 1] ); flag = true; &#125; &#125; if ( !flag ) return; &#125;&#125; 2)快速排序:(交换类)12345678910111213141516171819202122232425void Partition( ElemType R[], int low, int high );// 快排void QuickSort( ElemType R[], int low, int high )&#123; if ( low &gt;= high ) return; int pivotpos = Partition( R, low, high ); QuickSort( R, low, pivotpos - 1 ); QuickSort( R, pivotpos + 1, high );&#125;// 划分void Partition( ElemType R[], int low, int high )&#123; ElemType pivot = R[low]; while ( low &lt; high ) &#123; while ( low &lt; high &amp;&amp; R[high].key &gt;= pivot.key ) high--; R[low] = R[high]; while ( low &lt; high &amp;&amp; R[low].key &lt;= pivot.key ) low++; R[high] = R[low]; &#125; R[low] = pivot; return low;&#125; 3.选择排序1)简单选择排序(选择类)123456789101112void SelectSort( ElemType R[], int n )&#123; for ( int i = 0; i &lt; n - 1; i++ ) &#123; int min = i; for ( int j = i + 1; j &lt; n; j++ ) &#123; if ( R[j].key &lt; R[min].key ) min = j; &#125; if ( min != i ) swap( R[i], R[min] ); &#125;&#125; 2)堆排序(选择类)12345678910111213141516171819202122232425262728void AdjustDown( ElemType R[], int s, int n );void HeapSort( ElemType R[], int n )&#123; for ( int i = n / 2; i &gt; 0; i-- ) void AdjustDown( R, i, n ); for ( int i = n; i &gt; 1; i-- ) &#123; swap( R[i], R[1] ); AdjustDown( R, 1, i - 1 ); &#125;&#125;// 向下调整void AdjustDown( ElemType R[], int s, int n )&#123; R[0] = R[s]; for ( int i = 2 * s; i &lt;= n; i *= 2 ) &#123; if ( i &lt; n&amp;&amp;R[i].key &lt; R[i + 1].key ) i++; if (R[0].key &gt;=R[i].key ) break; else &#123; R[s] = R[i]; s = i; &#125; &#125; R[s] = R[0];&#125; 12345678910111213// 向上调整void AdjustUp( ElemType R[], int s )&#123; R[0] = R[s]; int p = s / 2; while ( p &gt;&amp;&amp; R[p].key &lt; R[0].key ) &#123; R[s] = R[p]; s = p; p /= 2; &#125; R[s] = R[0];&#125; 4.归并排序(归并类)12345678910111213141516171819202122232425262728void Merge( ElemType R[], int low, int mid, int high );void MergeSort( ElemType R[], int low, int high )&#123; if ( low &gt;= high ) return; int mid = ( low + high ) / 2; MergeSort( R, low, mid ); MergeSort( R, mid + 1, high ); Merge( R, low, mid, high );&#125;ElemType B[MAXSIZE];void Merge( ElemType R[], int low, int mid, int high )&#123; int i,j,k; for ( i = low; i &lt;= high; i++ ) B[i] = R[i]; i = k = low, j = mid + 1; while ( i &lt;= mid &amp;&amp; j &lt;= high ) &#123; if ( B[i].key &lt;= B[j].key ) R[k++] = B[i++]; else R[k++] = B[j++]; &#125; while ( i &lt;= mid ) R[k++] = B[i++]; while ( j &lt;= high ) R[k++] = B[j++];&#125; 二.综合题(算法)1.设顺序表用数组R[]表示,表中存储在数组下标1~m+n的范围内,前m个元素递增有序,后n个元素递增有序,设计一个算法,使得整个顺序表有序12345678910111213void InsertSort( ElemType R[], int m, int n )&#123; for ( int i = m + 1; i &lt;= m + n; i++ ) &#123; if ( R[i].key &lt; R[i - 1].key ) &#123; R[0] = R[i]; for ( int j = i - 1; j &gt; 0 &amp;&amp; ( R[0].key &lt; R[j].key ); j-- ) R[j + 1] = R[j]; R[j + 1] = R[0]; &#125; &#125;&#125; 2.计数排序:对表进行排序并将结果放到另一个新的表中,要求表中所有关键码互不相同12345678910void CountSort( ElemType A[], ElemType B[], int n )&#123; for ( int i = 0; i &lt; n; i++ ) &#123; int cnt = 0; for ( int j = 0; j &lt; n; j++ ) if ( A[i].key &gt; A[j].key )cnt++; B[cnt] = A[i]; &#125;&#125; 3.双向冒泡排序1234567891011121314151617181920212223242526// 思想:第一趟通过交换把最大的放最后,第二趟通过交换把最小的放最前,反复进行void BubbleSort( ElemType A[], int n )&#123; int low = 0, high = n - 1, i; bool flag = true; while ( low &lt; high &amp;&amp; flag ) &#123; flag = false; for (i = low; i &lt; high; i++ ) &#123; if (A[i]&gt;A[i+1] ) &#123; swap( A[i], A[i + 1] ); flag = true; &#125; &#125; high--; for ( i = high; i &gt; low; i-- ) &#123; if ( A[i] &lt; A[i - 1] ) &#123; swap( A[i], A[i - 1] ); flag = true; &#125; &#125; low++; &#125;&#125; 4.单链表的简单选择排序(假设不带表头结点)123456789101112131415161718192021222324void SelectSort( LinkList&amp; L )&#123; LinkList h, p, s, pre, r; h = L; while ( h ) &#123; p = s = h; pre = r = NULL; // 找最大结点s while ( p ) &#123; if (p-&gt;data&gt;s-&gt;data ) &#123; s = p; r = pre; &#125; pre = p; p = p-&gt;next; &#125; // 脱链 if ( s == h ) h = h-&gt;next; else r-&gt;next = s-&gt;next; // 头插法 s-&gt;next = L; L = s; &#125;&#125; 5.顺序表中有n个不同整数(下标1~n),设计算法把所有奇数移动到偶数前面(时,空都最少)1234567891011121314void Move( ElemType A[], int n )&#123; int low = 1, high = n; while ( low &lt; high ) &#123; while ( low &lt; high&amp;&amp;A[low] % 2 ) low++; while ( low &lt; high &amp;&amp; A[high] % 2 == 0 ) high--; if ( low &lt; high ) &#123; swap( A[low], A[high] ); low++; high--; &#125; &#125;&#125; 6.在顺序表中找出第k小的元素(时空最少)12345678910111213141516171819202122// 思想:划分int Partition( ElemType R[], int low, int high )&#123; int pivot = R[low]; while ( low &lt; high ) &#123; while ( low &lt; high &amp;&amp; R[high].key &gt;= pivot.key ) high--; R[low] = R[high]; while ( low &lt; high&amp;&amp; R[low].key &lt;= pivot.key ) low++; R[high] = R[low]; &#125; R[low] = pivot; return low;&#125;ElemType Kth_elem( ElemType R[], int low, int high, int k )&#123; int pivotpos = Partition( R, low, high ); if ( pivotpos == k ) return R[pivotpos]; else if ( pivotpos &gt; k ) return Kth_elem( R, low, pivotpos - 1, k ); else return Kth_elem( R, pivotpos + 1, high, k );&#125; 7.n个正整数构成的集合A,将其划分为两个不相交的子集$A1,A2$,元素个数分别是n1和n2.A1和A2中元素之和分别为S1和S2.设计一个时空高效算法,使|n1-n2|最小且|s1-s1|最大.(下标从1开始)1234567891011121314151617181920212223242526272829int Partition( ElemType R[], int low, int high )&#123; int pivot = R[low]; while ( low &lt; high ) &#123; while ( low &lt; high &amp;&amp; R[high].key &gt;= pivot.key ) high--; R[low] = R[high]; while ( low &lt; high&amp;&amp; R[low].key &lt;= pivot.key ) low++; R[high] = R[low]; &#125; R[low] = pivot; return low;&#125;int SetPartition( ElemType R[], int n, int low, int high )&#123; int k = n / 2, s1, s2, i; int pivotpos = Partition( R, low, high ); if ( pivotpos == k ) &#123; s1 = s2 = 0; for ( i = 1; i &lt;= k; i++ ) s1 += R[i]; for ( j = k + 1; j &lt;= n; j++ ) s2 += R[j]; return s2 - s1; &#125; else if ( pivotpos &gt; k ) return SetPartition( R, n, low, pivotpos - 1 ); else return SetPartition( R, n, pivotpos + 1, high );&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]133.克隆图]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-133-%E5%85%8B%E9%9A%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[方法一:dfs(递归)1234567891011121314map&lt;Node*,Node*&gt; dict;Node* clone(Node* node)&#123; if (!node) return node; if (dict.count(node)) return dict[node]; dict[node]=new Node(node-&gt;val,vector&lt;Node*&gt;&#123;&#125;); // 这里不能写clone(node),会导致死循环,记住,在new的时候千万不要再递归,递归最低层一定有一个明确结果,所以要把截止条件写清楚 for(auto it:node-&gt;neighbors) dict[node]-&gt;neighbors.push_back(clone(it)); return dict[node];&#125;Node* cloneGraph(Node* node) &#123; return clone(node);&#125; 方法二:dfs(非递归)1234567891011121314151617181920212223map&lt;Node*,Node*&gt; dict;Node* cloneGraph(Node* node) &#123; stack&lt;Node*&gt; S; S.push(node); while (!S.empty()) &#123; Node *p = S.top(); S.pop(); if (!dict.count(p)) // 从栈中出来的都是没有进行访问过的点 dict[p]=new Node(p-&gt;val,vector&lt;Node*&gt;&#123;&#125;); for (auto it:p-&gt;neighbors) &#123; if (!dict.count(it)) // 判断是否已经访问过该点 &#123; dict[it]=new Node(it-&gt;val,vector&lt;Node*&gt;&#123;&#125;); S.push(it); &#125; dict[p]-&gt;neighbors.push_back(dict[it]); // 将新点的拷贝放入neighbors中 &#125; &#125; return dict[node];&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]138.复制带随机指针的链表]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[方法一:递归12345678910unordered_map&lt;Node*,Node*&gt; dict;Node* copyRandomList(Node* head) &#123; if (!head) return head; if (dict.count(head)) return dict[head]; dict[head]=new Node(head-&gt;val, nullptr, nullptr); dict[head]-&gt;next=copyRandomList(head-&gt;next); dict[head]-&gt;random=copyRandomList(head-&gt;random); return dict[head];&#125; 方法二:非递归12345678910111213141516171819Node* copyRandomList(Node* head) &#123; if (!head) return head; unordered_map&lt;Node*,Node*&gt; m; Node *p=head; while(p) // make a copy of nodes &#123; m[p]=new Node(p-&gt;val,nullptr,nullptr); p=p-&gt;next; &#125; p=head; while(p) // link everyone and fill the random field &#123; m[p]-&gt;next=m[p-&gt;next]; m[p]-&gt;random=m[p-&gt;random]; p=p-&gt;next; &#125; return m[head];&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]144.二叉树的前序遍历]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[前往二叉树的:前序,中序,后序 遍历算法 方法一:递归123456789vector&lt;int&gt; res;vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; if (!root) return res; res.push_back(root-&gt;val); if (root-&gt;left) preorderTraversal(root-&gt;left); if (root-&gt;right) preorderTraversal(root-&gt;right); return res;&#125; 方法二:非递归1234567891011121314151617181920212223vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if (!root) return res; stack&lt;TreeNode*&gt; S; TreeNode* p = root; while(p||!S.empty()) &#123; if (p) // 访问左子树 &#123; res.push_back(p-&gt;val); S.push(p); p=p-&gt;left; &#125; else // 访问右子树 &#123; p=S.top(); S.pop(); p=p-&gt;right; &#125; &#125; return res;&#125; 方法三:非递归(该方法可用于后序遍历,需要修改几处代码)12345678910111213141516vector&lt;int&gt; res;vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; if (!root) return res; stack&lt;TreeNode*&gt; S; S.push(root); while (!S.empty()) &#123; root=S.top(); S.pop(); if (root-&gt;right) S.push(root-&gt;right); // 要实现后序遍历,需要以下两行调换 if (root-&gt;left) S.push(root-&gt;left); res.push_back(root-&gt;val); // res.insert(0,root-&gt;val)即为后序遍历 &#125; return res;&#125; 结论: 方法三这种形式只适合前序和后序遍历,不适合中序遍历,中序遍历较为麻烦 方法二这种形式只适合前序和中序遍历,不适合后序遍历,后序遍历较为麻烦]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]94.二叉树的中序遍历]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[前往二叉树的:前序,中序,后序 遍历算法 方法一:递归123456789vector&lt;int&gt; res;vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; if (!root) return res; if (root-&gt;left) inorderTraversal(root-&gt;left); res.push_back(root-&gt;val); if (root-&gt;right) inorderTraversal(root-&gt;right); return res;&#125; 方法二:非递归1234567891011121314151617181920212223vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if (!root) return res; stack&lt;TreeNode*&gt; S; TreeNode* p = root; while(p||!S.empty()) &#123; if (p) &#123; S.push(p); p=p-&gt;left; &#125; else &#123; p=S.top(); S.pop(); res.push_back(p-&gt;val); p=p-&gt;right; &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]145.二叉树的后序遍历]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[前往二叉树的:前序,中序,后序 遍历算法 方法一:递归123456789vector&lt;int&gt; res;vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; if (!root) return res; if (root-&gt;left) postorderTraversal(root-&gt;left); if (root-&gt;right) postorderTraversal(root-&gt;right); res.push_back(root-&gt;val); return res;&#125; 方法二:非递归1234567891011121314151617181920212223242526272829vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if (!root) return res; stack&lt;TreeNode*&gt; S; TreeNode* p=root, *r=nullptr; while (p||!S.empty()) &#123; if (p) &#123; S.push(p); p=p-&gt;left; &#125; else &#123; p=S.top(); if (p-&gt;right&amp;&amp;p-&gt;right!=r) p=p-&gt;right; else &#123; S.pop(); res.push_back(p-&gt;val); r=p; p=nullptr; &#125; &#125; &#125; return res; &#125; 方法三:非递归1234567891011121314151617vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if (!root) return res; stack&lt;TreeNode*&gt; S; TreeNode* p=root; S.push(p); while (!S.empty()) &#123; p=S.top(); S.pop(); if (p-&gt;left) S.push(p-&gt;left); if (p-&gt;right) S.push(p-&gt;right); res.insert(res.begin(),p-&gt;val); &#125; return res;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]968.监控二叉树]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[解题思路: 由于叶子节点一定不要安装监视器,这样才能使总监视器数量比较少,因此需要从下往上进行判断当前节点的状态(共:3种状态): 0: 当前节点安装了监视器 1: 当前节点可观,但没有安装监视器 2: 当前节点不可观对于空节点,我们认为是可观,但没有安装监视器,因此,叶子节点就为不可观的了,设想一个节点的左右孩子(为空)都可观且没有安装监视器,那该节点必然是不可观即2 有了以上对空节点和叶子节点的处理,我们再来正式分析非终端节点: 若一个节点的左孩子或右孩子不可观,那么该节点必然不可观,需要安装监视器,因此返回0状态 若一个节点的左孩子或右孩子都可观且至少有一个安装了监视器,那么该节点必然是可观的,返回1状态 若一个节点的左右孩子都可观且没安装监视器,那么该节点必然是不可观的,返回2状态记住,我们以上的分析都是基于从整个二叉树的叶子节点往根部,即从下往上进行,而且要做的就是将不可观的节点变得可观才行(因此要根据左右孩子的节点的状态来判断当前节点状态并做出调整) 这里可能会有疑惑,以上的第一条得出当前节点不可观,然后安装了监视器,而第三条也得出当前节点不可观,但却没有安装监视器,而是直接返回的2状态(当前节点不可观).这是为什么? 因为,对于第一条,因为左右孩子都不可观,为了让左右孩子都可观,则必须给当前节点安装监视器才行,而第三条中,左右孩子都是可观的(没有安装监视器),当前节点的可以直接返回不可观状态,因为后面可以由他的父节点进行摄像头安装,使其变得可观. 方法一:递归12345678910111213141516171819202122232425// 0：该节点安装了监视器 1：该节点可观，但没有安装监视器 2：该节点不可观int monitor = 0;int state(TreeNode* node)&#123; if (node == nullptr) return 1; int left = state(node-&gt;left); int right = state(node-&gt;right); // 该节点为0的情况 if (left == 2 || right == 2) &#123; monitor++; // 由于左或右节点不可观,则需要给当前节点安装监视器,为0状态 return 0; &#125; // 为1的情况 else if (left == 0 || right == 0) return 1; // 当(left!=2&amp;&amp;right!=2)时,才会进行该判断,也就是左右节点一定是可观的,再判断是否有一个安装了监视器,如有安装,则当前节点就不需要安装监视器也可观了,为1状态 // 为2的情况 else // 其他:党(left!=2&amp;&amp;right!=2)&amp;&amp;(left!=0&amp;&amp;right!=0),即left==1&amp;&amp;right==1时,左右节点都可观,但没有监视器,当前节点不可观,为2状态 return 2;&#125;int minCameraCover(TreeNode *root)&#123; if (root == nullptr) return 0; if (state(root) == 2) monitor++; // 如果根节点为2的状态,需要加一个监视器 return monitor;&#125; 注意:这里的if,else if,else的顺序是不能变的,先判断左右都是不可观的,再就是都可观,左或右至少有一个为监视器,最后才是都可观都无监视器.]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]106.从中序与后序遍历序列构造二叉树]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[前往 中序,后序遍历构造二叉树, 中序,前序遍历构造二叉树12345678910111213141516TreeNode* build(vector&lt;int&gt;&amp; inorder, int l1, int r1, vector&lt;int&gt;&amp;postorder, int l2, int r2)&#123; if (l1&gt;r1) return nullptr; int x = postorder[r2], i = 0; // 确定当前根节点 for (i = l1; i &lt;= r1 &amp;&amp; inorder[i] != x; ++i); // 在中序遍历序列中找到当前根节点位置(该位置可以划分出左右两个分支) int llen = i - l1; // 左子树结点数量 int rlen = r1 - i; // 右子树结点数量 TreeNode* p = new TreeNode(x); // 建立根节点 p-&gt;left = build(inorder, l1, l1 + llen - 1, postorder, l2, l2 + llen - 1); // 递归建立左子树,-1,-1是把当前根节点位置去掉 p-&gt;right = build(inorder, r1 - rlen + 1, r1, postorder, r2 - rlen, r2 - 1); // 递归建立右子树,+1,-1是把当前根节点位置去掉 return p;&#125;TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; if (inorder.empty()||postorder.empty()) return nullptr; return build(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1);&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]105.从前序与中序遍历序列构造二叉树]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[前往 中序,后序遍历构造二叉树, 中序,前序遍历构造二叉树12345678910111213141516TreeNode* build(vector&lt;int&gt;&amp; preorder, int l1, int r1, vector&lt;int&gt;&amp; inorder, int l2, int r2)&#123; if (l1&gt;r1) return nullptr; int x=preorder[l1], i=0; // 确定当前根节点 for(i=l2;inorder[i]!=x&amp;&amp;i&lt;r2;++i); // 在中序遍历序列中找到当前根节点位置(该位置可以划分出左右两个分支) int llen=i-l2; // 左子树结点数量 int rlen=r2-i; // 右子树结点数量 TreeNode *p = new TreeNode(x); // 建立根节点 p-&gt;left = build(preorder, l1+1, l1+llen, inorder, l2, l2+llen-1); // 递归建立左子树,+1,-1是把当前根节点位置去掉 p-&gt;right= build(preorder, r1-rlen+1, r1, inorder, r2-rlen+1, r2); // 递归建立右子树,+1,+1是把当前根节点位置去掉 return p;&#125;TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; return build(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1);&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]114.二叉树展开为链表]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[思路:递归,将左子树变成单链表形式,再将右子树变成单链表形式,最后将左子树单链表的末端连接到右子树单链表表头,将根节点的左孩子置空 方法一: 递归1234567891011121314void flatten(TreeNode* root) &#123; if (root==nullptr) return; flatten(root-&gt;left); // 将左子树变成单链表形式 flatten(root-&gt;right); // 将右子树变成单链表形式 if (root-&gt;left) // 将左子树单链表的末端连接到右子树单链表表头 &#123; TreeNode* p=root-&gt;left; while(p-&gt;right) p=p-&gt;right; p-&gt;right=root-&gt;right; root-&gt;right=root-&gt;left; root-&gt;left=nullptr; &#125;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]239.滑动窗口最大值]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[思路:滑动窗口的思想,只要是求连续子序列或者子串问题,都可用滑动窗口的思想 方法一: 滑动窗口123456789101112131415161718vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; res; if (nums.size()==0) return res; int i=0; deque&lt;int&gt; dq; for (i=0;i&lt;nums.size();++i) &#123; while(!dq.empty()&amp;&amp;nums[i]&gt;nums[dq.back()]) //在尾部添加元素，并保证左边元素都比尾部大 dq.pop_back(); dq.push_back(i); if (i-k==dq.front()) //在头部移除元素 dq.pop_front(); if (i&gt;=k-1) res.push_back(nums[dq.front()]); // 存放每次窗口内的最大值 &#125; return res;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]76.最小覆盖子串]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[思路:滑动窗口思想 方法一:滑动窗口1234567891011121314151617181920212223242526272829303132333435363738string minWindow(string s, string t) &#123; // 1.tdict记录T中每个字母与字母个数 // 2.维护一个滑动窗口字母的计数表sdict,计数当前窗口内T中字母出现的次数 // 3.当窗口内T中字母出现的次数大于等于T中每个字母出现的次数一样,这时第一个最短子串出现,再逐步从左边缩短窗口,直到不满足上述条件,然后再从右边扩大窗口,直到满足条件时,再进行最短子串长度对比,一直更新最短长度子串直到结束 if (s.size()&lt;t.size()||s.size()==0) return ""; unordered_map&lt;char,int&gt; tdict,sdict; int l=0,r=0,k=t.size(); for(auto it:t) // 填充T的字母与字母计数表 &#123; if (!tdict.count(it)) tdict[it]=1; else tdict[it]++; &#125; string res=""; for(r=0;r&lt;s.size();++r) &#123; if (tdict.count(s[r])) // 有字符,则进行记录 &#123; if (!sdict.count(s[r])) sdict[s[r]]=0; sdict[s[r]]++; if (sdict[s[r]]&lt;=tdict[s[r]]) k--; &#125; while(k==0) // 满足条件,滑动窗口从左边逐步缩短,直到剔除第一个属于T中的字符为止 &#123; if (res.empty()||r-l+1&lt;res.size()) // 最短子串更新 res=s.substr(l,r-l+1); if(tdict.count(s[l])) &#123; sdict[s[l]]--; if (sdict[s[l]]&lt;tdict[s[l]]) k++; &#125; l++; &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]3.无重复字符的最长子串]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[思路:滑动窗口的思想 方法一:滑动窗口123456789101112131415161718192021int lengthOfLongestSubstring(string s) &#123; /* 控制一个滑动窗口,窗口内的字符都是不重复的,通过set可以做到判断字符是否重复 */ unordered_set&lt;char&gt; set; size_t maxL=0; for(int l=0,r=0;r&lt;s.size();++r) &#123; if (!set.count(s[r])) // 当前判断的元素不存在于滑动窗口[l,r-1]中 set.insert(s[r]); // 将元素放入滑动窗口(即记录不重复字符) else // 当前判断的元素已经存在于滑动窗口[l,r-1]中 &#123; while(set.count(s[r])) // 从左缩短窗口,直到剔除当前判断的元素为止 set.erase(s[l++]); set.insert(s[r]); // 将当前判断元素放入到滑动窗口中 &#125; maxL=max(maxL,set.size()); // 更新无重复字符的最长子串 &#125; return maxL;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]1028.从先序遍历还原二叉树]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-1028-%E4%BB%8E%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[思路:用一个栈来管理树的层次关系,索引代表节点的深度 方法一:123456789101112131415161718192021222324252627TreeNode* recoverFromPreorder(string S) &#123; /* 由题意知,最上层节点深度为0(数字前面0条横线),而第二层节点前有1条横线,表示深度为1 树的前序遍历: 根-左-右 因此, */ if (S.empty()) return nullptr; vector&lt;TreeNode*&gt; stack; // 结果栈 for(int i=0,depth=0,val=0;i&lt;S.size();) &#123; for(depth=0;i&lt;S.size()&amp;&amp;S[i]=='-';++i) // 计算节点的深度 depth++; for(val=0;i&lt;S.size()&amp;&amp;S[i]!='-';++i) // 计算数值 val=val*10+S[i]-'0'; while (stack.size()&gt;depth) // 若当前栈的长度(树的高度)大于节点的深度,则可以把栈中最后几个节点pop掉(这些节点各已经成为完整的子树,可以pop掉了) stack.pop_back(); TreeNode* node=new TreeNode(val); // 新建节点用于存放当前深度的结点 if (!stack.empty()) // 节点间关联 &#123; if (!stack.back()-&gt;left) stack.back()-&gt;left=node; else if(!stack.back()-&gt;right) stack.back()-&gt;right=node; &#125; stack.push_back(node); &#125; return stack[0];&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]5040.边框着色]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-5040-%E8%BE%B9%E6%A1%86%E7%9D%80%E8%89%B2%2F</url>
    <content type="text"><![CDATA[方法一：dfs的非递归形式1234567891011121314151617181920212223242526272829using ll=long long;const ll MAXN=50LL;unordered_set&lt;ll&gt; vis,mark;vector&lt;vector&lt;int&gt;&gt; colorBorder(vector&lt;vector&lt;int&gt;&gt;&amp; G, int r0, int c0, int color) &#123; queue&lt;ll&gt; Q; Q.push(r0*MAXN+c0); int c=G[r0][c0]; int dx[]=&#123;-1,1,0,0&#125;,dy[]=&#123;0,0,-1,1&#125;; while (!Q.empty()) &#123; int x=Q.front()/MAXN; int y=Q.front()%MAXN; Q.pop(); vis.insert(x*MAXN+y); if (x==0||x==G.size()-1||y==0||y==G[0].size()-1) // 边界方块可变色 mark.insert(x*MAXN+y); else if (G[x-1][y]!=c||G[x+1][y]!=c||G[x][y-1]!=c||G[x][y+1]!=c) // 四个方向中,任意一个方块颜色不同,则可变色 mark.insert(x*MAXN+y); for (int d=0;d&lt;4;d++) // 放入连通分量的所有方块 &#123; int nx=x+dx[d],ny=y+dy[d]; if (0&lt;=nx&amp;&amp;nx&lt;G.size()&amp;&amp;0&lt;=ny&amp;&amp;ny&lt;G[0].size()&amp;&amp;!vis.count(nx*MAXN+ny)&amp;&amp;G[nx][ny]==c) Q.push(nx*MAXN+ny); &#125; &#125; for (auto it:mark) G[it/MAXN][it%MAXN]=color; return G;&#125; 思路:用vis记录访问过的方块,mark标记连通分量中需要修改颜色的方块,并非连通分量中所有的方块都要修改颜色,比如:一个方块如果四周(四个方向邻接的)都是相同颜色,那么只需要修改四周方块的颜色,而自己颜色不变(开始的时候没理解题意,以为只要是连通分量内的方块颜色都需要改变) 方法二: dfs递归形式,只不过把上面的非递归改为递归了123456789101112131415161718192021222324using ll=long long;const ll MAXN=50LL;unordered_set&lt;ll&gt; vis,mark;void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; G, int x, int y, int c)&#123; int dx[]=&#123;-1,1,0,0&#125;,dy[]=&#123;0,0,-1,1&#125;; vis.insert(x*MAXN+y); if (x==0||x==G.size()-1||y==0||y==G[0].size()-1) // 边界方块可变色 mark.insert(x*MAXN+y); else if (G[x-1][y]!=c||G[x+1][y]!=c||G[x][y-1]!=c||G[x][y+1]!=c) // 四个方向中,任意一个方块颜色不同,则可变色 mark.insert(x*MAXN+y); for (int d=0;d&lt;4;d++) // 放入连通分量的所有方块 &#123; int nx=x+dx[d],ny=y+dy[d]; if (0&lt;=nx&amp;&amp;nx&lt;G.size()&amp;&amp;0&lt;=ny&amp;&amp;ny&lt;G[0].size()&amp;&amp;!vis.count(nx*MAXN+ny)&amp;&amp;G[nx][ny]==c) dfs(G,nx,ny,c); &#125;&#125;vector&lt;vector&lt;int&gt;&gt; colorBorder(vector&lt;vector&lt;int&gt;&gt;&amp; G, int r0, int c0, int color) &#123; dfs(G,r0,c0,G[r0][c0]); for (auto it:mark) G[it/MAXN][it%MAXN]=color; return G;&#125; 方法三:dfs递归,但通过修改G中的数据,来记录是否访问过,和是否需要修改颜色,国外的一个大佬写的From an initial point, perform DFS and flip the cell color to negative to track visited cells.After DFS is complete for the cell, check if this cell is inside. If so, flip its color back to the positive.In the end, cells with the negative color are on the border. Change their color to the target color.1234567891011121314void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; g, int r, int c, int cl) &#123; if (r &lt; 0 || c &lt; 0 || r &gt;= g.size() || c &gt;= g[r].size() || g[r][c] != cl) return; // 剪枝(越界,非着色块) g[r][c] = -cl; // 着色 dfs(g, r - 1, c, cl), dfs(g, r + 1, c, cl), dfs(g, r, c - 1, cl), dfs(g, r, c + 1, cl); if (r &gt; 0 &amp;&amp; r &lt; g.size() - 1 &amp;&amp; c &gt; 0 &amp;&amp; c &lt; g[r].size() - 1 &amp;&amp; cl == abs(g[r - 1][c]) &amp;&amp; cl == abs(g[r + 1][c]) &amp;&amp; cl == abs(g[r][c - 1]) &amp;&amp; cl == abs(g[r][c + 1])) // 将原四周同色的块,颜色还原 g[r][c] = cl;&#125;vector&lt;vector&lt;int&gt;&gt; colorBorder(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int r0, int c0, int color) &#123; dfs(grid, r0, c0, grid[r0][c0]); for (auto i = 0; i &lt; grid.size(); ++i) // 根据dfs标记(负数)过的方块进行着色 for (auto j = 0; j &lt; grid[i].size(); ++j) grid[i][j] = grid[i][j] &lt; 0 ? color : grid[i][j]; return grid;&#125; 结论: 无论是递归还是非递归,先标记(标记vis),再遍历]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]5.最长回文子串]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[方法一:中心扩展算法解题思路:从左到右每一个字符都作为中心轴,然后逐渐往两边扩展,只要发现有不相等的字符,则确定了以该字符为轴的最长回文串,但需要考虑长度为奇数和偶数的不同情况的处理(长度为偶数时轴心为中间两个数的中心,长度为奇数时轴心为中间那个数) 算法时间复杂度: $O(n^{2})$12345678910111213141516171819202122232425262728string longestPalindrome(string s) &#123; int idx = 0, maxL = 0; for (int i = 0; i &lt; s.size(); ++i) // i为轴的位置,j为回文串半径 &#123; for (int j = 0; i - j &gt;= 0 &amp;&amp; i + j &lt; s.size(); ++j) // 奇数 &#123; if (s[i - j] != s[i + j]) break; if (2 * j + 1 &gt; maxL) &#123; maxL = 2 * j + 1; idx = i - j; &#125; &#125; for (int j = 0; i - j &gt;= 0 &amp;&amp; i + j + 1 &lt; s.size(); ++j) // 偶数 &#123; if (s[i-j]!=s[i+j+1]) break; if (2 * j + 2 &gt; maxL) &#123; maxL = 2 * j + 2; idx = i - j; &#125; &#125; &#125; return s.substr(idx, maxL);&#125; 方法二: manacher(马拉车法)解题思路:详见P3805【模板】manacher算法为了使奇数串和偶数串一致性处理,首先进行字符填充,使其成为奇数串,即在每个字符的前后填充字符,例如:原串: ABCCBA填充后: ~#A#B#C#C#B#A#原始串在数组中的位置: A B C C B A 0 1 2 3 4 5 填充串在数组中的位置 ~ # A # B # C # C # B # A # 0 1 2 3 4 5 6 7 8 9 10 11 12 13 首先说明: 奇数+偶数=奇数, 因此,奇数串填充偶数个#后为奇数串,偶数串填充奇数个#后为奇数串 ~字符用来作为边界,用处在于进行两边扩展时做为结束条件 填充串中字符的最大回文半径 - 1 = 原字符串中该字符的回文串长度 关于上述第3条我需要解释一下: s_copy ~ # A # B # C # C # B # A # index 0 1 2 3 4 5 6 7 8 9 10 11 12 13 pos 0 0 0 0 1 1 2 2 3 3 4 4 5 5 p 0 1 2 1 2 1 2 7 2 1 2 1 2 1 可以看到index=7的位置,#对应的p为7(即最大回文半径),即在C与C之间,表示原字符串中该字符的回文长度为6,那么原字符串ABCCBA的前面3个字符ABC构成的回文串长度为6 该题思路: 字符串填充统一为奇数串 Manacher法,从左到右遍历每个字符 记录每个字符的最大回文半径 确定已经记录的最大回文串右边界r,和中间轴m 当前字符s[i]是否能关于m找到一个对称点,即要满足:m&lt;=i&lt;=r 能:则得到一个有可能的最大回文半径,并从该半径开始扩展 否:则从新计算最大回文半径 算法时间复杂度为: $O(n)$1234567891011121314151617181920212223242526272829303132333435363738394041int pos[2005],p[2005]; // pos用于记录填充串与原始字串的位置关系,p用于记录填充串当前字符的最大回文半径string longestPalindrome(string s) &#123; /* 填充字符,统一为奇数串 */ string s_new="~"; for (int i=0,k=1;i&lt;s.size();++i) &#123; s_new+="#"; s_new+=s[i]; pos[k++]=i; pos[k++]=i; &#125; s_new+="#"; /* manacher */ int m=0,r=0,maxL=0,idx=0; for (int i=1;i&lt;s_new.size();++i) &#123; // 获取已知的最大回文半径,p[i]用于记录填充串对应字符的最大回文半径 if (i&lt;r) p[i]=min(p[2*m-i],r-i); // 当m&lt;=i&lt;=r时,i关于m中心轴对称的点为2*m-i,而p[2*m-i]是一定已经知道的 else p[i]=1; // 如果i超出了已知的最大回文右边界,则比如不能找到关于m对称的点,只能重新计算最大回文半径 // 暴力拓展左右两侧,计算当前的最大回文半径 while (s_new[i-p[i]]==s_new[i+p[i]]) p[i]++; // 新的回文半径比较大,则更新 if (r-i&lt;p[i]) &#123; m=i; r=i+p[i]; &#125; // 更新回文长度(原始字串的回文长度为新字串回文半径-1) if (p[i]-1&gt;=maxL) &#123; maxL=p[i]-1; idx=pos[i]-maxL/2; // 更新原始回文字串的起始位置 &#125; &#125; return s.substr(idx,maxL);&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回文串</tag>
      </tags>
  </entry>
</search>
