<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[leetcode]133.克隆图]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-133-%E5%85%8B%E9%9A%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[方法一:dfs(递归)1234567891011121314map&lt;Node*,Node*&gt; dict;Node* clone(Node* node)&#123; if (!node) return node; if (dict.count(node)) return dict[node]; dict[node]=new Node(node-&gt;val,vector&lt;Node*&gt;&#123;&#125;); // 这里不能写clone(node),会导致死循环,记住,在new的时候千万不要再递归,递归最低层一定有一个明确结果,所以要把截止条件写清楚 for(auto it:node-&gt;neighbors) dict[node]-&gt;neighbors.push_back(clone(it)); return dict[node];&#125;Node* cloneGraph(Node* node) &#123; return clone(node);&#125; 方法二:dfs(非递归)1234567891011121314151617181920212223map&lt;Node*,Node*&gt; dict;Node* cloneGraph(Node* node) &#123; stack&lt;Node*&gt; S; S.push(node); while (!S.empty()) &#123; Node *p = S.top(); S.pop(); if (!dict.count(p)) // 从栈中出来的都是没有进行访问过的点 dict[p]=new Node(p-&gt;val,vector&lt;Node*&gt;&#123;&#125;); for (auto it:p-&gt;neighbors) &#123; if (!dict.count(it)) // 判断是否已经访问过该点 &#123; dict[it]=new Node(it-&gt;val,vector&lt;Node*&gt;&#123;&#125;); S.push(it); &#125; dict[p]-&gt;neighbors.push_back(dict[it]); // 将新点的拷贝放入neighbors中 &#125; &#125; return dict[node];&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]138.复制带随机指针的链表]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[方法一:递归12345678910unordered_map&lt;Node*,Node*&gt; dict;Node* copyRandomList(Node* head) &#123; if (!head) return head; if (dict.count(head)) return dict[head]; dict[head]=new Node(head-&gt;val, nullptr, nullptr); dict[head]-&gt;next=copyRandomList(head-&gt;next); dict[head]-&gt;random=copyRandomList(head-&gt;random); return dict[head];&#125; 方法二:非递归12345678910111213141516171819Node* copyRandomList(Node* head) &#123; if (!head) return head; unordered_map&lt;Node*,Node*&gt; m; Node *p=head; while(p) // make a copy of nodes &#123; m[p]=new Node(p-&gt;val,nullptr,nullptr); p=p-&gt;next; &#125; p=head; while(p) // link everyone and fill the random field &#123; m[p]-&gt;next=m[p-&gt;next]; m[p]-&gt;random=m[p-&gt;random]; p=p-&gt;next; &#125; return m[head];&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]144.二叉树的前序遍历]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[前往二叉树的:前序,中序,后序 遍历算法 方法一:递归123456789vector&lt;int&gt; res;vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; if (!root) return res; res.push_back(root-&gt;val); if (root-&gt;left) preorderTraversal(root-&gt;left); if (root-&gt;right) preorderTraversal(root-&gt;right); return res;&#125; 方法二:非递归1234567891011121314151617181920212223vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if (!root) return res; stack&lt;TreeNode*&gt; S; TreeNode* p = root; while(p||!S.empty()) &#123; if (p) // 访问左子树 &#123; res.push_back(p-&gt;val); S.push(p); p=p-&gt;left; &#125; else // 访问右子树 &#123; p=S.top(); S.pop(); p=p-&gt;right; &#125; &#125; return res;&#125; 方法三:非递归(该方法可用于后序遍历,需要修改几处代码)12345678910111213141516vector&lt;int&gt; res;vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; if (!root) return res; stack&lt;TreeNode*&gt; S; S.push(root); while (!S.empty()) &#123; root=S.top(); S.pop(); if (root-&gt;right) S.push(root-&gt;right); // 要实现后序遍历,需要以下两行调换 if (root-&gt;left) S.push(root-&gt;left); res.push_back(root-&gt;val); // res.insert(0,root-&gt;val)即为后序遍历 &#125; return res;&#125; 结论: 方法三这种形式只适合前序和后序遍历,不适合中序遍历,中序遍历较为麻烦 方法二这种形式只适合前序和中序遍历,不适合后序遍历,后序遍历较为麻烦]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]94.二叉树的中序遍历]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[前往二叉树的:前序,中序,后序 遍历算法 方法一:递归123456789vector&lt;int&gt; res;vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; if (!root) return res; if (root-&gt;left) inorderTraversal(root-&gt;left); res.push_back(root-&gt;val); if (root-&gt;right) inorderTraversal(root-&gt;right); return res;&#125; 方法二:非递归1234567891011121314151617181920212223vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if (!root) return res; stack&lt;TreeNode*&gt; S; TreeNode* p = root; while(p||!S.empty()) &#123; if (p) &#123; S.push(p); p=p-&gt;left; &#125; else &#123; p=S.top(); S.pop(); res.push_back(p-&gt;val); p=p-&gt;right; &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]145.二叉树的后序遍历]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[前往二叉树的:前序,中序,后序 遍历算法 方法一:递归123456789vector&lt;int&gt; res;vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; if (!root) return res; if (root-&gt;left) postorderTraversal(root-&gt;left); if (root-&gt;right) postorderTraversal(root-&gt;right); res.push_back(root-&gt;val); return res;&#125; 方法二:非递归1234567891011121314151617181920212223242526272829vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if (!root) return res; stack&lt;TreeNode*&gt; S; TreeNode* p=root, *r=nullptr; while (p||!S.empty()) &#123; if (p) &#123; S.push(p); p=p-&gt;left; &#125; else &#123; p=S.top(); if (p-&gt;right&amp;&amp;p-&gt;right!=r) p=p-&gt;right; else &#123; S.pop(); res.push_back(p-&gt;val); r=p; p=nullptr; &#125; &#125; &#125; return res; &#125; 方法三:非递归1234567891011121314151617vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if (!root) return res; stack&lt;TreeNode*&gt; S; TreeNode* p=root; S.push(p); while (!S.empty()) &#123; p=S.top(); S.pop(); if (p-&gt;left) S.push(p-&gt;left); if (p-&gt;right) S.push(p-&gt;right); res.insert(res.begin(),p-&gt;val); &#125; return res;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]968.监控二叉树]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[解题思路: 由于叶子节点一定不要安装监视器,这样才能使总监视器数量比较少,因此需要从下往上进行判断当前节点的状态(共:3种状态): 0: 当前节点安装了监视器 1: 当前节点可观,但没有安装监视器 2: 当前节点不可观对于空节点,我们认为是可观,但没有安装监视器,因此,叶子节点就为不可观的了,设想一个节点的左右孩子(为空)都可观且没有安装监视器,那该节点必然是不可观即2 有了以上对空节点和叶子节点的处理,我们再来正式分析非终端节点: 若一个节点的左孩子或右孩子不可观,那么该节点必然不可观,需要安装监视器,因此返回0状态 若一个节点的左孩子或右孩子都可观且至少有一个安装了监视器,那么该节点必然是可观的,返回1状态 若一个节点的左右孩子都可观且没安装监视器,那么该节点必然是不可观的,返回2状态记住,我们以上的分析都是基于从整个二叉树的叶子节点往根部,即从下往上进行,而且要做的就是将不可观的节点变得可观才行(因此要根据左右孩子的节点的状态来判断当前节点状态并做出调整) 这里可能会有疑惑,以上的第一条得出当前节点不可观,然后安装了监视器,而第三条也得出当前节点不可观,但却没有安装监视器,而是直接返回的2状态(当前节点不可观).这是为什么? 因为,对于第一条,因为左右孩子都不可观,为了让左右孩子都可观,则必须给当前节点安装监视器才行,而第三条中,左右孩子都是可观的(没有安装监视器),当前节点的可以直接返回不可观状态,因为后面可以由他的父节点进行摄像头安装,使其变得可观. 方法一:递归12345678910111213141516171819202122232425// 0：该节点安装了监视器 1：该节点可观，但没有安装监视器 2：该节点不可观int monitor = 0;int state(TreeNode* node)&#123; if (node == nullptr) return 1; int left = state(node-&gt;left); int right = state(node-&gt;right); // 该节点为0的情况 if (left == 2 || right == 2) &#123; monitor++; // 由于左或右节点不可观,则需要给当前节点安装监视器,为0状态 return 0; &#125; // 为1的情况 else if (left == 0 || right == 0) return 1; // 当(left!=2&amp;&amp;right!=2)时,才会进行该判断,也就是左右节点一定是可观的,再判断是否有一个安装了监视器,如有安装,则当前节点就不需要安装监视器也可观了,为1状态 // 为2的情况 else // 其他:党(left!=2&amp;&amp;right!=2)&amp;&amp;(left!=0&amp;&amp;right!=0),即left==1&amp;&amp;right==1时,左右节点都可观,但没有监视器,当前节点不可观,为2状态 return 2;&#125;int minCameraCover(TreeNode *root)&#123; if (root == nullptr) return 0; if (state(root) == 2) monitor++; // 如果根节点为2的状态,需要加一个监视器 return monitor;&#125; 注意:这里的if,else if,else的顺序是不能变的,先判断左右都是不可观的,再就是都可观,左或右至少有一个为监视器,最后才是都可观都无监视器.]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]106.从中序与后序遍历序列构造二叉树]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[前往 中序,后序遍历构造二叉树, 中序,前序遍历构造二叉树12345678910111213141516TreeNode* build(vector&lt;int&gt;&amp; inorder, int l1, int r1, vector&lt;int&gt;&amp;postorder, int l2, int r2)&#123; if (l1&gt;r1) return nullptr; int x = postorder[r2], i = 0; // 确定当前根节点 for (i = l1; i &lt;= r1 &amp;&amp; inorder[i] != x; ++i); // 在中序遍历序列中找到当前根节点位置(该位置可以划分出左右两个分支) int llen = i - l1; // 左子树结点数量 int rlen = r1 - i; // 右子树结点数量 TreeNode* p = new TreeNode(x); // 建立根节点 p-&gt;left = build(inorder, l1, l1 + llen - 1, postorder, l2, l2 + llen - 1); // 递归建立左子树,-1,-1是把当前根节点位置去掉 p-&gt;right = build(inorder, r1 - rlen + 1, r1, postorder, r2 - rlen, r2 - 1); // 递归建立右子树,+1,-1是把当前根节点位置去掉 return p;&#125;TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; if (inorder.empty()||postorder.empty()) return nullptr; return build(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1);&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]105.从前序与中序遍历序列构造二叉树]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[前往 中序,后序遍历构造二叉树, 中序,前序遍历构造二叉树12345678910111213141516TreeNode* build(vector&lt;int&gt;&amp; preorder, int l1, int r1, vector&lt;int&gt;&amp; inorder, int l2, int r2)&#123; if (l1&gt;r1) return nullptr; int x=preorder[l1], i=0; // 确定当前根节点 for(i=l2;inorder[i]!=x&amp;&amp;i&lt;r2;++i); // 在中序遍历序列中找到当前根节点位置(该位置可以划分出左右两个分支) int llen=i-l2; // 左子树结点数量 int rlen=r2-i; // 右子树结点数量 TreeNode *p = new TreeNode(x); // 建立根节点 p-&gt;left = build(preorder, l1+1, l1+llen, inorder, l2, l2+llen-1); // 递归建立左子树,+1,-1是把当前根节点位置去掉 p-&gt;right= build(preorder, r1-rlen+1, r1, inorder, r2-rlen+1, r2); // 递归建立右子树,+1,+1是把当前根节点位置去掉 return p;&#125;TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; return build(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1);&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]114.二叉树展开为链表]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[思路:递归,将左子树变成单链表形式,再将右子树变成单链表形式,最后将左子树单链表的末端连接到右子树单链表表头,将根节点的左孩子置空 方法一: 递归1234567891011121314void flatten(TreeNode* root) &#123; if (root==nullptr) return; flatten(root-&gt;left); // 将左子树变成单链表形式 flatten(root-&gt;right); // 将右子树变成单链表形式 if (root-&gt;left) // 将左子树单链表的末端连接到右子树单链表表头 &#123; TreeNode* p=root-&gt;left; while(p-&gt;right) p=p-&gt;right; p-&gt;right=root-&gt;right; root-&gt;right=root-&gt;left; root-&gt;left=nullptr; &#125;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]239.滑动窗口最大值]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[思路:滑动窗口的思想,只要是求连续子序列或者子串问题,都可用滑动窗口的思想 方法一: 滑动窗口123456789101112131415161718vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; res; if (nums.size()==0) return res; int i=0; deque&lt;int&gt; dq; for (i=0;i&lt;nums.size();++i) &#123; while(!dq.empty()&amp;&amp;nums[i]&gt;nums[dq.back()]) //在尾部添加元素，并保证左边元素都比尾部大 dq.pop_back(); dq.push_back(i); if (i-k==dq.front()) //在头部移除元素 dq.pop_front(); if (i&gt;=k-1) res.push_back(nums[dq.front()]); // 存放每次窗口内的最大值 &#125; return res;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]76.最小覆盖子串]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[思路:滑动窗口思想 方法一:滑动窗口1234567891011121314151617181920212223242526272829303132333435363738string minWindow(string s, string t) &#123; // 1.tdict记录T中每个字母与字母个数 // 2.维护一个滑动窗口字母的计数表sdict,计数当前窗口内T中字母出现的次数 // 3.当窗口内T中字母出现的次数大于等于T中每个字母出现的次数一样,这时第一个最短子串出现,再逐步从左边缩短窗口,直到不满足上述条件,然后再从右边扩大窗口,直到满足条件时,再进行最短子串长度对比,一直更新最短长度子串直到结束 if (s.size()&lt;t.size()||s.size()==0) return ""; unordered_map&lt;char,int&gt; tdict,sdict; int l=0,r=0,k=t.size(); for(auto it:t) // 填充T的字母与字母计数表 &#123; if (!tdict.count(it)) tdict[it]=1; else tdict[it]++; &#125; string res=""; for(r=0;r&lt;s.size();++r) &#123; if (tdict.count(s[r])) // 有字符,则进行记录 &#123; if (!sdict.count(s[r])) sdict[s[r]]=0; sdict[s[r]]++; if (sdict[s[r]]&lt;=tdict[s[r]]) k--; &#125; while(k==0) // 满足条件,滑动窗口从左边逐步缩短,直到剔除第一个属于T中的字符为止 &#123; if (res.empty()||r-l+1&lt;res.size()) // 最短子串更新 res=s.substr(l,r-l+1); if(tdict.count(s[l])) &#123; sdict[s[l]]--; if (sdict[s[l]]&lt;tdict[s[l]]) k++; &#125; l++; &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]3.无重复字符的最长子串]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[思路:滑动窗口的思想 方法一:滑动窗口123456789101112131415161718192021int lengthOfLongestSubstring(string s) &#123; /* 控制一个滑动窗口,窗口内的字符都是不重复的,通过set可以做到判断字符是否重复 */ unordered_set&lt;char&gt; set; size_t maxL=0; for(int l=0,r=0;r&lt;s.size();++r) &#123; if (!set.count(s[r])) // 当前判断的元素不存在于滑动窗口[l,r-1]中 set.insert(s[r]); // 将元素放入滑动窗口(即记录不重复字符) else // 当前判断的元素已经存在于滑动窗口[l,r-1]中 &#123; while(set.count(s[r])) // 从左缩短窗口,直到剔除当前判断的元素为止 set.erase(s[l++]); set.insert(s[r]); // 将当前判断元素放入到滑动窗口中 &#125; maxL=max(maxL,set.size()); // 更新无重复字符的最长子串 &#125; return maxL;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]1028.从先序遍历还原二叉树]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-1028-%E4%BB%8E%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[思路:用一个栈来管理树的层次关系,索引代表节点的深度 方法一:123456789101112131415161718192021222324252627TreeNode* recoverFromPreorder(string S) &#123; /* 由题意知,最上层节点深度为0(数字前面0条横线),而第二层节点前有1条横线,表示深度为1 树的前序遍历: 根-左-右 因此, */ if (S.empty()) return nullptr; vector&lt;TreeNode*&gt; stack; // 结果栈 for(int i=0,depth=0,val=0;i&lt;S.size();) &#123; for(depth=0;i&lt;S.size()&amp;&amp;S[i]=='-';++i) // 计算节点的深度 depth++; for(val=0;i&lt;S.size()&amp;&amp;S[i]!='-';++i) // 计算数值 val=val*10+S[i]-'0'; while (stack.size()&gt;depth) // 若当前栈的长度(树的高度)大于节点的深度,则可以把栈中最后几个节点pop掉(这些节点各已经成为完整的子树,可以pop掉了) stack.pop_back(); TreeNode* node=new TreeNode(val); // 新建节点用于存放当前深度的结点 if (!stack.empty()) // 节点间关联 &#123; if (!stack.back()-&gt;left) stack.back()-&gt;left=node; else if(!stack.back()-&gt;right) stack.back()-&gt;right=node; &#125; stack.push_back(node); &#125; return stack[0];&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]5040.边框着色]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-5040-%E8%BE%B9%E6%A1%86%E7%9D%80%E8%89%B2%2F</url>
    <content type="text"><![CDATA[方法一：dfs的非递归形式1234567891011121314151617181920212223242526272829using ll=long long;const ll MAXN=50LL;unordered_set&lt;ll&gt; vis,mark;vector&lt;vector&lt;int&gt;&gt; colorBorder(vector&lt;vector&lt;int&gt;&gt;&amp; G, int r0, int c0, int color) &#123; queue&lt;ll&gt; Q; Q.push(r0*MAXN+c0); int c=G[r0][c0]; int dx[]=&#123;-1,1,0,0&#125;,dy[]=&#123;0,0,-1,1&#125;; while (!Q.empty()) &#123; int x=Q.front()/MAXN; int y=Q.front()%MAXN; Q.pop(); vis.insert(x*MAXN+y); if (x==0||x==G.size()-1||y==0||y==G[0].size()-1) // 边界方块可变色 mark.insert(x*MAXN+y); else if (G[x-1][y]!=c||G[x+1][y]!=c||G[x][y-1]!=c||G[x][y+1]!=c) // 四个方向中,任意一个方块颜色不同,则可变色 mark.insert(x*MAXN+y); for (int d=0;d&lt;4;d++) // 放入连通分量的所有方块 &#123; int nx=x+dx[d],ny=y+dy[d]; if (0&lt;=nx&amp;&amp;nx&lt;G.size()&amp;&amp;0&lt;=ny&amp;&amp;ny&lt;G[0].size()&amp;&amp;!vis.count(nx*MAXN+ny)&amp;&amp;G[nx][ny]==c) Q.push(nx*MAXN+ny); &#125; &#125; for (auto it:mark) G[it/MAXN][it%MAXN]=color; return G;&#125; 思路:用vis记录访问过的方块,mark标记连通分量中需要修改颜色的方块,并非连通分量中所有的方块都要修改颜色,比如:一个方块如果四周(四个方向邻接的)都是相同颜色,那么只需要修改四周方块的颜色,而自己颜色不变(开始的时候没理解题意,以为只要是连通分量内的方块颜色都需要改变) 方法二: dfs递归形式,只不过把上面的非递归改为递归了123456789101112131415161718192021222324using ll=long long;const ll MAXN=50LL;unordered_set&lt;ll&gt; vis,mark;void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; G, int x, int y, int c)&#123; int dx[]=&#123;-1,1,0,0&#125;,dy[]=&#123;0,0,-1,1&#125;; vis.insert(x*MAXN+y); if (x==0||x==G.size()-1||y==0||y==G[0].size()-1) // 边界方块可变色 mark.insert(x*MAXN+y); else if (G[x-1][y]!=c||G[x+1][y]!=c||G[x][y-1]!=c||G[x][y+1]!=c) // 四个方向中,任意一个方块颜色不同,则可变色 mark.insert(x*MAXN+y); for (int d=0;d&lt;4;d++) // 放入连通分量的所有方块 &#123; int nx=x+dx[d],ny=y+dy[d]; if (0&lt;=nx&amp;&amp;nx&lt;G.size()&amp;&amp;0&lt;=ny&amp;&amp;ny&lt;G[0].size()&amp;&amp;!vis.count(nx*MAXN+ny)&amp;&amp;G[nx][ny]==c) dfs(G,nx,ny,c); &#125;&#125;vector&lt;vector&lt;int&gt;&gt; colorBorder(vector&lt;vector&lt;int&gt;&gt;&amp; G, int r0, int c0, int color) &#123; dfs(G,r0,c0,G[r0][c0]); for (auto it:mark) G[it/MAXN][it%MAXN]=color; return G;&#125; 方法三:dfs递归,但通过修改G中的数据,来记录是否访问过,和是否需要修改颜色,国外的一个大佬写的From an initial point, perform DFS and flip the cell color to negative to track visited cells.After DFS is complete for the cell, check if this cell is inside. If so, flip its color back to the positive.In the end, cells with the negative color are on the border. Change their color to the target color.1234567891011121314void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; g, int r, int c, int cl) &#123; if (r &lt; 0 || c &lt; 0 || r &gt;= g.size() || c &gt;= g[r].size() || g[r][c] != cl) return; // 剪枝(越界,非着色块) g[r][c] = -cl; // 着色 dfs(g, r - 1, c, cl), dfs(g, r + 1, c, cl), dfs(g, r, c - 1, cl), dfs(g, r, c + 1, cl); if (r &gt; 0 &amp;&amp; r &lt; g.size() - 1 &amp;&amp; c &gt; 0 &amp;&amp; c &lt; g[r].size() - 1 &amp;&amp; cl == abs(g[r - 1][c]) &amp;&amp; cl == abs(g[r + 1][c]) &amp;&amp; cl == abs(g[r][c - 1]) &amp;&amp; cl == abs(g[r][c + 1])) // 将原四周同色的块,颜色还原 g[r][c] = cl;&#125;vector&lt;vector&lt;int&gt;&gt; colorBorder(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int r0, int c0, int color) &#123; dfs(grid, r0, c0, grid[r0][c0]); for (auto i = 0; i &lt; grid.size(); ++i) // 根据dfs标记(负数)过的方块进行着色 for (auto j = 0; j &lt; grid[i].size(); ++j) grid[i][j] = grid[i][j] &lt; 0 ? color : grid[i][j]; return grid;&#125; 结论: 无论是递归还是非递归,先标记(标记vis),再遍历]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]5.最长回文子串]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[方法一:中心扩展算法解题思路:从左到右每一个字符都作为中心轴,然后逐渐往两边扩展,只要发现有不相等的字符,则确定了以该字符为轴的最长回文串,但需要考虑长度为奇数和偶数的不同情况的处理(长度为偶数时轴心为中间两个数的中心,长度为奇数时轴心为中间那个数) 算法时间复杂度: $O(n^{2})$12345678910111213141516171819202122232425262728string longestPalindrome(string s) &#123; int idx = 0, maxL = 0; for (int i = 0; i &lt; s.size(); ++i) // i为轴的位置,j为回文串半径 &#123; for (int j = 0; i - j &gt;= 0 &amp;&amp; i + j &lt; s.size(); ++j) // 奇数 &#123; if (s[i - j] != s[i + j]) break; if (2 * j + 1 &gt; maxL) &#123; maxL = 2 * j + 1; idx = i - j; &#125; &#125; for (int j = 0; i - j &gt;= 0 &amp;&amp; i + j + 1 &lt; s.size(); ++j) // 偶数 &#123; if (s[i-j]!=s[i+j+1]) break; if (2 * j + 2 &gt; maxL) &#123; maxL = 2 * j + 2; idx = i - j; &#125; &#125; &#125; return s.substr(idx, maxL);&#125; 方法二:manacher(马拉车法)解题思路:详见P3805【模板】manacher算法算法时间复杂度为: $O(n)$1234567891011121314151617181920212223242526272829303132333435363738394041int pos[2005],p[2005];string longestPalindrome(string s) &#123; /* 填充字符,统一为奇数串 */ string s_new="~"; for (int i=0,k=1;i&lt;s.size();++i) &#123; s_new+="#"; s_new+=s[i]; pos[k++]=i; // 记录新字串与原始字串的位置关系 pos[k++]=i; &#125; s_new+="#"; /* manacher */ int m=0,r=0,maxL=0,idx=0; for (int i=1;i&lt;s_new.size();++i) &#123; // 获取已知的最小回文半径 if (i&lt;r) p[i]=min(p[2*m-i],r-i); else p[i]=1; // 暴力拓展左右两侧 while (s_new[i-p[i]]==s_new[i+p[i]]) p[i]++; // 新的回文半径比较大,则更新 if (r-i&lt;p[i]) &#123; m=i; r=i+p[i]; &#125; // 更新回文长度(原始字串的回文长度为新字串回文半径-1) if (p[i]-1&gt;maxL) &#123; maxL=p[i]-1; idx=pos[i]-maxL/2; // 更新原始回文字串的起始位置 &#125; &#125; return s.substr(idx,maxL);&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回文串</tag>
      </tags>
  </entry>
</search>
