<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[leetcode]214.最短回文串]]></title>
    <url>%2F2019%2F05%2F07%2Fleetcode-214-%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[方法一: KMP算法时间复杂度: $O(m+n)$ 解题思路: 实际就是求原串从左到右的最长回文串(必须包含左边所有字符),此处采用倒置+KMP算法来缩短匹配时间 将字符串倒置,原串作为模式串pat,倒置串作为主串txt 求出模式串pat的nextval[]值,然后进行字符串匹配,得到的模式串pat最长匹配长度即为模式串pat从第一个字符开始的最大回文串(匹配过程时间复杂度只需要$O(m+n)$) 1234567891011121314151617181920212223242526272829303132int nextval[40005];void get_nextval(string pat)&#123; int i=0,j=-1,len=pat.size(); nextval[0]=-1; for (;i&lt;len&amp;&amp;j&lt;len;) &#123; if (j==-1||pat[i]==pat[j]) &#123; i++,j++; if (pat[i]==pat[j]) nextval[i]=nextval[j]; else nextval[i]=j; &#125; else j=nextval[j]; &#125;&#125;string shortestPalindrome(string txt) &#123; string pat=txt; reverse(txt.begin(),txt.end()); // O(n) get_nextval(pat); // int i=0,j=0,lenTxt=txt.size(),lenPat=pat.size(); for(;i&lt;lenTxt&amp;&amp;j&lt;lenPat;) &#123; if (j==-1||txt[i]==pat[j]) i++,j++; else j = nextval[j]; &#125; return txt.substr(0,lenTxt-j)+pat;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回文串</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]TOC汇总]]></title>
    <url>%2F2019%2F05%2F07%2Fleetcode-TOC%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[请输入文章密码 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>TOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[algorithm]排序]]></title>
    <url>%2F2019%2F05%2F06%2Falgorithm-%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[一.排序算法1.插入排序1) 直接插入排序:(插入类)12345678910111213void InsertSort( ElemType R[], int n )&#123; for ( int i = 2; i &lt;= n; i++ ) &#123; if ( R[i].key &lt; R[i - 1].key ) &#123; R[0] = R[i]; for ( int j = i - 1; j &gt; 0 &amp;&amp; ( R[0].key &lt; R[j].key ); j-- ) R[j + 1] = R[j]; R[j + 1] = R[0]; &#125; &#125;&#125; 最好情况(顺序有序): 1)比较次数: $\sum_{i=2}^{n} 1=n-1$ 2)移动次数: 0 最坏情况(逆序有序): 1)比较次数: $\sum_{i=2}^{n} i=\frac {(n+2)(n-1)}{2}$ 2)移动次数: $\sum_{i=2}^{n} (i+1)=\frac {(n+4)(n-1)}{2}$ 2)折半插入排序:(插入类)1234567891011121314151617void BiInsertSort( ElemType R[], int n )&#123; for ( int i = 2; i &lt;= n; i++ ) &#123; R[0] = R[i]; int low = 1, high = i - 1; while ( low &lt;= high ) &#123; int mid = ( low + high ) / 2; if ( R[0].key &lt; R[m].key ) high = mid - 1; else low = mid + 1; &#125; for ( int j = i - 1; j &gt; high; j-- ) R[j + 1] = R[j]; R[j + 1] = R[0]; &#125;&#125; 3)希尔排序(又称缩小增量排序)(插入类)1234567891011121314151617// 当dk=1时,即为直接插入排序void ShellSort( ElemType R[], int n )&#123; for ( int dk = n / 2; dk &gt;= 1; dk /= 2 ) &#123; for ( int i = dk + 1; i &lt;= n; i++ ) &#123; if ( R[i].key &lt; R[i - dk].key ) &#123; R[0] = R[i]; for ( j = i - dk; j &gt; 0 &amp;&amp; ( R[0].key &lt; R[j].key ); j -= dk ) R[j + dk] = R[j]; R[j + dk] = R[0]; &#125; &#125; &#125;&#125; 2.交换排序1)起泡排序(冒泡排序)(交换类)12345678910111213141516void BubbleSort( ElemType R[], int n )&#123; for ( int i = 1; i &lt;= n - 1; i++ ) &#123; bool flag = false; for ( int j = n; j &gt; i; j-- ) &#123; if (R[j].key &lt; R[j-1].key ) &#123; swap( R[j], R[j - 1] ); flag = true; &#125; &#125; if ( !flag ) return; &#125;&#125; 2)快速排序:(交换类)12345678910111213141516171819202122232425void Partition( ElemType R[], int low, int high );// 快排void QuickSort( ElemType R[], int low, int high )&#123; if ( low &gt;= high ) return; int pivotpos = Partition( R, low, high ); QuickSort( R, low, pivotpos - 1 ); QuickSort( R, pivotpos + 1, high );&#125;// 划分void Partition( ElemType R[], int low, int high )&#123; ElemType pivot = R[low]; while ( low &lt; high ) &#123; while ( low &lt; high &amp;&amp; R[high].key &gt;= pivot.key ) high--; R[low] = R[high]; while ( low &lt; high &amp;&amp; R[low].key &lt;= pivot.key ) low++; R[high] = R[low]; &#125; R[low] = pivot; return low;&#125; 3.选择排序1)简单选择排序(选择类)123456789101112void SelectSort( ElemType R[], int n )&#123; for ( int i = 0; i &lt; n - 1; i++ ) &#123; int min = i; for ( int j = i + 1; j &lt; n; j++ ) &#123; if ( R[j].key &lt; R[min].key ) min = j; &#125; if ( min != i ) swap( R[i], R[min] ); &#125;&#125; 2)堆排序(选择类)12345678910111213141516171819202122232425262728void AdjustDown( ElemType R[], int s, int n );void HeapSort( ElemType R[], int n )&#123; for ( int i = n / 2; i &gt; 0; i-- ) void AdjustDown( R, i, n ); for ( int i = n; i &gt; 1; i-- ) &#123; swap( R[i], R[1] ); AdjustDown( R, 1, i - 1 ); &#125;&#125;// 向下调整void AdjustDown( ElemType R[], int s, int n )&#123; R[0] = R[s]; for ( int i = 2 * s; i &lt;= n; i *= 2 ) &#123; if ( i &lt; n&amp;&amp;R[i].key &lt; R[i + 1].key ) i++; if (R[0].key &gt;=R[i].key ) break; else &#123; R[s] = R[i]; s = i; &#125; &#125; R[s] = R[0];&#125; 12345678910111213// 向上调整void AdjustUp( ElemType R[], int s )&#123; R[0] = R[s]; int p = s / 2; while ( p &gt;&amp;&amp; R[p].key &lt; R[0].key ) &#123; R[s] = R[p]; s = p; p /= 2; &#125; R[s] = R[0];&#125; 4.归并排序(归并类)12345678910111213141516171819202122232425262728void Merge( ElemType R[], int low, int mid, int high );void MergeSort( ElemType R[], int low, int high )&#123; if ( low &gt;= high ) return; int mid = ( low + high ) / 2; MergeSort( R, low, mid ); MergeSort( R, mid + 1, high ); Merge( R, low, mid, high );&#125;ElemType B[MAXSIZE];void Merge( ElemType R[], int low, int mid, int high )&#123; int i,j,k; for ( i = low; i &lt;= high; i++ ) B[i] = R[i]; i = k = low, j = mid + 1; while ( i &lt;= mid &amp;&amp; j &lt;= high ) &#123; if ( B[i].key &lt;= B[j].key ) R[k++] = B[i++]; else R[k++] = B[j++]; &#125; while ( i &lt;= mid ) R[k++] = B[i++]; while ( j &lt;= high ) R[k++] = B[j++];&#125; 二.综合题(算法)1.设顺序表用数组R[]表示,表中存储在数组下标1~m+n的范围内,前m个元素递增有序,后n个元素递增有序,设计一个算法,使得整个顺序表有序12345678910111213void InsertSort( ElemType R[], int m, int n )&#123; for ( int i = m + 1; i &lt;= m + n; i++ ) &#123; if ( R[i].key &lt; R[i - 1].key ) &#123; R[0] = R[i]; for ( int j = i - 1; j &gt; 0 &amp;&amp; ( R[0].key &lt; R[j].key ); j-- ) R[j + 1] = R[j]; R[j + 1] = R[0]; &#125; &#125;&#125; 2.计数排序:对表进行排序并将结果放到另一个新的表中,要求表中所有关键码互不相同12345678910void CountSort( ElemType A[], ElemType B[], int n )&#123; for ( int i = 0; i &lt; n; i++ ) &#123; int cnt = 0; for ( int j = 0; j &lt; n; j++ ) if ( A[i].key &gt; A[j].key )cnt++; B[cnt] = A[i]; &#125;&#125; 3.双向冒泡排序1234567891011121314151617181920212223242526// 思想:第一趟通过交换把最大的放最后,第二趟通过交换把最小的放最前,反复进行void BubbleSort( ElemType A[], int n )&#123; int low = 0, high = n - 1, i; bool flag = true; while ( low &lt; high &amp;&amp; flag ) &#123; flag = false; for (i = low; i &lt; high; i++ ) &#123; if (A[i]&gt;A[i+1] ) &#123; swap( A[i], A[i + 1] ); flag = true; &#125; &#125; high--; for ( i = high; i &gt; low; i-- ) &#123; if ( A[i] &lt; A[i - 1] ) &#123; swap( A[i], A[i - 1] ); flag = true; &#125; &#125; low++; &#125;&#125; 4.单链表的简单选择排序(假设不带表头结点)123456789101112131415161718192021222324void SelectSort( LinkList&amp; L )&#123; LinkList h, p, s, pre, r; h = L; while ( h ) &#123; p = s = h; pre = r = NULL; // 找最大结点s while ( p ) &#123; if (p-&gt;data&gt;s-&gt;data ) &#123; s = p; r = pre; &#125; pre = p; p = p-&gt;next; &#125; // 脱链 if ( s == h ) h = h-&gt;next; else r-&gt;next = s-&gt;next; // 头插法 s-&gt;next = L; L = s; &#125;&#125; 5.顺序表中有n个不同整数(下标1~n),设计算法把所有奇数移动到偶数前面(时,空都最少)1234567891011121314void Move( ElemType A[], int n )&#123; int low = 1, high = n; while ( low &lt; high ) &#123; while ( low &lt; high&amp;&amp;A[low] % 2 ) low++; while ( low &lt; high &amp;&amp; A[high] % 2 == 0 ) high--; if ( low &lt; high ) &#123; swap( A[low], A[high] ); low++; high--; &#125; &#125;&#125; 6.在顺序表中找出第k小的元素(时空最少)12345678910111213141516171819202122// 思想:划分int Partition( ElemType R[], int low, int high )&#123; int pivot = R[low]; while ( low &lt; high ) &#123; while ( low &lt; high &amp;&amp; R[high].key &gt;= pivot.key ) high--; R[low] = R[high]; while ( low &lt; high&amp;&amp; R[low].key &lt;= pivot.key ) low++; R[high] = R[low]; &#125; R[low] = pivot; return low;&#125;ElemType Kth_elem( ElemType R[], int low, int high, int k )&#123; int pivotpos = Partition( R, low, high ); if ( pivotpos == k ) return R[pivotpos]; else if ( pivotpos &gt; k ) return Kth_elem( R, low, pivotpos - 1, k ); else return Kth_elem( R, pivotpos + 1, high, k );&#125; 7.n个正整数构成的集合A,将其划分为两个不相交的子集$A1,A2$,元素个数分别是n1和n2.A1和A2中元素之和分别为S1和S2.设计一个时空高效算法,使|n1-n2|最小且|s1-s1|最大.(下标从1开始)1234567891011121314151617181920212223242526272829int Partition( ElemType R[], int low, int high )&#123; int pivot = R[low]; while ( low &lt; high ) &#123; while ( low &lt; high &amp;&amp; R[high].key &gt;= pivot.key ) high--; R[low] = R[high]; while ( low &lt; high&amp;&amp; R[low].key &lt;= pivot.key ) low++; R[high] = R[low]; &#125; R[low] = pivot; return low;&#125;int SetPartition( ElemType R[], int n, int low, int high )&#123; int k = n / 2, s1, s2, i; int pivotpos = Partition( R, low, high ); if ( pivotpos == k ) &#123; s1 = s2 = 0; for ( i = 1; i &lt;= k; i++ ) s1 += R[i]; for ( j = k + 1; j &lt;= n; j++ ) s2 += R[j]; return s2 - s1; &#125; else if ( pivotpos &gt; k ) return SetPartition( R, n, low, pivotpos - 1 ); else return SetPartition( R, n, pivotpos + 1, high );&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]133.克隆图]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-133-%E5%85%8B%E9%9A%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[方法一:dfs(递归)1234567891011121314map&lt;Node*,Node*&gt; dict;Node* clone(Node* node)&#123; if (!node) return node; if (dict.count(node)) return dict[node]; dict[node]=new Node(node-&gt;val,vector&lt;Node*&gt;&#123;&#125;); // 这里不能写clone(node),会导致死循环,记住,在new的时候千万不要再递归,递归最低层一定有一个明确结果,所以要把截止条件写清楚 for(auto it:node-&gt;neighbors) dict[node]-&gt;neighbors.push_back(clone(it)); return dict[node];&#125;Node* cloneGraph(Node* node) &#123; return clone(node);&#125; 方法二:dfs(非递归)1234567891011121314151617181920212223map&lt;Node*,Node*&gt; dict;Node* cloneGraph(Node* node) &#123; stack&lt;Node*&gt; S; S.push(node); while (!S.empty()) &#123; Node *p = S.top(); S.pop(); if (!dict.count(p)) // 从栈中出来的都是没有进行访问过的点 dict[p]=new Node(p-&gt;val,vector&lt;Node*&gt;&#123;&#125;); for (auto it:p-&gt;neighbors) &#123; if (!dict.count(it)) // 判断是否已经访问过该点 &#123; dict[it]=new Node(it-&gt;val,vector&lt;Node*&gt;&#123;&#125;); S.push(it); &#125; dict[p]-&gt;neighbors.push_back(dict[it]); // 将新点的拷贝放入neighbors中 &#125; &#125; return dict[node];&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]138.复制带随机指针的链表]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[方法一:递归12345678910unordered_map&lt;Node*,Node*&gt; dict;Node* copyRandomList(Node* head) &#123; if (!head) return head; if (dict.count(head)) return dict[head]; dict[head]=new Node(head-&gt;val, nullptr, nullptr); dict[head]-&gt;next=copyRandomList(head-&gt;next); dict[head]-&gt;random=copyRandomList(head-&gt;random); return dict[head];&#125; 方法二:非递归12345678910111213141516171819Node* copyRandomList(Node* head) &#123; if (!head) return head; unordered_map&lt;Node*,Node*&gt; m; Node *p=head; while(p) // make a copy of nodes &#123; m[p]=new Node(p-&gt;val,nullptr,nullptr); p=p-&gt;next; &#125; p=head; while(p) // link everyone and fill the random field &#123; m[p]-&gt;next=m[p-&gt;next]; m[p]-&gt;random=m[p-&gt;random]; p=p-&gt;next; &#125; return m[head];&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]144.二叉树的前序遍历]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[前往二叉树的:前序,中序,后序 遍历算法 方法一:递归123456789vector&lt;int&gt; res;vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; if (!root) return res; res.push_back(root-&gt;val); if (root-&gt;left) preorderTraversal(root-&gt;left); if (root-&gt;right) preorderTraversal(root-&gt;right); return res;&#125; 方法二:非递归1234567891011121314151617181920212223vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if (!root) return res; stack&lt;TreeNode*&gt; S; TreeNode* p = root; while(p||!S.empty()) &#123; if (p) // 访问左子树 &#123; res.push_back(p-&gt;val); S.push(p); p=p-&gt;left; &#125; else // 访问右子树 &#123; p=S.top(); S.pop(); p=p-&gt;right; &#125; &#125; return res;&#125; 方法三:非递归(该方法可用于后序遍历,需要修改几处代码)12345678910111213141516vector&lt;int&gt; res;vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; if (!root) return res; stack&lt;TreeNode*&gt; S; S.push(root); while (!S.empty()) &#123; root=S.top(); S.pop(); if (root-&gt;right) S.push(root-&gt;right); // 要实现后序遍历,需要以下两行调换 if (root-&gt;left) S.push(root-&gt;left); res.push_back(root-&gt;val); // res.insert(0,root-&gt;val)即为后序遍历 &#125; return res;&#125; 结论: 方法三这种形式只适合前序和后序遍历,不适合中序遍历,中序遍历较为麻烦 方法二这种形式只适合前序和中序遍历,不适合后序遍历,后序遍历较为麻烦]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>递归</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]94.二叉树的中序遍历]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[前往二叉树的:前序,中序,后序 遍历算法 方法一:递归123456789vector&lt;int&gt; res;vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; if (!root) return res; if (root-&gt;left) inorderTraversal(root-&gt;left); res.push_back(root-&gt;val); if (root-&gt;right) inorderTraversal(root-&gt;right); return res;&#125; 方法二:非递归1234567891011121314151617181920212223vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if (!root) return res; stack&lt;TreeNode*&gt; S; TreeNode* p = root; while(p||!S.empty()) &#123; if (p) &#123; S.push(p); p=p-&gt;left; &#125; else &#123; p=S.top(); S.pop(); res.push_back(p-&gt;val); p=p-&gt;right; &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>递归</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]145.二叉树的后序遍历]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[前往二叉树的:前序,中序,后序 遍历算法 方法一:递归123456789vector&lt;int&gt; res;vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; if (!root) return res; if (root-&gt;left) postorderTraversal(root-&gt;left); if (root-&gt;right) postorderTraversal(root-&gt;right); res.push_back(root-&gt;val); return res;&#125; 方法二:非递归1234567891011121314151617181920212223242526272829vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if (!root) return res; stack&lt;TreeNode*&gt; S; TreeNode* p=root, *r=nullptr; while (p||!S.empty()) &#123; if (p) &#123; S.push(p); p=p-&gt;left; &#125; else &#123; p=S.top(); if (p-&gt;right&amp;&amp;p-&gt;right!=r) p=p-&gt;right; else &#123; S.pop(); res.push_back(p-&gt;val); r=p; p=nullptr; &#125; &#125; &#125; return res; &#125; 方法三:非递归1234567891011121314151617vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if (!root) return res; stack&lt;TreeNode*&gt; S; TreeNode* p=root; S.push(p); while (!S.empty()) &#123; p=S.top(); S.pop(); if (p-&gt;left) S.push(p-&gt;left); if (p-&gt;right) S.push(p-&gt;right); res.insert(res.begin(),p-&gt;val); &#125; return res;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>递归</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]968.监控二叉树]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[解题思路: 由于叶子节点一定不要安装监视器,这样才能使总监视器数量比较少,因此需要从下往上进行判断当前节点的状态(共:3种状态): 0: 当前节点安装了监视器 1: 当前节点可观,但没有安装监视器 2: 当前节点不可观对于空节点,我们认为是可观,但没有安装监视器,因此,叶子节点就为不可观的了,设想一个节点的左右孩子(为空)都可观且没有安装监视器,那该节点必然是不可观即2 有了以上对空节点和叶子节点的处理,我们再来正式分析非终端节点: 若一个节点的左孩子或右孩子不可观,那么该节点必然不可观,需要安装监视器,因此返回0状态 若一个节点的左孩子或右孩子都可观且至少有一个安装了监视器,那么该节点必然是可观的,返回1状态 若一个节点的左右孩子都可观且没安装监视器,那么该节点必然是不可观的,返回2状态记住,我们以上的分析都是基于从整个二叉树的叶子节点往根部,即从下往上进行,而且要做的就是将不可观的节点变得可观才行(因此要根据左右孩子的节点的状态来判断当前节点状态并做出调整) 这里可能会有疑惑,以上的第一条得出当前节点不可观,然后安装了监视器,而第三条也得出当前节点不可观,但却没有安装监视器,而是直接返回的2状态(当前节点不可观).这是为什么? 因为,对于第一条,因为左右孩子都不可观,为了让左右孩子都可观,则必须给当前节点安装监视器才行,而第三条中,左右孩子都是可观的(没有安装监视器),当前节点的可以直接返回不可观状态,因为后面可以由他的父节点进行摄像头安装,使其变得可观. 方法一:递归12345678910111213141516171819202122232425// 0：该节点安装了监视器 1：该节点可观，但没有安装监视器 2：该节点不可观int monitor = 0;int state(TreeNode* node)&#123; if (node == nullptr) return 1; int left = state(node-&gt;left); int right = state(node-&gt;right); // 该节点为0的情况 if (left == 2 || right == 2) &#123; monitor++; // 由于左或右节点不可观,则需要给当前节点安装监视器,为0状态 return 0; &#125; // 为1的情况 else if (left == 0 || right == 0) return 1; // 当(left!=2&amp;&amp;right!=2)时,才会进行该判断,也就是左右节点一定是可观的,再判断是否有一个安装了监视器,如有安装,则当前节点就不需要安装监视器也可观了,为1状态 // 为2的情况 else // 其他:党(left!=2&amp;&amp;right!=2)&amp;&amp;(left!=0&amp;&amp;right!=0),即left==1&amp;&amp;right==1时,左右节点都可观,但没有监视器,当前节点不可观,为2状态 return 2;&#125;int minCameraCover(TreeNode *root)&#123; if (root == nullptr) return 0; if (state(root) == 2) monitor++; // 如果根节点为2的状态,需要加一个监视器 return monitor;&#125; 注意:这里的if,else if,else的顺序是不能变的,先判断左右都是不可观的,再就是都可观,左或右至少有一个为监视器,最后才是都可观都无监视器.]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]106.从中序与后序遍历序列构造二叉树]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[前往 中序,后序遍历构造二叉树, 中序,前序遍历构造二叉树12345678910111213141516TreeNode* build(vector&lt;int&gt;&amp; inorder, int l1, int r1, vector&lt;int&gt;&amp;postorder, int l2, int r2)&#123; if (l1&gt;r1) return nullptr; int x = postorder[r2], i = 0; // 确定当前根节点 for (i = l1; i &lt;= r1 &amp;&amp; inorder[i] != x; ++i); // 在中序遍历序列中找到当前根节点位置(该位置可以划分出左右两个分支) int llen = i - l1; // 左子树结点数量 int rlen = r1 - i; // 右子树结点数量 TreeNode* p = new TreeNode(x); // 建立根节点 p-&gt;left = build(inorder, l1, l1 + llen - 1, postorder, l2, l2 + llen - 1); // 递归建立左子树,-1,-1是把当前根节点位置去掉 p-&gt;right = build(inorder, r1 - rlen + 1, r1, postorder, r2 - rlen, r2 - 1); // 递归建立右子树,+1,-1是把当前根节点位置去掉 return p;&#125;TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; if (inorder.empty()||postorder.empty()) return nullptr; return build(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1);&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>递归</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]105.从前序与中序遍历序列构造二叉树]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[前往 中序,后序遍历构造二叉树, 中序,前序遍历构造二叉树12345678910111213141516TreeNode* build(vector&lt;int&gt;&amp; preorder, int l1, int r1, vector&lt;int&gt;&amp; inorder, int l2, int r2)&#123; if (l1&gt;r1) return nullptr; int x=preorder[l1], i=0; // 确定当前根节点 for(i=l2;inorder[i]!=x&amp;&amp;i&lt;r2;++i); // 在中序遍历序列中找到当前根节点位置(该位置可以划分出左右两个分支) int llen=i-l2; // 左子树结点数量 int rlen=r2-i; // 右子树结点数量 TreeNode *p = new TreeNode(x); // 建立根节点 p-&gt;left = build(preorder, l1+1, l1+llen, inorder, l2, l2+llen-1); // 递归建立左子树,+1,-1是把当前根节点位置去掉 p-&gt;right= build(preorder, r1-rlen+1, r1, inorder, r2-rlen+1, r2); // 递归建立右子树,+1,+1是把当前根节点位置去掉 return p;&#125;TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; return build(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1);&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>递归</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]114.二叉树展开为链表]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[思路:递归,将左子树变成单链表形式,再将右子树变成单链表形式,最后将左子树单链表的末端连接到右子树单链表表头,将根节点的左孩子置空 方法一: 递归1234567891011121314void flatten(TreeNode* root) &#123; if (root==nullptr) return; flatten(root-&gt;left); // 将左子树变成单链表形式 flatten(root-&gt;right); // 将右子树变成单链表形式 if (root-&gt;left) // 将左子树单链表的末端连接到右子树单链表表头 &#123; TreeNode* p=root-&gt;left; while(p-&gt;right) p=p-&gt;right; p-&gt;right=root-&gt;right; root-&gt;right=root-&gt;left; root-&gt;left=nullptr; &#125;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>递归</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]239.滑动窗口最大值]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[思路:滑动窗口的思想,只要是求连续子序列或者子串问题,都可用滑动窗口的思想 方法一: 滑动窗口123456789101112131415161718vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; res; if (nums.size()==0) return res; int i=0; deque&lt;int&gt; dq; for (i=0;i&lt;nums.size();++i) &#123; while(!dq.empty()&amp;&amp;nums[i]&gt;nums[dq.back()]) //在尾部添加元素，并保证左边元素都比尾部大 dq.pop_back(); dq.push_back(i); if (i-k==dq.front()) //在头部移除元素 dq.pop_front(); if (i&gt;=k-1) res.push_back(nums[dq.front()]); // 存放每次窗口内的最大值 &#125; return res;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]76.最小覆盖子串]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[思路:滑动窗口思想 方法一:滑动窗口1234567891011121314151617181920212223242526272829303132333435363738string minWindow(string s, string t) &#123; // 1.tdict记录T中每个字母与字母个数 // 2.维护一个滑动窗口字母的计数表sdict,计数当前窗口内T中字母出现的次数 // 3.当窗口内T中字母出现的次数大于等于T中每个字母出现的次数一样,这时第一个最短子串出现,再逐步从左边缩短窗口,直到不满足上述条件,然后再从右边扩大窗口,直到满足条件时,再进行最短子串长度对比,一直更新最短长度子串直到结束 if (s.size()&lt;t.size()||s.size()==0) return ""; unordered_map&lt;char,int&gt; tdict,sdict; int l=0,r=0,k=t.size(); for(auto it:t) // 填充T的字母与字母计数表 &#123; if (!tdict.count(it)) tdict[it]=1; else tdict[it]++; &#125; string res=""; for(r=0;r&lt;s.size();++r) &#123; if (tdict.count(s[r])) // 有字符,则进行记录 &#123; if (!sdict.count(s[r])) sdict[s[r]]=0; sdict[s[r]]++; if (sdict[s[r]]&lt;=tdict[s[r]]) k--; &#125; while(k==0) // 满足条件,滑动窗口从左边逐步缩短,直到剔除第一个属于T中的字符为止 &#123; if (res.empty()||r-l+1&lt;res.size()) // 最短子串更新 res=s.substr(l,r-l+1); if(tdict.count(s[l])) &#123; sdict[s[l]]--; if (sdict[s[l]]&lt;tdict[s[l]]) k++; &#125; l++; &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]3.无重复字符的最长子串]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[思路:滑动窗口的思想 方法一:滑动窗口123456789101112131415161718192021int lengthOfLongestSubstring(string s) &#123; /* 控制一个滑动窗口,窗口内的字符都是不重复的,通过set可以做到判断字符是否重复 */ unordered_set&lt;char&gt; set; size_t maxL=0; for(int l=0,r=0;r&lt;s.size();++r) &#123; if (!set.count(s[r])) // 当前判断的元素不存在于滑动窗口[l,r-1]中 set.insert(s[r]); // 将元素放入滑动窗口(即记录不重复字符) else // 当前判断的元素已经存在于滑动窗口[l,r-1]中 &#123; while(set.count(s[r])) // 从左缩短窗口,直到剔除当前判断的元素为止 set.erase(s[l++]); set.insert(s[r]); // 将当前判断元素放入到滑动窗口中 &#125; maxL=max(maxL,set.size()); // 更新无重复字符的最长子串 &#125; return maxL;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]1028.从先序遍历还原二叉树]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-1028-%E4%BB%8E%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[思路:用一个栈来管理树的层次关系,索引代表节点的深度 方法一:123456789101112131415161718192021222324252627TreeNode* recoverFromPreorder(string S) &#123; /* 由题意知,最上层节点深度为0(数字前面0条横线),而第二层节点前有1条横线,表示深度为1 树的前序遍历: 根-左-右 因此, */ if (S.empty()) return nullptr; vector&lt;TreeNode*&gt; stack; // 结果栈 for(int i=0,depth=0,val=0;i&lt;S.size();) &#123; for(depth=0;i&lt;S.size()&amp;&amp;S[i]=='-';++i) // 计算节点的深度 depth++; for(val=0;i&lt;S.size()&amp;&amp;S[i]!='-';++i) // 计算数值 val=val*10+S[i]-'0'; while (stack.size()&gt;depth) // 若当前栈的长度(树的高度)大于节点的深度,则可以把栈中最后几个节点pop掉(这些节点各已经成为完整的子树,可以pop掉了) stack.pop_back(); TreeNode* node=new TreeNode(val); // 新建节点用于存放当前深度的结点 if (!stack.empty()) // 节点间关联 &#123; if (!stack.back()-&gt;left) stack.back()-&gt;left=node; else if(!stack.back()-&gt;right) stack.back()-&gt;right=node; &#125; stack.push_back(node); &#125; return stack[0];&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]5040.边框着色]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-5040-%E8%BE%B9%E6%A1%86%E7%9D%80%E8%89%B2%2F</url>
    <content type="text"><![CDATA[方法一：dfs的非递归形式1234567891011121314151617181920212223242526272829using ll=long long;const ll MAXN=50LL;unordered_set&lt;ll&gt; vis,mark;vector&lt;vector&lt;int&gt;&gt; colorBorder(vector&lt;vector&lt;int&gt;&gt;&amp; G, int r0, int c0, int color) &#123; queue&lt;ll&gt; Q; Q.push(r0*MAXN+c0); int c=G[r0][c0]; int dx[]=&#123;-1,1,0,0&#125;,dy[]=&#123;0,0,-1,1&#125;; while (!Q.empty()) &#123; int x=Q.front()/MAXN; int y=Q.front()%MAXN; Q.pop(); vis.insert(x*MAXN+y); if (x==0||x==G.size()-1||y==0||y==G[0].size()-1) // 边界方块可变色 mark.insert(x*MAXN+y); else if (G[x-1][y]!=c||G[x+1][y]!=c||G[x][y-1]!=c||G[x][y+1]!=c) // 四个方向中,任意一个方块颜色不同,则可变色 mark.insert(x*MAXN+y); for (int d=0;d&lt;4;d++) // 放入连通分量的所有方块 &#123; int nx=x+dx[d],ny=y+dy[d]; if (0&lt;=nx&amp;&amp;nx&lt;G.size()&amp;&amp;0&lt;=ny&amp;&amp;ny&lt;G[0].size()&amp;&amp;!vis.count(nx*MAXN+ny)&amp;&amp;G[nx][ny]==c) Q.push(nx*MAXN+ny); &#125; &#125; for (auto it:mark) G[it/MAXN][it%MAXN]=color; return G;&#125; 思路:用vis记录访问过的方块,mark标记连通分量中需要修改颜色的方块,并非连通分量中所有的方块都要修改颜色,比如:一个方块如果四周(四个方向邻接的)都是相同颜色,那么只需要修改四周方块的颜色,而自己颜色不变(开始的时候没理解题意,以为只要是连通分量内的方块颜色都需要改变) 方法二: dfs递归形式,只不过把上面的非递归改为递归了123456789101112131415161718192021222324using ll=long long;const ll MAXN=50LL;unordered_set&lt;ll&gt; vis,mark;void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; G, int x, int y, int c)&#123; int dx[]=&#123;-1,1,0,0&#125;,dy[]=&#123;0,0,-1,1&#125;; vis.insert(x*MAXN+y); if (x==0||x==G.size()-1||y==0||y==G[0].size()-1) // 边界方块可变色 mark.insert(x*MAXN+y); else if (G[x-1][y]!=c||G[x+1][y]!=c||G[x][y-1]!=c||G[x][y+1]!=c) // 四个方向中,任意一个方块颜色不同,则可变色 mark.insert(x*MAXN+y); for (int d=0;d&lt;4;d++) // 放入连通分量的所有方块 &#123; int nx=x+dx[d],ny=y+dy[d]; if (0&lt;=nx&amp;&amp;nx&lt;G.size()&amp;&amp;0&lt;=ny&amp;&amp;ny&lt;G[0].size()&amp;&amp;!vis.count(nx*MAXN+ny)&amp;&amp;G[nx][ny]==c) dfs(G,nx,ny,c); &#125;&#125;vector&lt;vector&lt;int&gt;&gt; colorBorder(vector&lt;vector&lt;int&gt;&gt;&amp; G, int r0, int c0, int color) &#123; dfs(G,r0,c0,G[r0][c0]); for (auto it:mark) G[it/MAXN][it%MAXN]=color; return G;&#125; 方法三:dfs递归,但通过修改G中的数据,来记录是否访问过,和是否需要修改颜色,国外的一个大佬写的From an initial point, perform DFS and flip the cell color to negative to track visited cells.After DFS is complete for the cell, check if this cell is inside. If so, flip its color back to the positive.In the end, cells with the negative color are on the border. Change their color to the target color.1234567891011121314void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; g, int r, int c, int cl) &#123; if (r &lt; 0 || c &lt; 0 || r &gt;= g.size() || c &gt;= g[r].size() || g[r][c] != cl) return; // 剪枝(越界,非着色块) g[r][c] = -cl; // 着色 dfs(g, r - 1, c, cl), dfs(g, r + 1, c, cl), dfs(g, r, c - 1, cl), dfs(g, r, c + 1, cl); if (r &gt; 0 &amp;&amp; r &lt; g.size() - 1 &amp;&amp; c &gt; 0 &amp;&amp; c &lt; g[r].size() - 1 &amp;&amp; cl == abs(g[r - 1][c]) &amp;&amp; cl == abs(g[r + 1][c]) &amp;&amp; cl == abs(g[r][c - 1]) &amp;&amp; cl == abs(g[r][c + 1])) // 将原四周同色的块,颜色还原 g[r][c] = cl;&#125;vector&lt;vector&lt;int&gt;&gt; colorBorder(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int r0, int c0, int color) &#123; dfs(grid, r0, c0, grid[r0][c0]); for (auto i = 0; i &lt; grid.size(); ++i) // 根据dfs标记(负数)过的方块进行着色 for (auto j = 0; j &lt; grid[i].size(); ++j) grid[i][j] = grid[i][j] &lt; 0 ? color : grid[i][j]; return grid;&#125; 结论: 无论是递归还是非递归,先标记(标记vis),再遍历]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]5.最长回文子串]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[方法一:中心扩展算法解题思路:从左到右每一个字符都作为中心轴,然后逐渐往两边扩展,只要发现有不相等的字符,则确定了以该字符为轴的最长回文串,但需要考虑长度为奇数和偶数的不同情况的处理(长度为偶数时轴心为中间两个数的中心,长度为奇数时轴心为中间那个数) 算法时间复杂度: $O(n^{2})$12345678910111213141516171819202122232425262728string longestPalindrome(string s) &#123; int idx = 0, maxL = 0; for (int i = 0; i &lt; s.size(); ++i) // i为轴的位置,j为回文串半径 &#123; for (int j = 0; i - j &gt;= 0 &amp;&amp; i + j &lt; s.size(); ++j) // 奇数 &#123; if (s[i - j] != s[i + j]) break; if (2 * j + 1 &gt; maxL) &#123; maxL = 2 * j + 1; idx = i - j; &#125; &#125; for (int j = 0; i - j &gt;= 0 &amp;&amp; i + j + 1 &lt; s.size(); ++j) // 偶数 &#123; if (s[i-j]!=s[i+j+1]) break; if (2 * j + 2 &gt; maxL) &#123; maxL = 2 * j + 2; idx = i - j; &#125; &#125; &#125; return s.substr(idx, maxL);&#125; 方法二: manacher(马拉车法)解题思路:详见P3805【模板】manacher算法为了使奇数串和偶数串一致性处理,首先进行字符填充,使其成为奇数串,即在每个字符的前后填充字符,例如:原串: ABCCBA填充后: ~#A#B#C#C#B#A#原始串在数组中的位置: A B C C B A 0 1 2 3 4 5 填充串在数组中的位置 ~ # A # B # C # C # B # A # 0 1 2 3 4 5 6 7 8 9 10 11 12 13 首先说明: 奇数+偶数=奇数, 因此,奇数串填充偶数个#后为奇数串,偶数串填充奇数个#后为奇数串 ~字符用来作为边界,用处在于进行两边扩展时做为结束条件 填充串中字符的最大回文半径 - 1 = 原字符串中该字符的回文串长度 关于上述第3条我需要解释一下: s_copy ~ # A # B # C # C # B # A # index 0 1 2 3 4 5 6 7 8 9 10 11 12 13 pos 0 0 0 0 1 1 2 2 3 3 4 4 5 5 p 0 1 2 1 2 1 2 7 2 1 2 1 2 1 可以看到index=7的位置,#对应的p为7(即最大回文半径),即在C与C之间,表示原字符串中该字符的回文长度为6,那么原字符串ABCCBA的前面3个字符ABC构成的回文串长度为6 该题思路: 字符串填充统一为奇数串 Manacher法,从左到右遍历每个字符 记录每个字符的最大回文半径 确定已经记录的最大回文串右边界r,和中间轴m 当前字符s[i]是否能关于m找到一个对称点,即要满足:m&lt;=i&lt;=r 能:则得到一个有可能的最大回文半径,并从该半径开始扩展 否:则从新计算最大回文半径 算法时间复杂度为: $O(n)$1234567891011121314151617181920212223242526272829303132333435363738394041int pos[2005],p[2005]; // pos用于记录填充串与原始字串的位置关系,p用于记录填充串当前字符的最大回文半径string longestPalindrome(string s) &#123; /* 填充字符,统一为奇数串 */ string s_new="~"; for (int i=0,k=1;i&lt;s.size();++i) &#123; s_new+="#"; s_new+=s[i]; pos[k++]=i; pos[k++]=i; &#125; s_new+="#"; /* manacher */ int m=0,r=0,maxL=0,idx=0; for (int i=1;i&lt;s_new.size();++i) &#123; // 获取已知的最大回文半径,p[i]用于记录填充串对应字符的最大回文半径 if (i&lt;r) p[i]=min(p[2*m-i],r-i); // 当m&lt;=i&lt;=r时,i关于m中心轴对称的点为2*m-i,而p[2*m-i]是一定已经知道的 else p[i]=1; // 如果i超出了已知的最大回文右边界,则比如不能找到关于m对称的点,只能重新计算最大回文半径 // 暴力拓展左右两侧,计算当前的最大回文半径 while (s_new[i-p[i]]==s_new[i+p[i]]) p[i]++; // 新的回文半径比较大,则更新 if (r-i&lt;p[i]) &#123; m=i; r=i+p[i]; &#125; // 更新回文长度(原始字串的回文长度为新字串回文半径-1) if (p[i]-1&gt;=maxL) &#123; maxL=p[i]-1; idx=pos[i]-maxL/2; // 更新原始回文字串的起始位置 &#125; &#125; return s.substr(idx,maxL);&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回文串</tag>
      </tags>
  </entry>
</search>
