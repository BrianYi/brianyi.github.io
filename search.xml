<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[leetcode]106.从中序与后序遍历序列构造二叉树]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[前往 中序,后序遍历构造二叉树, 中序,前序遍历构造二叉树12345678910111213141516TreeNode* build(vector&lt;int&gt;&amp; inorder, int l1, int r1, vector&lt;int&gt;&amp;postorder, int l2, int r2)&#123; if (l1&gt;r1) return nullptr; int x = postorder[r2], i = 0; // 确定当前根节点 for (i = l1; i &lt;= r1 &amp;&amp; inorder[i] != x; ++i); // 在中序遍历序列中找到当前根节点位置(该位置可以划分出左右两个分支) int llen = i - l1; // 左子树结点数量 int rlen = r1 - i; // 右子树结点数量 TreeNode* p = new TreeNode(x); // 建立根节点 p-&gt;left = build(inorder, l1, l1 + llen - 1, postorder, l2, l2 + llen - 1); // 递归建立左子树,-1,-1是把当前根节点位置去掉 p-&gt;right = build(inorder, r1 - rlen + 1, r1, postorder, r2 - rlen, r2 - 1); // 递归建立右子树,+1,-1是把当前根节点位置去掉 return p;&#125;TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; if (inorder.empty()||postorder.empty()) return nullptr; return build(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1);&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]105.从前序与中序遍历序列构造二叉树]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[前往 中序,后序遍历构造二叉树, 中序,前序遍历构造二叉树12345678910111213141516TreeNode* build(vector&lt;int&gt;&amp; preorder, int l1, int r1, vector&lt;int&gt;&amp; inorder, int l2, int r2)&#123; if (l1&gt;r1) return nullptr; int x=preorder[l1], i=0; // 确定当前根节点 for(i=l2;inorder[i]!=x&amp;&amp;i&lt;r2;++i); // 在中序遍历序列中找到当前根节点位置(该位置可以划分出左右两个分支) int llen=i-l2; // 左子树结点数量 int rlen=r2-i; // 右子树结点数量 TreeNode *p = new TreeNode(x); // 建立根节点 p-&gt;left = build(preorder, l1+1, l1+llen, inorder, l2, l2+llen-1); // 递归建立左子树,+1,-1是把当前根节点位置去掉 p-&gt;right= build(preorder, r1-rlen+1, r1, inorder, r2-rlen+1, r2); // 递归建立右子树,+1,+1是把当前根节点位置去掉 return p;&#125;TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; return build(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1);&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]114.二叉树展开为链表]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[思路:递归,将左子树变成单链表形式,再将右子树变成单链表形式,最后将左子树单链表的末端连接到右子树单链表表头,将根节点的左孩子置空 方法一: 递归1234567891011121314void flatten(TreeNode* root) &#123; if (root==nullptr) return; flatten(root-&gt;left); // 将左子树变成单链表形式 flatten(root-&gt;right); // 将右子树变成单链表形式 if (root-&gt;left) // 将左子树单链表的末端连接到右子树单链表表头 &#123; TreeNode* p=root-&gt;left; while(p-&gt;right) p=p-&gt;right; p-&gt;right=root-&gt;right; root-&gt;right=root-&gt;left; root-&gt;left=nullptr; &#125;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]239.滑动窗口最大值]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[思路:滑动窗口的思想,只要是求连续子序列或者子串问题,都可用滑动窗口的思想 方法一: 滑动窗口123456789101112131415161718vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; res; if (nums.size()==0) return res; int i=0; deque&lt;int&gt; dq; for (i=0;i&lt;nums.size();++i) &#123; while(!dq.empty()&amp;&amp;nums[i]&gt;nums[dq.back()]) //在尾部添加元素，并保证左边元素都比尾部大 dq.pop_back(); dq.push_back(i); if (i-k==dq.front()) //在头部移除元素 dq.pop_front(); if (i&gt;=k-1) res.push_back(nums[dq.front()]); // 存放每次窗口内的最大值 &#125; return res;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]76.最小覆盖子串]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[思路:滑动窗口思想 方法一:滑动窗口1234567891011121314151617181920212223242526272829303132333435363738string minWindow(string s, string t) &#123; // 1.tdict记录T中每个字母与字母个数 // 2.维护一个滑动窗口字母的计数表sdict,计数当前窗口内T中字母出现的次数 // 3.当窗口内T中字母出现的次数大于等于T中每个字母出现的次数一样,这时第一个最短子串出现,再逐步从左边缩短窗口,直到不满足上述条件,然后再从右边扩大窗口,直到满足条件时,再进行最短子串长度对比,一直更新最短长度子串直到结束 if (s.size()&lt;t.size()||s.size()==0) return ""; unordered_map&lt;char,int&gt; tdict,sdict; int l=0,r=0,k=t.size(); for(auto it:t) // 填充T的字母与字母计数表 &#123; if (!tdict.count(it)) tdict[it]=1; else tdict[it]++; &#125; string res=""; for(r=0;r&lt;s.size();++r) &#123; if (tdict.count(s[r])) // 有字符,则进行记录 &#123; if (!sdict.count(s[r])) sdict[s[r]]=0; sdict[s[r]]++; if (sdict[s[r]]&lt;=tdict[s[r]]) k--; &#125; while(k==0) // 满足条件,滑动窗口从左边逐步缩短,直到剔除第一个属于T中的字符为止 &#123; if (res.empty()||r-l+1&lt;res.size()) // 最短子串更新 res=s.substr(l,r-l+1); if(tdict.count(s[l])) &#123; sdict[s[l]]--; if (sdict[s[l]]&lt;tdict[s[l]]) k++; &#125; l++; &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]3.无重复字符的最长子串]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[思路:滑动窗口的思想 方法一:滑动窗口123456789101112131415161718192021int lengthOfLongestSubstring(string s) &#123; /* 控制一个滑动窗口,窗口内的字符都是不重复的,通过set可以做到判断字符是否重复 */ unordered_set&lt;char&gt; set; size_t maxL=0; for(int l=0,r=0;r&lt;s.size();++r) &#123; if (!set.count(s[r])) // 当前判断的元素不存在于滑动窗口[l,r-1]中 set.insert(s[r]); // 将元素放入滑动窗口(即记录不重复字符) else // 当前判断的元素已经存在于滑动窗口[l,r-1]中 &#123; while(set.count(s[r])) // 从左缩短窗口,直到剔除当前判断的元素为止 set.erase(s[l++]); set.insert(s[r]); // 将当前判断元素放入到滑动窗口中 &#125; maxL=max(maxL,set.size()); // 更新无重复字符的最长子串 &#125; return maxL;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]1028.从先序遍历还原二叉树]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-1028-%E4%BB%8E%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[思路:用一个栈来管理树的层次关系,索引代表节点的深度 方法一:123456789101112131415161718192021222324252627TreeNode* recoverFromPreorder(string S) &#123; /* 由题意知,最上层节点深度为0(数字前面0条横线),而第二层节点前有1条横线,表示深度为1 树的前序遍历: 根-左-右 因此, */ if (S.empty()) return nullptr; vector&lt;TreeNode*&gt; stack; // 结果栈 for(int i=0,depth=0,val=0;i&lt;S.size();) &#123; for(depth=0;i&lt;S.size()&amp;&amp;S[i]=='-';++i) // 计算节点的深度 depth++; for(val=0;i&lt;S.size()&amp;&amp;S[i]!='-';++i) // 计算数值 val=val*10+S[i]-'0'; while (stack.size()&gt;depth) // 若当前栈的长度(树的高度)大于节点的深度,则可以把栈中最后几个节点pop掉(这些节点各已经成为完整的子树,可以pop掉了) stack.pop_back(); TreeNode* node=new TreeNode(val); // 新建节点用于存放当前深度的结点 if (!stack.empty()) // 节点间关联 &#123; if (!stack.back()-&gt;left) stack.back()-&gt;left=node; else if(!stack.back()-&gt;right) stack.back()-&gt;right=node; &#125; stack.push_back(node); &#125; return stack[0];&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]5040.边框着色]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-5040-%E8%BE%B9%E6%A1%86%E7%9D%80%E8%89%B2%2F</url>
    <content type="text"><![CDATA[方法一：dfs的非递归形式1234567891011121314151617181920212223242526272829using ll=long long;const ll MAXN=50LL;unordered_set&lt;ll&gt; vis,mark;vector&lt;vector&lt;int&gt;&gt; colorBorder(vector&lt;vector&lt;int&gt;&gt;&amp; G, int r0, int c0, int color) &#123; queue&lt;ll&gt; Q; Q.push(r0*MAXN+c0); int c=G[r0][c0]; int dx[]=&#123;-1,1,0,0&#125;,dy[]=&#123;0,0,-1,1&#125;; while (!Q.empty()) &#123; int x=Q.front()/MAXN; int y=Q.front()%MAXN; Q.pop(); vis.insert(x*MAXN+y); if (x==0||x==G.size()-1||y==0||y==G[0].size()-1) // 边界方块可变色 mark.insert(x*MAXN+y); else if (G[x-1][y]!=c||G[x+1][y]!=c||G[x][y-1]!=c||G[x][y+1]!=c) // 四个方向中,任意一个方块颜色不同,则可变色 mark.insert(x*MAXN+y); for (int d=0;d&lt;4;d++) // 放入连通分量的所有方块 &#123; int nx=x+dx[d],ny=y+dy[d]; if (0&lt;=nx&amp;&amp;nx&lt;G.size()&amp;&amp;0&lt;=ny&amp;&amp;ny&lt;G[0].size()&amp;&amp;!vis.count(nx*MAXN+ny)&amp;&amp;G[nx][ny]==c) Q.push(nx*MAXN+ny); &#125; &#125; for (auto it:mark) G[it/MAXN][it%MAXN]=color; return G;&#125; 思路:用vis记录访问过的方块,mark标记连通分量中需要修改颜色的方块,并非连通分量中所有的方块都要修改颜色,比如:一个方块如果四周(四个方向邻接的)都是相同颜色,那么只需要修改四周方块的颜色,而自己颜色不变(开始的时候没理解题意,以为只要是连通分量内的方块颜色都需要改变) 方法二: dfs递归形式,只不过把上面的非递归改为递归了123456789101112131415161718192021222324using ll=long long;const ll MAXN=50LL;unordered_set&lt;ll&gt; vis,mark;void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; G, int x, int y, int c)&#123; int dx[]=&#123;-1,1,0,0&#125;,dy[]=&#123;0,0,-1,1&#125;; vis.insert(x*MAXN+y); if (x==0||x==G.size()-1||y==0||y==G[0].size()-1) // 边界方块可变色 mark.insert(x*MAXN+y); else if (G[x-1][y]!=c||G[x+1][y]!=c||G[x][y-1]!=c||G[x][y+1]!=c) // 四个方向中,任意一个方块颜色不同,则可变色 mark.insert(x*MAXN+y); for (int d=0;d&lt;4;d++) // 放入连通分量的所有方块 &#123; int nx=x+dx[d],ny=y+dy[d]; if (0&lt;=nx&amp;&amp;nx&lt;G.size()&amp;&amp;0&lt;=ny&amp;&amp;ny&lt;G[0].size()&amp;&amp;!vis.count(nx*MAXN+ny)&amp;&amp;G[nx][ny]==c) dfs(G,nx,ny,c); &#125;&#125;vector&lt;vector&lt;int&gt;&gt; colorBorder(vector&lt;vector&lt;int&gt;&gt;&amp; G, int r0, int c0, int color) &#123; dfs(G,r0,c0,G[r0][c0]); for (auto it:mark) G[it/MAXN][it%MAXN]=color; return G;&#125; 方法三:dfs递归,但通过修改G中的数据,来记录是否访问过,和是否需要修改颜色,国外的一个大佬写的From an initial point, perform DFS and flip the cell color to negative to track visited cells.After DFS is complete for the cell, check if this cell is inside. If so, flip its color back to the positive.In the end, cells with the negative color are on the border. Change their color to the target color.1234567891011121314void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; g, int r, int c, int cl) &#123; if (r &lt; 0 || c &lt; 0 || r &gt;= g.size() || c &gt;= g[r].size() || g[r][c] != cl) return; // 剪枝(越界,非着色块) g[r][c] = -cl; // 着色 dfs(g, r - 1, c, cl), dfs(g, r + 1, c, cl), dfs(g, r, c - 1, cl), dfs(g, r, c + 1, cl); if (r &gt; 0 &amp;&amp; r &lt; g.size() - 1 &amp;&amp; c &gt; 0 &amp;&amp; c &lt; g[r].size() - 1 &amp;&amp; cl == abs(g[r - 1][c]) &amp;&amp; cl == abs(g[r + 1][c]) &amp;&amp; cl == abs(g[r][c - 1]) &amp;&amp; cl == abs(g[r][c + 1])) // 将原四周同色的块,颜色还原 g[r][c] = cl;&#125;vector&lt;vector&lt;int&gt;&gt; colorBorder(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int r0, int c0, int color) &#123; dfs(grid, r0, c0, grid[r0][c0]); for (auto i = 0; i &lt; grid.size(); ++i) // 根据dfs标记(负数)过的方块进行着色 for (auto j = 0; j &lt; grid[i].size(); ++j) grid[i][j] = grid[i][j] &lt; 0 ? color : grid[i][j]; return grid;&#125; 结论: 无论是递归还是非递归,先标记(标记vis),再遍历]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]5.最长回文子串]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[方法一:中心扩展算法 解题思路:从左到右每一个字符都作为中心轴,然后逐渐往两边扩展,只要发现有不相等的字符,则确定了以该字符为轴的最长回文串,但需要考虑长度为奇数和偶数的不同情况的处理(长度为偶数时轴心为中间两个数的中心,长度为奇数时轴心为中间那个数) 算法时间复杂度:$O(n^{2})$12345678910111213141516171819202122232425262728string longestPalindrome(string s) &#123; int idx = 0, maxL = 0; for (int i = 0; i &lt; s.size(); ++i) // i为轴的位置,j为回文串半径 &#123; for (int j = 0; i - j &gt;= 0 &amp;&amp; i + j &lt; s.size(); ++j) // 奇数 &#123; if (s[i - j] != s[i + j]) break; if (2 * j + 1 &gt; maxL) &#123; maxL = 2 * j + 1; idx = i - j; &#125; &#125; for (int j = 0; i - j &gt;= 0 &amp;&amp; i + j + 1 &lt; s.size(); ++j) // 偶数 &#123; if (s[i-j]!=s[i+j+1]) break; if (2 * j + 2 &gt; maxL) &#123; maxL = 2 * j + 2; idx = i - j; &#125; &#125; &#125; return s.substr(idx, maxL);&#125;方法二:manacher(马拉车法) 解题思路:详见P3805【模板】manacher算法 算法时间复杂度为:$O(n)$1234567891011121314151617181920212223242526272829303132333435363738394041int pos[2005],p[2005];string longestPalindrome(string s) &#123; /* 填充字符,统一为奇数串 */ string s_new="~"; for (int i=0,k=1;i&lt;s.size();++i) &#123; s_new+="#"; s_new+=s[i]; pos[k++]=i; // 记录新字串与原始字串的位置关系 pos[k++]=i; &#125; s_new+="#"; /* manacher */ int m=0,r=0,maxL=0,idx=0; for (int i=1;i&lt;s_new.size();++i) &#123; // 获取已知的最小回文半径 if (i&lt;r) p[i]=min(p[2*m-i],r-i); else p[i]=1; // 暴力拓展左右两侧 while (s_new[i-p[i]]==s_new[i+p[i]]) p[i]++; // 新的回文半径比较大,则更新 if (r-i&lt;p[i]) &#123; m=i; r=i+p[i]; &#125; // 更新回文长度(原始字串的回文长度为新字串回文半径-1) if (p[i]-1&gt;maxL) &#123; maxL=p[i]-1; idx=pos[i]-maxL/2; // 更新原始回文字串的起始位置 &#125; &#125; return s.substr(idx,maxL);&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回文串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
</search>
